<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Blokko v1.4.0: -->
    <title>Blokko-‰∏™‰∫∫ÁÆÄ‰ªãÁîüÊàêÂô®ÔºÅ (v1.4.0)</title>
    
    <script>
        // Anti-FOUC (Flash of Unstyled Content) Script
        try {
            if (localStorage.getItem('blokkoTheme') === 'dark') {
                document.documentElement.classList.add('dark-mode');
            }
        } catch (e) {
            console.error('Failed to apply theme from localStorage', e);
        }
    </script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" />

    <!-- v1.3.1: Add Recommended Fonts via reliable CDN -->
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Sans+SC:400,700&display=swap">
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:400,700&display=swap">
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=ZCOOL+KuaiLe&display=swap">
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=ZCOOL+XiaoWei&display=swap">

    <style>
        /* CSS ÂèòÈáè */
        :root {
            --bg-editor: #ffffff; --bg-preview-pane: #f0f2f5; --bg-preview-page: #ffffff;
            --bg-card: #ffffff; --bg-input: #f9f9f9; --bg-section: #fdfdfd;
            --bg-modal-overlay: rgba(0, 0, 0, 0.6); --bg-inset: #f0f2f5;
            --bg-image-thumb: #eeeeee; --bg-image-upload-hover: #eef5ff;
            --text-primary: #1a1a1a; --text-secondary: #555555; --text-label: #333333;
            --text-placeholder: #999; --text-on-primary: #ffffff; --text-action: #007AFF;
            --border-color: #e8e8e8; --border-input: #d1d5db; --border-dashed: #cccccc;
            --shadow-light: rgba(0, 0, 0, 0.05); --shadow-medium: rgba(0, 0, 0, 0.08);
            --preset-text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
            --color-primary: #007AFF; --color-primary-hover: #0056CC; --color-danger: #ff4757;
            --color-danger-hover: #e03c48; --color-secondary: #8e8e93; --color-secondary-hover: #636366;
            --header-height: 55px; --transition-speed: 0.3s; --transition-short: 0.2s;
            /* Global Card Styles */
            --g-card-bg-color: var(--bg-card); --g-card-text-color: var(--text-primary); --g-card-opacity: 1;
            --g-card-shadow: 0 4px 12px rgba(0,0,0,0.08);
            --g-card-border-radius: 12px; --g-card-text-align: left;
            --g-card-line-height: 1.5; --g-card-font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --g-card-font-size: 1rem;
            --g-card-text-stroke: 0px transparent;
            --g-card-border: 1px solid transparent;
            /* Active Card Styles */
            --active-card-shadow: var(--g-card-shadow); --active-card-border: var(--g-card-border);
            --active-card-text-shadow: none; --active-card-font-family: var(--g-card-font-family);
            --active-card-font-size: var(--g-card-font-size); 
        }
        html.dark-mode {
            --bg-editor: #1f2229; --bg-preview-pane: #121417; --bg-preview-page: #1f2229;
            --bg-card: #2c303a; --bg-input: #2c303a; --bg-section: #252830;
            --bg-modal-overlay: rgba(0, 0, 0, 0.7); --bg-inset: #2c2c2e;
            --bg-image-thumb: #3e4451; --bg-image-upload-hover: #2c3e50;
            --text-primary: #f0f2f5; --text-secondary: #a0aec0; --text-label: #e2e8f0;
            --text-placeholder: #777; --text-on-primary: #ffffff; --text-action: #3498db;
            --border-color: #3e4451; --border-input: #4a5160; --border-dashed: #555;
            --shadow-light: rgba(0, 0, 0, 0.2); --shadow-medium: rgba(0, 0, 0, 0.3);
            --preset-text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            --g-card-bg-color: var(--bg-card); --g-card-text-color: var(--text-primary);
            --g-card-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { font-family: var(--g-card-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif); background-color: var(--bg-preview-pane); color: var(--text-primary); transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        .app-header { width: 100%; height: var(--header-height); background: var(--bg-editor); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; position: fixed; top: 0; left: 0; z-index: 100; box-shadow: 0 2px 8px var(--shadow-light); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        .header-actions-wrapper { display: flex; align-items: center; gap: 15px; }
        .app-header-title { font-size: 1.25rem; font-weight: 700; }
        .theme-switch-wrapper { display: flex; align-items: center; gap: 10px; }
        .theme-switch-wrapper span { font-size: 0.9rem; color: var(--text-secondary); }
        .app-container { display: flex; height: 100vh; padding-top: var(--header-height); }
        .editor-panel { width: 520px; min-width: 450px; max-width: 70vw; height: calc(100vh - var(--header-height)); overflow-y: auto; overflow-x: hidden; background: var(--bg-editor); border-right: 1px solid var(--border-color); padding: 25px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; flex-shrink: 0; }
        .resizer { width: 5px; height: calc(100vh - var(--header-height)); background: var(--border-color); cursor: col-resize; z-index: 50; flex-shrink: 0;}
        .resizer:hover { background: var(--color-primary); }
        .preview-panel { flex-grow: 1; height: calc(100vh - var(--header-height)); overflow-y: auto; display: flex; flex-direction: column; align-items: center; padding: 40px 20px; background: var(--bg-preview-pane); transition: background-color var(--transition-speed) ease; }
        body.export-mode .preview-panel { justify-content: flex-start; }
        .preview-wrapper { width: 100%; max-width: 600px; min-height: fit-content; border-radius: 20px; box-shadow: 0 4px 16px var(--shadow-medium); padding: 20px; padding-bottom: 40px; transition: all var(--transition-speed) ease; position: relative; overflow: hidden; font-family: var(--active-card-font-family); font-size: var(--active-card-font-size); }
        .preview-wrapper::before { content: none; } /* FIX: Layering - remove pseudo element for background image */
        .preview-overlay { display: none; } /* FIX: Layering - overlay is now baked into the background-image property */
        .preview-header, .preview-blocks-container { position: relative; z-index: 2; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box; }
        [data-state-key]:hover, [data-card-key]:hover, .tag-pill:hover { outline: 1px dashed var(--color-primary); cursor: text; }
        [contenteditable="true"] { outline: 2px solid var(--color-primary); box-shadow: 0 0 8px rgba(0, 122, 255, 0.5); background-color: rgba(0, 122, 255, 0.1); border-radius: 4px; }
        .btn { display: inline-block; border: none; padding: 10px 16px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: background-color var(--transition-short) ease, transform var(--transition-short) ease, box-shadow var(--transition-short) ease; text-align: center; width: 100%; color: var(--text-on-primary); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .btn-primary { background: var(--color-primary); } .btn-primary:hover:not(:disabled) { background: var(--color-primary-hover); box-shadow: 0 4px 8px rgba(0,122,255,0.3); }
        .btn-secondary { background: var(--color-secondary); } .btn-secondary:hover:not(:disabled) { background: var(--color-secondary-hover); box-shadow: 0 4px 8px rgba(142,142,147,0.3); }
        .btn-danger { background: var(--color-danger); } .btn-danger:hover:not(:disabled) { background: var(--color-danger-hover); box-shadow: 0 4px 8px rgba(255,71,87,0.3); }
        .btn-default { background-color: var(--bg-input); border: 1px solid var(--border-input); color: var(--text-secondary); } .btn-default:hover:not(:disabled) { background-color: var(--border-color); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .btn:active:not(:disabled) { transform: scale(0.98); } .btn:disabled { background: #999; cursor: not-allowed; opacity: 0.6; }
        .btn-small { padding: 6px 10px; font-size: 0.9rem; }
        .btn-icon { width: auto; padding: 6px 10px; font-size: 0.9rem; display: flex; align-items: center; justify-content: center; }
        .editor-section { width: 100%; background: var(--bg-section); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; margin-bottom: 15px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; box-shadow: 0 2px 8px var(--shadow-light); }
        .editor-section legend { font-size: 1.1rem; font-weight: 700; color: var(--text-primary); margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); width: 100%; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .editor-section legend::after { content: " ‚ñº"; font-size: 0.8rem; }
        .editor-section.collapsed legend::after { content: " ‚ñ∂"; }
        .editor-section.collapsed .section-content { display: none; }
        .section-content { padding-top: 15px; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-size: 0.9rem; font-weight: 600; color: var(--text-label); margin-bottom: 8px; }
        .form-group input[type="text"], .form-group input[type="number"], .form-group input[type="file"], .form-group select, .form-group textarea { width: 100%; padding: 10px; font-size: 14px; background: var(--bg-input); border: 1px solid var(--border-input); border-radius: 6px; color: var(--text-primary); transition: all var(--transition-short) ease; max-width: 100%; overflow-wrap: break-word; }
        .form-group input[type="text"]:focus, .form-group input[type="number"]:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2); }
        .form-group textarea { min-height: 80px; resize: vertical; }
        .input-group { display: flex; align-items: center; gap: 0; border: 1px solid var(--border-input); border-radius: 6px; overflow: hidden;}
        .input-group:focus-within { border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2); }
        .input-group.simple { border: none; border-radius: 0; gap: 10px; } .input-group.simple:focus-within { box-shadow: none; }
        .input-group input[type="color"] { flex-shrink: 0; width: 40px; height: 38px; border: none; background: transparent; cursor: pointer; }
        .input-group input[type="text"].color-hex-input { flex-grow: 1; border: none; border-left: 1px solid var(--border-input); border-radius: 0; padding-left: 10px; background-color: var(--bg-input); color: var(--text-primary); }
        .input-group input[type="text"].color-hex-input:focus { outline: none; box-shadow: none; }
        .input-group input[type="range"] { flex-grow: 1; height: 20px; cursor: pointer; min-width: 100px; }
        .radio-group { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; background: var(--bg-input); border: 1px solid var(--border-input); border-radius: 6px; padding: 10px; }
        .radio-group label { margin: 0; font-weight: normal; display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.9rem; }
        .color-control-row { display: flex; flex-wrap: wrap; gap: 15px; align-items: flex-start; min-width: 0; }
        .color-control-group { flex: 1; min-width: 150px; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer; }
        .checkbox-group label { display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer; margin: 0; }
        .checkbox-group input[type="checkbox"] { width: auto; height: auto; }
        hr.separator { border: none; border-top: 1px solid var(--border-color); margin: 20px 0; }
        .tabs { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 15px; }
        .tab-btn { padding: 8px 12px; cursor: pointer; border: none; background: none; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid transparent; }
        .tab-btn.active { color: var(--text-primary); border-bottom-color: var(--color-primary); }
        .tab-content { display: none; } .tab-content.active { display: block; }
        .gradient-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .gradient-angle-control { grid-column: 1 / -1; }
        .preview-header { padding: 30px 15px; text-align: center; border-radius: 16px; transition: all var(--transition-speed) ease; overflow-wrap: break-word; }
        #preview-avatar { width: 90px; height: 90px; border: 4px solid var(--bg-preview-page); box-shadow: 0 4px 12px var(--shadow-light); object-fit: cover; background-color: #fff; transition: all var(--transition-speed) ease; }
        #preview-nickname { margin: 12px 0 5px; font-size: 1.6rem; font-weight: 700; color: var(--text-primary); transition: color var(--transition-speed) ease; }
        #preview-subtitle { margin: 0 0 8px; font-size: 1rem; font-weight: 400; color: var(--text-primary); opacity: 0.7; transition: color var(--transition-speed) ease, margin var(--transition-speed) ease; }
        #preview-bio { margin: 0; font-size: 0.9rem; line-height: 1.4; color: var(--text-primary); opacity: 0.8; transition: color var(--transition-speed) ease; white-space: pre-wrap; }
        #preview-subtitle:empty, #preview-bio:empty { display: none; }
        .tags-container { margin-top: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
        .tag-pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 12px; font-size: 0.8rem; font-weight: 600; border-radius: 16px; transition: all var(--transition-speed) ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #editor-blocks-list .empty-placeholder { text-align: center; padding: 20px; color: var(--text-placeholder); font-style: italic; }
        .editor-block { background: var(--bg-editor); border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px var(--shadow-light); transition: all var(--transition-speed) ease; opacity: 1; transform: scale(1); }
        .sortable-ghost { background: var(--bg-image-upload-hover) !important; border: 2px dashed var(--color-primary); box-shadow: none !important; opacity: 0.8 !important; }
        .editor-block.sortable-chosen { box-shadow: 0 4px 12px var(--shadow-medium); transform: scale(1.02); }
        .editor-block-header { display: flex; align-items: center; padding: 0 10px; background: var(--bg-section); border-bottom: 1px solid var(--border-color); border-radius: 8px 8px 0 0; }
        .block-drag-handle { font-size: 1.5rem; color: var(--text-placeholder); padding: 10px; cursor: grab; flex-shrink: 0; }
        .block-drag-handle:active { cursor: grabbing; }
        .editor-block-title-input { font-weight: 600; color: var(--text-primary); margin: 0; flex-grow: 1; padding: 10px; border: 1px solid transparent; background: transparent; font-size: 1em; min-width: 0; overflow-wrap: break-word; border-radius: 4px; }
        .editor-block-title-input:hover { border-color: var(--border-input); }
        .editor-block-title-input:focus { outline: 1px solid var(--color-primary); background: var(--bg-input); border-color: var(--color-primary); }
        .block-actions { display: flex; align-items: center; gap: 5px; margin-left: auto; flex-shrink: 0; }
        .up-down-btns { display: flex; gap: 2px; }
        .up-down-btns button { font-size: 1rem; width: 28px; height: 28px; padding: 0; line-height: 28px; }
        .block-settings { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding-left: 10px; flex-shrink: 0; }
        .block-settings label { font-size: 0.9rem; margin: 0; color: var(--text-secondary); cursor: pointer; }
        .block-delete-btn { width: auto; padding: 6px 10px; font-size: 0.9rem; flex-shrink: 0; }
        .editor-block-content { padding: 15px; overflow-x: hidden; /* Fix for mobile card overflow */ }
        .card-editors-list .empty-placeholder, .image-card-editors-list .empty-placeholder { text-align: center; padding: 15px; color: var(--text-placeholder); font-size: 0.9rem; }
        .editor-card { background: var(--bg-section); border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 15px; position: relative; padding-left: 40px; opacity: 1; transform: scale(1); }
        .editor-card.sortable-chosen { box-shadow: 0 3px 8px var(--shadow-medium); transform: scale(1.01); }
        .card-drag-handle { position: absolute; top: 0; left: 0; bottom: 0; width: 40px; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; color: var(--text-placeholder); cursor: grab; border-right: 1px solid var(--border-color); }
        .card-drag-handle:active { cursor: grabbing; }
        .editor-card-header { display: flex; justify-content: flex-end; padding: 8px 10px; border-bottom: 1px solid var(--border-color); }
        .card-delete-btn { width: auto; padding: 4px 8px; font-size: 0.8rem; }
        .editor-card-content { padding: 15px; }
        .card-bg-control { display: flex; align-items: center; gap: 10px; }
        .card-bg-control input[type="file"] { flex-grow: 1; }
        .card-overlay-controls { border: 1px solid var(--border-input); border-radius: 6px; padding: 10px; margin-top: 10px; background: var(--bg-input); }
        .card-style-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
        .image-card-editor-content { display: flex; gap: 15px; align-items: flex-start; }
        .image-card-editor-thumb { flex-shrink: 0; width: 80px; }
        .image-card-editor-fields { flex-grow: 1; }
        .thumbnail-wrapper { position: relative; width: 100%; padding-top: 100%; background: var(--bg-image-thumb); border-radius: 6px; overflow: hidden; transition: all var(--transition-short) ease; }
        .thumbnail-wrapper img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transition: transform var(--transition-short) ease; }
        .thumbnail-wrapper:hover { transform: scale(1.05); box-shadow: 0 4px 12px var(--shadow-medium); }
        .thumbnail-wrapper:hover img { transform: scale(1.05); }
        .thumbnail-actions { position: absolute; top: 3px; right: 3px; display: flex; gap: 4px; opacity: 0; transition: opacity var(--transition-short) ease; }
        .thumbnail-wrapper:hover .thumbnail-actions { opacity: 1; }
        .thumbnail-actions .btn { width: 24px; height: 24px; padding: 0; font-size: 0.8rem; line-height: 24px; border-radius: 50%; background: rgba(0,0,0,0.6); color: white; border: none; }
        .thumbnail-actions .btn:hover { background: rgba(0,0,0,0.8); }
        .preview-blocks-container { margin-top: 20px; display: flex; flex-direction: column; gap: 20px; width: 100%; box-sizing: border-box; }
        .preview-blocks-container.locked-mode * { cursor: default !important; }
        #preview-blocks-container .empty-placeholder { text-align: center; padding: 50px 0; color: var(--text-placeholder); }
        .preview-block-wrapper.sortable-drag { opacity: 1 !important; }
        .preview-block-wrapper { cursor: grab; } .preview-block-wrapper:active { cursor: grabbing; }
        .preview-cards-container { width: 100%; }
        .preview-cards-single { display: flex; flex-direction: column; gap: 15px; }
        .preview-cards-dual { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .preview-cards-triple { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .masonry-active { display: block; position: relative; } /* Override grid */
        .masonry-active.preview-cards-dual .preview-card, .masonry-active.preview-cards-dual figure { width: calc(50% - 7.5px); margin-bottom: 15px; }
        .masonry-active.preview-cards-triple .preview-card, .masonry-active.preview-cards-triple figure { width: calc(33.333% - 10px); margin-bottom: 15px; }
        .preview-card { box-sizing: border-box; width: 100%; view-transition-name: var(--card-transition-name); }
        .preview-card-inner { width: 100%; height: 100%; box-sizing: border-box; position: relative; overflow: hidden; color: var(--card-text-color, var(--g-card-text-color)); border-radius: var(--g-card-border-radius); box-shadow: var(--active-card-shadow, none); border: var(--active-card-border, none); font-weight: var(--card-font-weight, normal); text-shadow: var(--active-card-text-shadow, none); padding: 15px; word-wrap: break-word; transition: all var(--transition-short) ease, transform var(--transition-short) ease; -webkit-text-stroke: var(--g-card-text-stroke); line-height: var(--g-card-line-height); background-clip: padding-box; }
        .preview-card-inner::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 0; background-size: cover; background-position: center; border-radius: inherit; background: var(--card-bg-final); transition: background var(--transition-speed) ease; }
        .preview-card-inner::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--card-overlay-color, transparent); opacity: var(--card-overlay-opacity, 0); border-radius: inherit; z-index: 1; pointer-events: none; transition: all var(--transition-short) ease; }
        .preview-card:hover .preview-card-inner { transform: scale(1.02); box-shadow: 0 6px 16px var(--shadow-medium); }
        .preview-card.adding, figure.adding { animation: fadeInScale 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .preview-card.removing, figure.removing { animation: fadeOutScale 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .preview-card-title, .preview-card-content { position: relative; z-index: 2; margin: 0; word-wrap: break-word; overflow-wrap: break-word; color: inherit; }
        .preview-card-title { font-size: 1.1em; font-weight: inherit; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        .preview-card-title .iconify, .tag-pill .iconify { font-size: 1.1em; line-height: 1; vertical-align: middle; }
        .preview-card-content { font-size: 0.95em; line-height: inherit; white-space: pre-wrap; }
        .preview-cards-container figure { margin: 0; display: flex; flex-direction: column; transition: transform 0.3s ease; }
        .preview-cards-container figure img { width: 100%; display: block; border-radius: 8px; height: auto; max-width: 100%; transition: transform 0.3s ease; }
        .preview-cards-container figure:hover img { transform: scale(1.05); }
        .preview-cards-container figure figcaption { text-align: center; margin-top: 8px; padding: 5px; overflow-wrap: break-word; color: var(--g-card-text-color); border-radius: 8px; }
        .preview-cards-container figure figcaption strong { display: block; font-weight: 600; margin-bottom: 3px; }
        .separator-preview { display: flex; align-items: center; justify-content: center; }
        .separator-preview-line { flex-grow: 1; height: 1px; }
        .spacer-preview { transition: height 0.3s ease; }
        .font-controls { display: flex; flex-direction: column; gap: 8px; margin-top: 8px; align-items: stretch; }
        .font-controls select { width: 100%; }
        .font-controls .buttons { display: flex; gap: 10px; }
        .font-controls .buttons .btn { flex-grow: 1; padding: 8px 12px; font-size: 13px; width: auto; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-modal-overlay); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility 0s var(--transition-speed) ease; backdrop-filter: blur(5px); pointer-events: none; }
        .modal-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; pointer-events: auto; }
        .modal-container { background: var(--bg-editor); border-radius: 16px; box-shadow: 0 10px 30px var(--shadow-medium); padding: 25px; width: 90%; max-width: 500px; border: 1px solid var(--border-color); transform: scale(0.95); opacity: 0; transition: all var(--transition-speed) ease; }
        .modal-overlay.visible .modal-container { transform: scale(1); opacity: 1; }
        .modal-container h3 { margin-top: 0; margin-bottom: 20px; font-size: 1.25rem; color: var(--text-primary); }
        .cropper-img-container { width: 100%; height: 300px; margin-bottom: 20px; background: var(--bg-input); border-radius: 8px; overflow: hidden; }
        .cropper-img-container img { max-width: 100%; }
        .modal-actions { display: flex; gap: 15px; justify-content: flex-end; margin-top: 15px; }
        .modal-actions .btn { width: auto; min-width: 100px; }
        #download-modal-content { text-align: center; }
        #download-modal-content img { max-width: 100%; max-height: 50vh; border-radius: 8px; border: 1px solid var(--border-color); margin-bottom: 15px; }
        #download-modal-content a { display: block; background: var(--color-primary); color: white; text-decoration: none; padding: 12px 20px; border-radius: 8px; font-size: 1rem; font-weight: 600; margin-bottom: 20px; transition: background-color var(--transition-short) ease; }
        #download-modal-content a:hover { background-color: var(--color-primary-hover); }
        .crop-ratios { margin-bottom: 15px; }
        .crop-ratios label { margin-right: 10px; font-size: 0.9rem; cursor: pointer; }
        .error-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--bg-editor); color: var(--text-primary); padding: 25px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.3); z-index: 2000; max-width: 90%; width: 450px; border: 1px solid var(--border-color); }
        .error-modal h3 { color: var(--color-danger); margin-top: 0; }
        .error-modal p { margin: 10px 0; font-size: 0.95rem; }
        .error-modal .btn { margin-top: 15px; float: right; }
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; font-size: 1.2rem; backdrop-filter: blur(5px); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s 0.3s; pointer-events: none; }
        #loading-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; pointer-events: auto; }
        .spinner { width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--color-primary); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        .toast-notification-container { position: fixed; bottom: 20px; right: 20px; z-index: 9999; display: flex; flex-direction: column; gap: 10px; }
        .toast-notification { background-color: var(--bg-card); color: var(--text-primary); padding: 12px 18px; border-radius: 8px; box-shadow: 0 4px 12px var(--shadow-medium); border: 1px solid var(--border-color); opacity: 0; transform: translateX(100%); animation: toast-in 0.5s forwards, toast-out 0.5s 4.5s forwards; font-size: 0.9rem; }
        .toast-notification.success { border-left: 4px solid #2ecc71; }
        .toast-notification.error { border-left: 4px solid var(--color-danger); }
        .toast-notification.info { border-left: 4px solid var(--color-primary); }
        #icon-picker-modal .modal-container, #texture-picker-modal .modal-container { max-width: 700px; }
        #icon-grid, #texture-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 10px; max-height: 50vh; overflow-y: auto; padding: 10px; border: 1px solid var(--border-input); border-radius: 8px; background: var(--bg-input); }
        #texture-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
        .icon-grid-item { display: flex; align-items: center; justify-content: center; height: 50px; font-size: 1.5rem; color: var(--text-primary); border-radius: 6px; cursor: pointer; transition: background-color var(--transition-short); position: relative; }
        .icon-grid-item:hover, .texture-grid-item:hover { background-color: var(--border-color); }
        .icon-grid-item .delete-custom-icon-btn { position: absolute; top: 2px; right: 2px; width: 18px; height: 18px; padding: 0; font-size: 0.7rem; line-height: 18px; border-radius: 50%; display: none; }
        .icon-grid-item:hover .delete-custom-icon-btn { display: flex; }
        .texture-grid-item { display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 6px; cursor: pointer; transition: background-color var(--transition-short); padding: 5px; }
        .texture-preview { width: 100%; height: 80px; border: 1px solid var(--border-color); border-radius: 4px; background-size: 20px; }
        .texture-name { font-size: 0.75rem; margin-top: 5px; color: var(--text-secondary); text-align: center; }
        #tag-manager-list { display: flex; flex-direction: column; gap: 10px; max-height: 250px; overflow-y: auto; padding: 10px; border: 1px solid var(--border-input); border-radius: 6px; background-color: var(--bg-input); margin-bottom: 15px; }
        .tag-manager-item { display: flex; align-items: center; gap: 8px; background-color: var(--bg-section); padding: 8px; border-radius: 4px; border: 1px solid var(--border-color); }
        .tag-manager-item .tag-icon-btn { flex-shrink: 0; width: 32px; height: 32px; padding: 0; font-size: 1.2rem; }
        .tag-manager-item .tag-text-input { flex-grow: 1; border: none; background: transparent; padding: 4px 6px; }
        .tag-manager-item .tag-delete-btn { flex-shrink: 0; width: 32px; height: 32px; padding: 0; }
        .empty-tag-list { text-align: center; color: var(--text-placeholder); padding: 20px 0; }
        .inset-controls { border: 1px solid var(--border-input); border-radius: 6px; padding: 15px; margin-top: 10px; background: var(--bg-input); }
        /* Styles for Help Modal */
        #help-modal .tab-content { max-height: 60vh; overflow-y: auto; padding: 15px; }
        #help-thanks .thanks-item { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        #help-thanks .thanks-item:last-child { border-bottom: none; }
        #help-thanks h4 { margin-top: 0; margin-bottom: 8px; }
        #help-thanks p { margin: 4px 0; }
        #help-thanks details { margin-top: 10px; }
        #help-thanks summary { cursor: pointer; font-weight: 600; color: var(--text-action); }
        #help-thanks pre { white-space: pre-wrap; word-wrap: break-word; background: var(--bg-input); padding: 10px; border-radius: 6px; font-size: 0.8rem; max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); }
        .newbie-tip-bar {
            display: none;
            width: 100%;
            max-width: 600px;
            background-color: var(--bg-card);
            color: var(--text-primary);
            padding: 10px 15px;
            margin-bottom: 15px;
            border-radius: 12px;
            box-shadow: var(--shadow-medium);
            text-align: center;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            border: 1px solid var(--border-color);
        }
        .newbie-tip-bar .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0 5px;
        }
        @keyframes toast-in { to { opacity: 1; transform: translateX(0); } }
        @keyframes toast-out { to { opacity: 0; transform: translateX(100%); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInScale { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        @keyframes fadeOutScale { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.9); } }
        .preview-header { animation: fadeIn 0.4s ease forwards; }
        #mobile-edit-toggle { display: none; }
        @media (max-width: 768px) {
            .app-header-title { display: none; } 
            #mobile-edit-toggle { display: block; z-index: 201; }
            .resizer { display: none; }
            .app-container { flex-direction: column; }
            .editor-panel {
                position: fixed; top: var(--header-height); left: 0; width: 85%; max-width: 350px;
                height: calc(100vh - var(--header-height)); z-index: 200;
                transform: translateX(-100%); transition: transform 0.3s ease-in-out;
                box-shadow: 4px 0 15px rgba(0,0,0,0.1); border-right: 1px solid var(--border-color);
            }
            .editor-panel.is-open { transform: translateX(0); }
            .preview-panel { width: 100%; height: calc(100vh - var(--header-height)); padding: 20px 10px; }
            body.editor-open::after {
                content: ''; position: fixed; top: var(--header-height); left: 0; width: 100%;
                height: calc(100vh - var(--header-height)); background: rgba(0,0,0,0.4); z-index: 199;
                opacity: 1; pointer-events: auto; transition: opacity 0.3s ease-in-out;
            }
            .preview-cards-triple { grid-template-columns: 1fr; }
            .masonry-active.preview-cards-triple .preview-card, .masonry-active.preview-cards-triple figure { width: 100%; }
        }
    </style>
</head>
<body>

    <header class="app-header">
        <button id="mobile-edit-toggle" class="btn btn-default btn-icon" style="width: auto; padding: 6px 12px;"><span class="iconify" data-icon="mdi:pencil"></span> ÁºñËæë</button>
        <div class="app-header-title">Blokko (v1.4.0)</div>
        <div class="header-actions-wrapper">
            <button id="lock-mode-toggle" class="btn btn-default" style="width: auto; padding: 6px 12px;" title="ÂàáÊç¢ÁºñËæë/È¢ÑËßàÊ®°Âºè">ÁºñËæë‰∏≠</button>
            <button id="show-help-btn" class="btn btn-default btn-icon" style="width: auto; padding: 6px 12px;"><span class="iconify" data-icon="mdi:help-circle-outline"></span> Â∏ÆÂä©</button>
            <div class="theme-switch-wrapper">
                <span id="theme-label">Êòé‰∫ÆÊ®°Âºè</span>
                <button id="theme-toggle-btn" class="btn btn-default" style="width: auto; padding: 6px 12px;">ÂàáÊç¢</button>
            </div>
        </div>
    </header>

    <div class="app-container">
        <aside class="editor-panel" id="editor-panel">
            
            <fieldset class="editor-section" id="personal-info-section">
                <legend>‰∏™‰∫∫‰ø°ÊÅØ</legend>
                <div class="section-content">
                    <div class="form-group"><label>ÊòµÁß∞:</label><input type="text" data-state-key="personalInfo.nickname" data-preview-target="#preview-nickname"></div>
                    <div class="form-group"><label>ÊòµÁß∞È¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="personalInfo.nicknameColor"><input type="text" class="color-hex-input" data-color-sync-key="personalInfo.nicknameColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.nicknameColor">ÈáçÁΩÆ</button></div></div>
                    <div class="form-group"><label>ÂâØÊ†áÈ¢ò (ÂèØÈÄâ):</label><input type="text" data-state-key="personalInfo.subtitle" data-preview-target="#preview-subtitle"></div>
                    <div class="form-group"><label>ÂâØÊ†áÈ¢òÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="personalInfo.subtitleColor"><input type="text" class="color-hex-input" data-color-sync-key="personalInfo.subtitleColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.subtitleColor">ÈáçÁΩÆ</button></div></div>
                    <div class="form-group"><label>ÁÆÄ‰ªã (ÂèØÈÄâ):</label><textarea data-state-key="personalInfo.bio" rows="3" data-preview-target="#preview-bio"></textarea></div>
                    <div class="form-group"><label>ÁÆÄ‰ªãÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="personalInfo.bioColor"><input type="text" class="color-hex-input" data-color-sync-key="personalInfo.bioColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.bioColor">ÈáçÁΩÆ</button></div></div>
                    <hr class="separator">
                    <div class="form-group">
                        <label>Ê†áÁ≠æÁÆ°ÁêÜÂô®:</label>
                        <div id="tag-manager-list"></div>
                        <div class="input-group simple" style="margin-top: 10px;">
                            <input type="text" id="new-tag-text-input" placeholder="ËæìÂÖ•Êñ∞Ê†áÁ≠æÊñáÂ≠ó...">
                            <button id="add-new-tag-btn" class="btn btn-default btn-small">Ê∑ªÂä†Ê†áÁ≠æ</button>
                        </div>
                    </div>
                    <div class="form-group"><label>Ê†áÁ≠æÊ†∑Âºè:</label><div class="color-control-row"><div class="color-control-group"><label>ËÉåÊôØ</label><div class="input-group"><input type="color" data-state-key="personalInfo.tagBgColor"><input type="text" class="color-hex-input" data-color-sync-key="personalInfo.tagBgColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.tagBgColor">ÈáçÁΩÆ</button></div></div><div class="color-control-group"><label>ÊñáÂ≠ó</label><div class="input-group"><input type="color" data-state-key="personalInfo.tagTextColor"><input type="text" class="color-hex-input" data-color-sync-key="personalInfo.tagTextColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.tagTextColor">ÈáçÁΩÆ</button></div></div></div></div>
                    <hr class="separator">
                    <div class="form-group"><label>Â§¥ÂÉè‰∏ä‰º†:</label><input type="file" id="avatar-upload" accept="image/*"></div>
                    <div class="form-group"><label>Â§¥ÂÉèÂΩ¢Áä∂:</label><div class="radio-group"><label><input type="radio" name="avatarShape" value="50%" data-state-key="personalInfo.avatarShape">ÂúÜÂΩ¢</label><label><input type="radio" name="avatarShape" value="16px" data-state-key="personalInfo.avatarShape">ÂúÜËßí</label><label><input type="radio" name="avatarShape" value="0px" data-state-key="personalInfo.avatarShape">ÊñπÂΩ¢</label></div></div>
                    <div class="color-control-row"><div class="color-control-group"><label>Â§¥ÂÉèËæπÊ°Ü(px):</label><input type="range" data-state-key="personalInfo.avatarBorderSize" min="0" max="10" step="1"></div><div class="color-control-group"><label>ËæπÊ°ÜÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="personalInfo.avatarBorderColor"><input type="text" class="color-hex-input" data-color-sync-key="personalInfo.avatarBorderColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.avatarBorderColor">ÈáçÁΩÆ</button></div></div></div>
                </div>
            </fieldset>

            <fieldset class="editor-section">
                <legend>ÂÜÖÂÆπÂå∫Âùó</legend>
                <div class="section-content">
                    <div id="editor-blocks-list"></div>
                    <div class="form-group" style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
                        <button id="add-text-block-btn" class="btn btn-default">‚ûï ÊñáÊú¨Âå∫Âùó</button>
                        <button id="add-image-block-btn" class="btn btn-default">üñºÔ∏è ÂõæÁâáÂå∫Âùó</button>
                        <button id="add-separator-block-btn" class="btn btn-default">„Ä∞Ô∏è ÂàÜÈöîÁ∫ø</button>
                        <button id="add-spacer-block-btn" class="btn btn-default">‚éµ ÁïôÁôΩÂùó</button>
                    </div>
                </div>
            </fieldset>

            <fieldset class="editor-section collapsed" id="page-styles-section">
                <legend>È°µÈù¢ËÉåÊôØÊ†∑Âºè</legend>
                <div class="section-content">
                    <div class="tabs"><button class="tab-btn" data-tab="page-bg-solid">Á∫ØËâ≤/ÂõæÁâá</button><button class="tab-btn active" data-tab="page-bg-gradient">Ê∏êÂèò</button></div>
                    <div id="page-bg-solid" class="tab-content"><div class="form-group"><label>È°µÈù¢ËÉåÊôØÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgSolidColor"><input type="text" class="color-hex-input" data-color-sync-key="pageStyles.pageBgSolidColor"></div></div><div class="form-group"><label>ËÉåÊôØÂõæ (ÂèØÈÄâ):</label><div class="input-group simple"><input type="file" id="page-bg-upload" accept="image/*" style="width:100%"><button id="clear-page-bg-btn" class="btn btn-default btn-small">Ê∏ÖÈô§</button></div></div>
                    <div id="page-image-controls" style="display:none;"><div class="form-group"><label>ÂõæÁâáÈÅÆÁΩ©È¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageOverlayColor"><input type="text" class="color-hex-input" data-color-sync-key="pageStyles.pageOverlayColor"></div></div><div class="form-group"><label>ÂõæÁâáÈÅÆÁΩ©‰∏çÈÄèÊòéÂ∫¶:</label><input type="range" data-state-key="pageStyles.pageOverlayOpacity" min="0" max="1" step="0.05"></div></div></div>
                    <div id="page-bg-gradient" class="tab-content active"><div class="gradient-controls"><div class="form-group"><label>Ëµ∑ÂßãÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgGradientStart"><input type="text" class="color-hex-input" data-color-sync-key="pageStyles.pageBgGradientStart"></div></div><div class="form-group"><label>ÁªìÊùüÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgGradientEnd"><input type="text" class="color-hex-input" data-color-sync-key="pageStyles.pageBgGradientEnd"></div></div><div class="gradient-angle-control form-group"><label>ËßíÂ∫¶ (<span class="angle-value">135</span>¬∞):</label><input type="range" data-state-key="pageStyles.pageBgGradientAngle" min="0" max="360" step="1"></div></div></div>
                    
                    <div class="form-group" style="margin-top: 10px;">
                        <button id="show-texture-picker-btn" class="btn btn-default">üé® Ê∑ªÂä†Á∫πÁêÜ</button>
                    </div>
                    <div id="page-texture-controls" class="inset-controls" style="display:none;">
                        <div class="form-group">
                            <label>ÂΩìÂâçÁ∫πÁêÜ: <span id="current-texture-name">Êó†</span></label>
                             <button id="clear-texture-btn" class="btn btn-default btn-small">Ê∏ÖÈô§Á∫πÁêÜ</button>
                        </div>
                        <div class="color-control-row">
                             <div class="color-control-group"><label>Á∫πÁêÜÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgPatternColor"><input type="text" class="color-hex-input" data-color-sync-key="pageStyles.pageBgPatternColor"></div></div>
                             <div class="color-control-group"><label>Á∫πÁêÜ‰∏çÈÄèÊòéÂ∫¶:</label><input type="range" data-state-key="pageStyles.pageBgPatternOpacity" min="0" max="1" step="0.05"></div>
                        </div>
                        <div class="form-group"><label>Á∫πÁêÜÂØÜÂ∫¶:</label><input type="range" data-state-key="pageStyles.pageBgPatternDensity" min="10" max="100" step="2"></div>
                    </div>
                </div>
            </fieldset>

            <fieldset class="editor-section collapsed" id="header-styles-section">
                <legend>Â§¥ÈÉ®Ê†∑Âºè</legend>
                <div class="section-content">
                    <div class="tabs"><button class="tab-btn" data-tab="header-bg-solid">Á∫ØËâ≤</button><button class="tab-btn active" data-tab="header-bg-gradient">Ê∏êÂèò</button></div>
                    <div id="header-bg-solid" class="tab-content"><div class="form-group"><label>Â§¥ÈÉ®ËÉåÊôØÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerBgColor"><input type="text" class="color-hex-input" data-color-sync-key="pageStyles.headerBgColor"></div></div></div>
                    <div id="header-bg-gradient" class="tab-content active"><div class="gradient-controls"><div class="form-group"><label>Ëµ∑ÂßãÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerBgGradientStart"><input type="text" class="color-hex-input" data-color-sync-key="pageStyles.headerBgGradientStart"></div></div><div class="form-group"><label>ÁªìÊùüÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerBgGradientEnd"><input type="text" class="color-hex-input" data-color-sync-key="pageStyles.headerBgGradientEnd"></div></div><div class="gradient-angle-control form-group"><label>ËßíÂ∫¶ (<span class="angle-value">135</span>¬∞):</label><input type="range" data-state-key="pageStyles.headerBgGradientAngle" min="0" max="360" step="1"></div></div></div>
                    <div class="form-group"><label>Â§¥ÈÉ®ÊñáÂ≠óÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerTextColor"><input type="text" class="color-hex-input" data-color-sync-key="pageStyles.headerTextColor"></div></div>
                    <div class="form-group"><label>Â§¥ÈÉ®‰∏çÈÄèÊòéÂ∫¶:</label><input type="range" data-state-key="pageStyles.headerOpacity" min="0" max="1" step="0.05"></div>
                </div>
            </fieldset>
            
            <fieldset class="editor-section collapsed" id="global-card-styles-section"> 
                <legend>ÂÖ®Â±ÄÂç°ÁâáÊ†∑Âºè</legend>
                <div class="section-content">
                    <div class="tabs"><button class="tab-btn active" data-tab="card-bg-solid">Á∫ØËâ≤</button><button class="tab-btn" data-tab="card-bg-gradient">Ê∏êÂèò</button></div>
                    <div id="card-bg-solid" class="tab-content active"><div class="color-control-row"><div class="color-control-group"><label>ËÉåÊôØËâ≤:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.bgColor"><input type="text" class="color-hex-input" data-color-sync-key="globalCardStyles.bgColor"></div></div><div class="color-control-group"><label>ÊñáÂ≠óÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.textColor"><input type="text" class="color-hex-input" data-color-sync-key="globalCardStyles.textColor"></div></div></div></div>
                    <div id="card-bg-gradient" class="tab-content"><div class="gradient-controls"><div class="form-group"><label>Ëµ∑ÂßãÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.bgGradientStart"><input type="text" class="color-hex-input" data-color-sync-key="globalCardStyles.bgGradientStart"></div></div><div class="form-group"><label>ÁªìÊùüÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.bgGradientEnd"><input type="text" class="color-hex-input" data-color-sync-key="globalCardStyles.bgGradientEnd"></div></div><div class="gradient-angle-control form-group"><label>ËßíÂ∫¶ (<span class="angle-value">135</span>¬∞):</label><input type="range" data-state-key="globalCardStyles.bgGradientAngle" min="0" max="360" step="1"></div></div></div>
                    <div class="form-group"><label>‰∏çÈÄèÊòéÂ∫¶:</label><input type="range" data-state-key="globalCardStyles.opacity" min="0" max="1" step="0.05"></div>
                    <div class="form-group checkbox-group"><label><input type="checkbox" data-state-key="globalCardStyles.shadowEnabled"> ÊòæÁ§∫Âç°ÁâáÈò¥ÂΩ±</label></div>
                    <div class="form-group"><label>ÂúÜËßí (px): <span id="gCardRadiusValue">12</span></label><input type="range" data-state-key="globalCardStyles.radius" min="0" max="40" step="1"></div>
                    <hr class="separator">
                    <label>Âç°ÁâáËæπÊ°Ü:</label>
                    <div class="form-group inset-controls">
                        <div class="form-group"><label>Ê†∑Âºè:</label><select data-state-key="globalCardStyles.borderStyle"><option value="none">Êó†</option><option value="solid">ÂÆûÁ∫ø</option><option value="dashed">ËôöÁ∫ø</option><option value="dotted">ÁÇπÁä∂</option></select></div>
                        <div class="color-control-row">
                            <div class="color-control-group"><label>Á≤óÁªÜ(px):</label><input type="range" data-state-key="globalCardStyles.borderWidth" min="0" max="10" step="1"></div>
                            <div class="color-control-group"><label>È¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.borderColor"><input type="text" class="color-hex-input" data-color-sync-key="globalCardStyles.borderColor"></div></div>
                        </div>
                    </div>
                    <hr class="separator">
                    <div class="form-group"><label>ÂØπÈΩê:</label><div class="radio-group"><label><input type="radio" name="gCardAlign" value="left" data-state-key="globalCardStyles.textAlign">Â±ÖÂ∑¶</label><label><input type="radio" name="gCardAlign" value="center" data-state-key="globalCardStyles.textAlign">Â±Ö‰∏≠</label><label><input type="radio" name="gCardAlign" value="right" data-state-key="globalCardStyles.textAlign">Â±ÖÂè≥</label></div></div>
                    <div class="form-group"><label>Ë°åÈ´ò:</label><div class="radio-group"><label><input type="radio" name="gCardLineHeight" value="1.4" data-state-key="globalCardStyles.lineHeight">Á¥ßÂáë</label><label><input type="radio" name="gCardLineHeight" value="1.5" data-state-key="globalCardStyles.lineHeight">‰∏≠Á≠â</label><label><input type="radio" name="gCardLineHeight" value="1.6" data-state-key="globalCardStyles.lineHeight">ÂÆΩÊùæ</label></div></div>
                    <hr class="separator">
                    <div class="form-group">
                        <label>Â≠ó‰Ωì:</label>
                        <div class="font-controls">
                            <input type="text" id="font-search-input" placeholder="ÊêúÁ¥¢Êú¨Âú∞Â≠ó‰Ωì..." style="margin-bottom: 5px;">
                            <select id="font-family-select" data-state-key="globalCardStyles.fontFamily"></select>
                            <div class="buttons">
                                <button id="load-local-fonts-btn" class="btn btn-default">Âä†ËΩΩÊú¨Âú∞</button>
                                <button id="upload-font-btn" class="btn btn-default">‰∏ä‰º†Â≠ó‰Ωì</button>
                            </div>
                            <input type="file" id="font-upload-input" accept=".ttf,.woff,.woff2,.otf" style="display: none;">
                        </div>
                    </div>
                    <div class="form-group"> <label>Â≠óÂè∑:</label> <select data-state-key="globalCardStyles.fontSize"> <option value="0.9rem">Â∞è</option> <option value="1rem" selected>‰∏≠ (ÈªòËÆ§)</option> <option value="1.1rem">Â§ß</option> </select> </div>
                    <div class="color-control-row"><div class="color-control-group"><label>ÊñáÂ≠óÊèèËæπ(px):</label><input type="range" data-state-key="globalCardStyles.textStrokeWidth" min="0" max="5" step="0.5"></div><div class="color-control-group"><label>ÊèèËæπÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.textStrokeColor"><input type="text" class="color-hex-input" data-color-sync-key="globalCardStyles.textStrokeColor"></div></div></div>
                </div>
            </fieldset>

            <fieldset class="editor-section">
                <legend>Êìç‰Ωú‰∏éÁÆ°ÁêÜ</legend>
                <div class="section-content">
                    <div class="form-group" style="display: flex; gap: 10px;"> <button id="undo-btn" class="btn btn-default" disabled>Êí§Âõû</button> <button id="redo-btn" class="btn btn-default" disabled>ÈáçÂÅö</button> </div>
                    <div class="form-group" style="display: flex; gap: 10px;"> <button id="import-btn" class="btn btn-secondary">ÂØºÂÖ•ÈÖçÁΩÆ</button> <button id="export-btn" class="btn btn-secondary">ÂØºÂá∫ÈÖçÁΩÆ</button> <button id="export-template-btn" class="btn btn-secondary">Â≠ò‰∏∫Ê®°Êùø</button></div>
                    <div class="form-group">
                        <div class="checkbox-group" style="margin-bottom: 10px;">
                            <label><input type="checkbox" id="hd-export-toggle"> Ë∂ÖÊ∏ÖÂØºÂá∫ (1800px)</label>
                        </div>
                        <div class="checkbox-group" style="margin-bottom: 10px;">
                            <label><input type="checkbox" id="custom-width-toggle"> Ëá™ÂÆö‰πâÂÆΩÂ∫¶</label>
                            <input type="number" id="custom-width-input" value="1200" style="width: 80px; padding: 4px 8px;" disabled>
                        </div>
                        <div class="checkbox-group" style="margin-bottom: 10px;">
                            <label><input type="checkbox" id="export-rounded-corners-toggle"> ÂØºÂá∫‰∏∫ÂúÜËßíÂõæÁâá</label>
                            <input type="number" id="export-corner-radius-input" value="20" style="width: 60px; padding: 4px 8px;" disabled>
                        </div>
                        <div id="export-size-preview" style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 5px;"></div>
                        <button id="export-png-btn" class="btn btn-primary" style="margin-top:10px;">ÂØºÂá∫‰∏∫ÂõæÁâá (1200px)</button>
                    </div>
                    <hr class="separator">
                    <div class="form-group">
                        <label>È¢ÑËÆæ‰∏ªÈ¢ò:</label>
                        <div class="input-group simple"> <button data-preset="light" class="btn btn-default btn-small">Êòé‰∫Æ</button> <button data-preset="dark" class="btn btn-default btn-small">ÊöóÈªë</button> <button data-preset="mint" class="btn btn-default btn-small">ËñÑËç∑</button> <button data-preset="coffee" class="btn btn-default btn-small">ÂíñÂï°</button> </div>
                    </div>
                    <div class="form-group">
                        <button id="reset-btn" class="btn btn-danger">ÊÅ¢Â§çÈªòËÆ§Ê®°Êùø</button>
                    </div>
                    <input type="file" id="config-file-input" accept=".json" style="display: none;">
                </div>
            </fieldset>

        </aside>

        <div class="resizer" id="resizer"></div>
        <main class="preview-panel" id="preview-panel">
            <div class="newbie-tip-bar" id="newbie-tip-bar" style="display: none;">
                <span>üí° <b>Â∞èÊèêÁ§∫Ôºö</b>È¢ÑËßàÂå∫ÁöÑÊâÄÊúâÊñáÂ≠óÔºå<b>ÂèåÂáª‰∏Ä‰∏ã</b>Â∞±ËÉΩÁõ¥Êé•‰øÆÊîπÂì¶ÔºÅ</span>
                <button class="close-btn" id="newbie-tip-close-btn">&times;</button>
            </div>
            <div class="preview-wrapper" id="preview-wrapper">
                <div class="preview-overlay" id="preview-overlay"></div>
                <header class="preview-header" id="preview-header">
                    <img id="preview-avatar" src="" alt="Avatar">
                    <h1 id="preview-nickname" data-state-key="personalInfo.nickname"></h1>
                    <h2 id="preview-subtitle" data-state-key="personalInfo.subtitle"></h2>
                    <p id="preview-bio" data-state-key="personalInfo.bio"></p>
                    <div class="tags-container" id="preview-tags-container"></div>
                </header>
                <main class="preview-blocks-container" id="preview-blocks-container"></main>
            </div>
        </main>
    </div>

    <div class="modal-overlay" id="cropper-modal"><div class="modal-container"><h3 id="cropper-title">Ë£ÅÂâ™ÂõæÁâá</h3><div class="crop-ratios radio-group"><label><input type="radio" name="crop-ratio" value="NaN" checked> Ëá™Áî±</label><label><input type="radio" name="crop-ratio" value="1"> 1:1</label><label><input type="radio" name="crop-ratio" value="1.3333"> 4:3</label><label><input type="radio" name="crop-ratio" value="1.7777"> 16:9</label></div><div class="cropper-img-container"><img id="cropper-image" src=""></div><div class="modal-actions"><button id="cropper-cancel-btn" class="btn btn-default">ÂèñÊ∂à</button><button id="cropper-save-btn" class="btn btn-primary">Á°ÆËÆ§</button></div></div></div>
    <div class="modal-overlay" id="download-modal"><div class="modal-container"><h3 id="download-modal-title">‰∏ãËΩΩÂ∑≤ÂáÜÂ§áÂ•Ω</h3><div id="download-modal-content"></div><div class="modal-actions" style="justify-content: center;"><button id="download-modal-close-btn" class="btn btn-default">ÂÖ≥Èó≠</button></div></div></div>
    
    <div class="modal-overlay" id="help-modal">
        <div class="modal-container" style="max-width: 700px;">
            <div class="tabs">
                <button class="tab-btn" data-tab="help-tutorial">Êñ∞ÊâãÊïôÁ®ã</button>
                <button class="tab-btn active" data-tab="help-instructions">‰ΩøÁî®ËØ¥Êòé</button>
                <button class="tab-btn" data-tab="help-changelog">Êõ¥Êñ∞Êó•Âøó</button>
                <button class="tab-btn" data-tab="help-thanks">ÊÑüË∞¢‰ø°ÊÅØ</button>
                <button class="tab-btn" data-tab="help-about">ÂÖ≥‰∫é</button>
            </div>
            <div id="help-tutorial" class="tab-content">
                <h4>Ê¨¢ËøéÊù•Âà∞ BlokkoÔºÅ‚ú®</h4>
                <p>Âà´ÊãÖÂøÉÔºåËøô‰∏™Â∞èÊïôÁ®ãÂ∞ÜÂ∏¶‰Ω†Âø´ÈÄü‰∏äÊâãÔºåÊï¥‰∏™ËøáÁ®ãÂè™ÈúÄ‰∏ÄÂàÜÈíüÔºÅ</p>
                <hr class="separator">
                <h5>Á¨¨‰∏ÄÊ≠•ÔºöÊ†∏ÂøÉÊäÄÂ∑ß - ÂèåÂáªÁºñËæëÔºÅ</h5>
                <p>Blokko ÊúÄ‰æøÊç∑ÁöÑÊìç‰ΩúÂ∞±ÊòØ‚ÄúÂèåÂáª‚Äù„ÄÇ<strong>È¢ÑËßàÂå∫ÂüüÈáå‰Ω†ÁúãÂà∞ÁöÑÊâÄÊúâÊñáÂ≠ó</strong>ÔºàÊØîÂ¶ÇÊòµÁß∞„ÄÅÁÆÄ‰ªã„ÄÅÂç°ÁâáÊ†áÈ¢òÂíåÂÜÖÂÆπÔºâÔºåÁõ¥Êé•Áî®Èº†Ê†á<strong>ÂèåÂáª</strong>ÂÆÉ‰ª¨ÔºåÂ∞±ÂèØ‰ª•Á´ãÂàªÂºÄÂßãÁºñËæëÔºåÈùûÂ∏∏Êñπ‰æøÔºÅ</p>
                <hr class="separator">
                <h5>Á¨¨‰∫åÊ≠•ÔºöË∞ÉÊï¥‰Ω†ÁöÑ‰∏™‰∫∫‰ø°ÊÅØ</h5>
                <p>Âú®Â∑¶‰æßÁöÑÁºñËæëÈù¢ÊùøÔºåÊúÄ‰∏äÊñπÁöÑ <strong>‚Äú‰∏™‰∫∫‰ø°ÊÅØ‚Äù</strong> Âå∫ÂüüÔºå‰Ω†ÂèØ‰ª•‰∏ä‰º†Â§¥ÂÉè„ÄÅ‰øÆÊîπÊòµÁß∞„ÄÅÊ∑ªÂä†Ê†áÁ≠æÔºåÊâìÈÄ†Â±û‰∫é‰Ω†ÁöÑÁã¨ÁâπÂ§¥ÈÉ®Ê†∑Âºè„ÄÇ</p>
                <hr class="separator">
                <h5>Á¨¨‰∏âÊ≠•ÔºöÊ∑ªÂä†ÂíåÁÆ°ÁêÜÂÜÖÂÆπ</h5>
                <p>Âú® <strong>‚ÄúÂÜÖÂÆπÂå∫Âùó‚Äù</strong> ÈÉ®ÂàÜÔºå‰Ω†ÂèØ‰ª•ÁÇπÂáª‰∏ãÊñπÁöÑ‚Äú‚ûï‚ÄùÊåâÈíÆÊù•Ê∑ªÂä†‰∏çÂêåÁ±ªÂûãÁöÑÂ±ïÁ§∫Ê®°ÂùóÔºåÊØîÂ¶ÇÊñáÊú¨Âç°Áâá„ÄÅÂõæÁâáÂ¢ôÁ≠â„ÄÇÊØè‰∏™Âå∫ÂùóÂíåÂç°ÁâáÈÉΩÂèØ‰ª•ÈÄöËøáÊãñÊãΩ ‚ò∞ ÂõæÊ†áÊù•ÊéíÂ∫è„ÄÇ</p>
                <hr class="separator">
                <h5>Á¨¨ÂõõÊ≠•ÔºöÁæéÂåñ‰∏éÂØºÂá∫</h5>
                <p>ÂΩì‰Ω†ÂØπÂÜÖÂÆπÊª°ÊÑèÂêéÔºåÂèØ‰ª•Êé¢Á¥¢ <strong>‚ÄúÈ°µÈù¢Ê†∑Âºè‚Äù</strong> Âíå <strong>‚ÄúÂÖ®Â±ÄÂç°ÁâáÊ†∑Âºè‚Äù</strong>ÔºåË∞ÉÊï¥È¢úËâ≤„ÄÅÂ≠ó‰ΩìÂíåËÉåÊôØÔºåËÆ©‰Ω†ÁöÑ‰ΩúÂìÅÊõ¥ÂÖ∑‰∏™ÊÄß„ÄÇÂÖ®ÈÉ®ÂÆåÊàêÂêéÔºåÁÇπÂáªÊúÄ‰∏ãÊñπÁöÑ <strong>‚ÄúÂØºÂá∫‰∏∫ÂõæÁâá‚Äù</strong> ÊåâÈíÆÔºåÂ∞±ÂèØ‰ª•‰øùÂ≠ò‰Ω†ÁöÑÊù∞‰ΩúÂï¶ÔºÅ</p>
                <hr class="separator">
                <div style="background: var(--bg-input); border-left: 4px solid var(--color-danger); padding: 10px 15px; border-radius: 6px;">
                    <h5 style="color: var(--color-danger); margin-top:0;">‚ö†Ô∏è ÂÖ≥‰∫éÁâàÊùÉÁöÑÈáçË¶ÅÊèêÁ§∫</h5>
                    <p>Blokko ÊòØ‰∏Ä‰∏™ÂÆåÂÖ®ÂÖçË¥πÁöÑÊú¨Âú∞Âàõ‰ΩúÂ∑•ÂÖ∑„ÄÇÂΩìÊÇ®‰ΩøÁî®‚Äú‰∏ä‰º†Â≠ó‰Ωì‚Äù„ÄÅ‚Äú‰∏ä‰º†ÂõæÁâá/ÂõæÊ†á‚ÄùÂäüËÉΩÊó∂ÔºåÊÇ®ÈúÄË¶ÅÂØπËøô‰∫õÁ¥†ÊùêË¥üË¥£„ÄÇ<strong>ËØ∑Á°Æ‰øùÊÇ®‰∏ä‰º†Âíå‰ΩøÁî®ÁöÑ‰ªª‰ΩïÊñá‰ª∂ÈÉΩÂ∑≤Ëé∑Âæó‰∫ÜÂéüÁâàÊùÉÊñπÁöÑÂêàÊ≥ïÊéàÊùÉÔºåÊàñ‰ΩøÁî®Êó†ÁâàÊùÉÂèØÂïÜÁî®Á¥†Êùê„ÄÇ</strong></p>
                    <p style="margin-bottom:0;">Âõ†‰ΩøÁî®Êú™ÊéàÊùÉÁ¥†ÊùêËÄå‰∫ßÁîüÁöÑ‰ªª‰ΩïÁâàÊùÉÈóÆÈ¢òÔºåÂ∞ÜÁî±ÊÇ®Ëá™Ë°åÊâøÊãÖ„ÄÇ</p>
                </div>
                <div class="modal-actions" style="justify-content: center; margin-top: 20px;">
                    <button id="tutorial-close-btn" class="btn btn-primary">ÊàëÂ≠¶‰ºö‰∫ÜÔºåÂºÄÂßãÂàõ‰ΩúÔºÅ</button>
                </div>
            </div>
            <div id="help-instructions" class="tab-content active">
                <h4>Ê¨¢Ëøé‰ΩøÁî® BlokkoÔºÅ</h4>
                <p><strong><span class="iconify" data-icon="mdi:cursor-default-click-outline" style="vertical-align: -0.2em;"></span> ÂèåÂáªÁºñËæëÔºö</strong> È¢ÑËßàÂå∫ÂüüÁöÑÂ§ßÈÉ®ÂàÜÊñáÊú¨ÂÜÖÂÆπÔºàÂ¶ÇÊòµÁß∞„ÄÅÁÆÄ‰ªã„ÄÅÂç°ÁâáÊ†áÈ¢òÂíåÂÜÖÂÆπÔºâÈÉΩÂèØ‰ª•ÈÄöËøáÂèåÂáªÁõ¥Êé•ËøõË°åÁºñËæë„ÄÇ</p>
                <p><strong><span class="iconify" data-icon="mdi:drag" style="vertical-align: -0.2em;"></span> ÊãñÊãΩÊéíÂ∫èÔºö</strong> Âú®ÁºñËæëÂå∫Ôºå‰Ω†ÂèØ‰ª•ÊãñÂä®Âå∫ÂùóÊàñÂç°ÁâáÂ∑¶‰æßÁöÑ ‚ò∞ ÂõæÊ†áÊù•ÂØπÂÆÉ‰ª¨ËøõË°åÊéíÂ∫è„ÄÇ</p>
                <p><strong><span class="iconify" data-icon="mdi:view-dashboard-variant-outline" style="vertical-align: -0.2em;"></span> ÁÄëÂ∏ÉÊµÅÂ∏ÉÂ±ÄÔºö</strong> ÂØπ‰∫éÂ§öÂàóÂå∫ÂùóÔºàÂèåÊéí/‰∏âÊéíÔºâÔºåÂèØ‰ª•Âú®ÁºñËæëÂå∫ÂãæÈÄâ‚ÄúÂêØÁî®ÁÄëÂ∏ÉÊµÅ‚ÄùÔºå‰ΩøÂç°Áâá/ÂõæÁâáÈ´òÂ∫¶Ëá™ÈÄÇÂ∫îÔºåÂ∏ÉÂ±ÄÊõ¥Á¥ßÂáë„ÄÇ</p>
                <p><strong><span class="iconify" data-icon="mdi:lock-open-variant-outline" style="vertical-align: -0.2em;"></span> ÈîÅÂÆöÊ®°ÂºèÔºö</strong> ÁÇπÂáªÂè≥‰∏äËßíÁöÑ "ÁºñËæë‰∏≠" ÊåâÈíÆÂèØÂàáÊç¢Âà∞ "ÈîÅÂÆö‰∏≠"ÔºåÊ≠§Ê®°Âºè‰∏ãÁ¶ÅÁî®ÊãñÊãΩÔºåÊñπ‰æøÂú®ÊâãÊú∫‰∏äÈ°∫ÁïÖÊªëÂä®ÊµèËßà„ÄÇ</p>
                <p><strong><span class="iconify" data-icon="mdi:import" style="vertical-align: -0.2em;"></span> ÂØºÂÖ•/ÂØºÂá∫Ôºö</strong> ‰ΩøÁî®‚ÄúÂØºÂá∫ÈÖçÁΩÆ‚ÄùÊåâÈíÆÂèØ‰ª•‰øùÂ≠ò‰Ω†ÊâÄÊúâÁöÑËÆæËÆ°‰∏∫‰∏Ä‰∏™ .json Êñá‰ª∂ÔºåÊñπ‰æøÂ§á‰ªΩÂíåÂàÜ‰∫´„ÄÇ‰πãÂêéÂèØ‰ª•ÈÄöËøá‚ÄúÂØºÂÖ•ÈÖçÁΩÆ‚ÄùÊù•ÊÅ¢Â§ç„ÄÇ</p>
                <p><strong><span class="iconify" data-icon="mdi:content-save" style="vertical-align: -0.2em;"></span> Êú¨Âú∞‰øùÂ≠òÔºö</strong> ‰Ω†ÁöÑÊâÄÊúâ‰øÆÊîπÈÉΩ‰ºöËá™Âä®‰øùÂ≠òÂú®ÂΩìÂâçÊµèËßàÂô®‰∏≠ÔºåÂà∑Êñ∞È°µÈù¢‰∏ç‰ºö‰∏¢Â§±ËøõÂ∫¶ÔºàËØ∑Âãø‰ΩøÁî®Êó†ÁóïÊ®°ÂºèÔºâ„ÄÇ</p>
                <p><strong><span class="iconify" data-icon="mdi:shield-account-outline" style="vertical-align: -0.2em;"></span> Ê≥®ÊÑèÔºÅÂÖ≥‰∫éÊÇ®‰∏ä‰º†ÁöÑÂÜÖÂÆπÔºÅ</strong></p>
                <p>Blokko ÊòØ‰∏Ä‰∏™ÂÆåÂÖ®ÂÖçË¥πÁöÑÊú¨Âú∞Âàõ‰ΩúÂ∑•ÂÖ∑ÔºåÁõ∏‰ø°ÊÇ®‰ºöÁî®ÂÆÉÊù•Âà∂‰ΩúÂá∫Ëâ≤ÁöÑÂÜÖÂÆπÔºÅ</p>
                <p>‰ΩÜËøòËØ∑Ê≥®ÊÑèÔºåÂΩìÊÇ®‰ΩøÁî®‚Äú‰∏ä‰º†Â≠ó‰Ωì‚Äù„ÄÅ‚ÄúÂä†ËΩΩÊú¨Âú∞Â≠ó‰Ωì‚ÄùÊàñ‚Äú‰∏ä‰º†ÂõæÁâá/ÂõæÊ†á‚ÄùÂäüËÉΩÊó∂ÔºåÊÇ®ÈúÄË¶ÅÂØπËøô‰∫õÁ¥†ÊùêË¥üË¥£„ÄÇ<strong>ËØ∑Á°Æ‰øùÊÇ®‰∏ä‰º†Âíå‰ΩøÁî®ÁöÑ‰ªª‰ΩïÂ≠ó‰Ωì (ttf, woffÁ≠â)„ÄÅÂõæÁâáÊàñÂõæÊ†áÊñá‰ª∂ÔºåÈÉΩÂ∑≤Ëé∑Âæó‰∫ÜÂéüÁâàÊùÉÊñπÁöÑÂêàÊ≥ïÊéàÊùÉ„ÄÇ</strong></p>
                <p>Âõ†‰ΩøÁî®Êú™ÊéàÊùÉÁ¥†ÊùêËÄå‰∫ßÁîüÁöÑ‰ªª‰ΩïÁâàÊùÉÈóÆÈ¢òÔºåÂ∞ÜÈúÄË¶ÅÁî±ÊÇ®Ëá™Ë°åÊâøÊãÖÔºå<strong>Âõ†Ê≠§ÊàëÈºìÂä±ÊÇ®‰ΩøÁî®ÂºÄÊ∫êÁöÑÊó†ÁâàÊùÉÂèØÂïÜÁî®Â≠ó‰Ωì/ÂõæÁâá/ÂõæÊ†áÊñá‰ª∂„ÄÇ</strong></p>
		   </div>
            <div id="help-changelog" class="tab-content">
                <h4>v1.4.0 (ÂΩìÂâçÁâàÊú¨)</h4>
                <ul>
                    <li><b>„Äê‰ΩìÈ™å„Äë</b> Êñ∞Â¢û‰∫ÜÊñ∞ÊâãÊïôÁ®ãÔºÅÈ¶ñÊ¨°ÊâìÂºÄÂ∑•ÂÖ∑Êó∂‰ºöËá™Âä®ÂºπÂá∫ÔºåÂºïÂØºÊñ∞Áî®Êà∑Âø´ÈÄü‰∏äÊâã„ÄÇÂêéÁª≠ÂèØÂú®‚ÄúÂ∏ÆÂä©‚Äù‰∏≠Êü•Áúã„ÄÇ</li>
                    <li><b>„Äê‰ΩìÈ™å„Äë</b> ‰ºòÂåñ‰∫ÜÁºñËæëÂå∫ÁöÑÂ∏ÉÂ±ÄÔºåÂ∞Ü‚Äú‰∏™‰∫∫‰ø°ÊÅØ‚ÄùÂíå‚ÄúÂÜÖÂÆπÂå∫Âùó‚ÄùÁ≠âÂ∏∏Áî®È°πÂâçÊèêÔºåÂ∞Ü‚ÄúÂØºÂÖ•/ÂØºÂá∫‚ÄùÁ≠âÊìç‰ΩúÈ°πÂêéÁΩÆÔºåÊõ¥Á¨¶Âêà‰ΩøÁî®Áõ¥Ëßâ„ÄÇ</li>
                    <li><b>„Äê‰ΩìÈ™å„Äë</b> Âº∫Âåñ‰∫Ü‚ÄúÂèåÂáªÁºñËæë‚ÄùÁöÑÂºïÂØºÔºå‰∏∫Êñ∞Áî®Êà∑Â¢ûÂä†‰∫ÜÈÜíÁõÆÁöÑÊèêÁ§∫Êù°„ÄÇ</li>
                    <li><b>„Äê‰ºòÂåñ„Äë</b> ‰ºòÂåñ‰∫ÜPCÁ´ØÁöÑÁÇπÂáªÂÆö‰ΩçÂäüËÉΩÔºåÁé∞Âú®ÁÇπÂáªÈ¢ÑËßàÂå∫ÁöÑ‰ªªÊÑèÂç°ÁâáÔºåÂ∑¶‰æßÁºñËæëÂå∫Â∞ÜÁ≤æÁ°ÆÊªöÂä®Âà∞ËØ•Âç°ÁâáÁöÑËÆæÁΩÆ‰ΩçÁΩÆ„ÄÇ</li>
                    <li><b>„Äê‰øÆÂ§ç„Äë</b> ‰øÆÂ§ç‰∫ÜÊâãÊú∫Á´ØÁºñËæëÈù¢ÊùøÂèØËÉΩ‰ºöÂá∫Áé∞Ê∞¥Âπ≥ÊªöÂä®Êù°ÁöÑÈóÆÈ¢ò„ÄÇ</li>
                    <li><b>„Äê‰øÆÂ§ç„Äë</b> ‰øÆÂ§ç‰∫ÜÁºñËæëÂå∫ÂÜÖÂèØÊäòÂè†È°πÁõÆ‰πãÈó¥ÂûÇÁõ¥Èó¥Ë∑ùËøáÂ§ßÁöÑÈóÆÈ¢òÔºå‰ΩøÂ∏ÉÂ±ÄÊõ¥Á¥ßÂáë„ÄÇ</li>
                    <li><b>„Äê‰øÆÂ§ç„Äë</b> ÈáçÊûÑ‰∫Ü‚ÄúÈ°µÈù¢‰∏éÂ§¥ÈÉ®Ê†∑Âºè‚ÄùÂå∫ÂùóÔºåÂ∞ÜÂÖ∂ÊãÜÂàÜ‰∏∫‰∏§‰∏™Áã¨Á´ãÁöÑÊäòÂè†È°πÔºåËß£ÂÜ≥‰∫ÜÁÇπÂáªÂÜÖÈÉ®Ê†áÁ≠æÈ°µÂØºËá¥Êï¥‰∏™Âå∫ÂùóÊäòÂè†ÁöÑ‰∫§‰∫íÈóÆÈ¢ò„ÄÇ</li>
                </ul>
                <hr class="separator">
                <h4>v1.3.2</h4>
                <ul>
                    <li><b>„ÄêÊñ∞Â¢û„Äë</b> ‰∏∫Â§öÂàóÊñáÊú¨Âå∫ÂùóÔºàÂèåÊéí/‰∏âÊéíÔºâÂ¢ûÂä†‰∫ÜÁÄëÂ∏ÉÊµÅÔºàMasonryÔºâÂ∏ÉÂ±ÄÈÄâÈ°π„ÄÇÂêØÁî®ÂêéÔºåÂç°ÁâáÂ∞ÜÊ†πÊçÆÂÜÖÂÆπËá™ÈÄÇÂ∫îÈ´òÂ∫¶ÔºåÂπ∂Á¥ßÂáëÊéíÂàóÔºåËß£ÂÜ≥‰∫ÜÂõ†Âç°ÁâáÈ´òÂ∫¶‰∏ç‰∏ÄÂØºËá¥ÁöÑÂ∏ÉÂ±ÄÁ©∫Ê¥ûÈóÆÈ¢ò„ÄÇ</li>
                    <li><b>„ÄêÊñ∞Â¢û/ÈáçÊûÑ„Äë</b> ÂõæÁâáÂå∫ÂùóÂ∑≤ÂÆåÂÖ®ÈáçÊûÑÔºåÁé∞Âú®‰∏éÊñáÊú¨Âå∫ÂùóÊã•ÊúâÁªü‰∏ÄÁöÑÂç°ÁâáÂºèÁÆ°ÁêÜÈÄªËæë„ÄÇÂèØ‰ª•‰∏∫ÂõæÁâáÂå∫ÂùóÂêØÁî®ÁÄëÂ∏ÉÊµÅÂ∏ÉÂ±ÄÔºåÂÆûÁé∞ÂÆåÁæéÁöÑÂõæÁâáÂ¢ôÊïàÊûú„ÄÇ</li>
                    <li><b>„ÄêÊñ∞Â¢û„Äë</b> Âú®ÁîµËÑëÁ´ØÔºåÁÇπÂáªÊàñÂèåÂáªÈ¢ÑËßàÂå∫ÁöÑÂå∫ÂùóÊó∂ÔºåÂ∑¶‰æßÁºñËæëÈù¢Êùø‰ºöËá™Âä®ÂÆö‰ΩçÂπ∂Â±ïÂºÄÂà∞ËØ•Âå∫ÂùóÁöÑËÆæÁΩÆÂå∫ÂüüÔºåÊñπ‰æøÂø´ÈÄü‰øÆÊîπ„ÄÇ</li>
                    <li><b>„Äê‰ºòÂåñ„Äë</b> ‰ºòÂåñ‰∫ÜÈÉ®ÂàÜÊñáÊú¨Ë°®Ëø∞„ÄÇ</li>
                    <li><b>„Äê‰ºòÂåñ„Äë</b> ÂØºÂÖ•ÊóßÁâàÈÖçÁΩÆÊñá‰ª∂Êó∂Ôºå‰ºöËá™Âä®Â∞ÜÊóßÁöÑÂõæÁâáÂå∫ÂùóÊï∞ÊçÆÁªìÊûÑÊó†ÁºùËøÅÁßªÂà∞Êñ∞ÁöÑÂç°ÁâáÂºèÁªìÊûÑÔºå‰øùËØÅÂÖºÂÆπÊÄß„ÄÇ</li>
                    <li><b>„Äê‰ºòÂåñ„Äë</b> Êõ¥Êñ∞‰∫Ü‚ÄúÊÑüË∞¢‰ø°ÊÅØ‚ÄùÈ°µÈù¢ÔºåÂä†ÂÖ•‰∫ÜÂØπ Masonry.js ÂºÄÊ∫êÂ∫ìÁöÑÊÑüË∞¢„ÄÇ</li>
                </ul>
                <hr class="separator">
                <h4>v1.3.1</h4>
                <ul>
                    <li><b>„ÄêÊñ∞Â¢û„Äë</b> ÂÜÖÁΩÆ4Ê¨æÊé®ËçêÂ≠ó‰ΩìÔºàÊÄùÊ∫êÈªë‰Ωì„ÄÅÊÄùÊ∫êÂÆã‰Ωì„ÄÅÁ´ôÈÖ∑Âø´‰πê‰Ωì„ÄÅÁ´ôÈÖ∑Â∞èËñá‰ΩìÔºâÔºåÈÄöËøáÂõΩÂÜÖCDNÂä†ÈÄüÔºåÊó†ÈúÄÊâãÂä®‰∏ä‰º†„ÄÇ</li>
                    <li><b>„Äê‰ºòÂåñ„Äë</b> Â∏ÆÂä©ÂºπÁ™óÈáçÊûÑ‰∏∫Âõõ‰∏™Áã¨Á´ãÂàÜÈ°µÔºö‰ΩøÁî®ËØ¥Êòé„ÄÅÊõ¥Êñ∞Êó•Âøó„ÄÅÊÑüË∞¢‰ø°ÊÅØ„ÄÅÂÖ≥‰∫é„ÄÇ</li>
                    <li><b>„Äê‰ºòÂåñ„Äë</b> ‚ÄúÊÑüË∞¢‰ø°ÊÅØ‚ÄùÈ°µËøõË°åÂêàËßÑÊÄßÂ¢ûÂº∫Ôºå‰∏∫ÊØè‰∏™ÂºÄÊ∫êÈ°πÁõÆÊèê‰æõÁã¨Á´ãÁöÑËÆ∏ÂèØËØÅÂéüÊñáÔºàÂèØÊäòÂè†Êü•ÁúãÔºâ„ÄÇ</li>
                </ul>
                <hr class="separator">
                <h4>v1.3.0</h4>
                <ul>
                    <li><b>„ÄêÊñ∞Â¢û„Äë</b> Ëá™ÂÆö‰πâÂØºÂá∫ÂÆΩÂ∫¶„ÄÅËÉåÊôØÁ∫πÁêÜ„ÄÅ‰∏âÂàóÂ∏ÉÂ±Ä„ÄÅÁïôÁôΩÂùóÁ≠âÂäüËÉΩ„ÄÇ</li>
                    <li><b>„Äê‰øÆÂ§ç„Äë</b> ‰øÆÂ§ç‰∫ÜÂèåÂáªÁºñËæëÂè™ËÉΩËæìÂÖ•‰∏Ä‰∏™Â≠óÁ¨¶„ÄÅÂØºÂá∫ÂõæÁâáËÉåÊôØÂõæ‰∏¢Â§±Á≠âÂ§öÈ°πBUG„ÄÇ</li>
                    <li><b>„Äê‰ºòÂåñ„Äë</b> Ë∞ÉÊï¥‰∫ÜÈÉ®ÂàÜUIÔºåÂπ∂Â∞ÜÂõæÊ†áÂ∫ìÊù•Ê∫êË∞ÉÊï¥‰∏∫Êó†ÈúÄÁΩ≤ÂêçÁöÑÂºÄÊ∫êÂõæÊ†áÂ∫ì„ÄÇ</li>
                </ul>
            </div>
            <div id="help-thanks" class="tab-content">
                <p>Êú¨Â∑•ÂÖ∑ÁöÑÂÆûÁé∞Á¶ª‰∏çÂºÄ‰ª•‰∏ã‰ºòÁßÄÁöÑÂºÄÊ∫êÈ°πÁõÆÔºåÂú®Ê≠§Ë°®Á§∫ËØöÊåöÁöÑÊÑüË∞¢Ôºö</p>
                <div class="thanks-item">
                    <h4>ÂºÄÊ∫êÂ≠ó‰Ωì</h4>
                    <p>Êú¨È°πÁõÆÈõÜÊàêÁöÑÊé®ËçêÂ≠ó‰ΩìÂùáÂü∫‰∫é <strong>SIL Open Font License 1.1</strong> ÂçèËÆÆÔºåÂèØÂÖçË¥πÂïÜÁî®„ÄÇ</p>
                    <ul>
                        <li><a href="https://github.com/adobe-fonts/source-han-sans" target="_blank" rel="noopener noreferrer"><strong>ÊÄùÊ∫êÈªë‰Ωì (Source Han Sans)</strong></a> - Áî± Adobe ‰∏é Google ËÅîÂêàÂºÄÂèë„ÄÇ</li>
                        <li><a href="https://github.com/adobe-fonts/source-han-serif" target="_blank" rel="noopener noreferrer"><strong>ÊÄùÊ∫êÂÆã‰Ωì (Source Han Serif)</strong></a> - Áî± Adobe ‰∏é Google ËÅîÂêàÂºÄÂèë„ÄÇ</li>
                        <li><a href="https://www.zcool.com.cn/work/ZMTg5Njc2NTI=.html" target="_blank" rel="noopener noreferrer"><strong>Á´ôÈÖ∑Âø´‰πê‰Ωì (ZCOOL KuaiLe)</strong></a> - Áî± Á´ôÈÖ∑ (ZCOOL) ËÆæËÆ°Â∏àÂõ¢ÈòüÂàõ‰Ωú„ÄÇ</li>
                        <li><a href="https://www.zcool.com.cn/work/ZMTg5ODY0NDQ=.html" target="_blank" rel="noopener noreferrer"><strong>Á´ôÈÖ∑Â∞èËñá‰Ωì (ZCOOL XiaoWei)</strong></a> - Áî± Á´ôÈÖ∑ (ZCOOL) ËÆæËÆ°Â∏àÂõ¢ÈòüÂàõ‰Ωú„ÄÇ</li>
                    </ul>
                    <details>
                        <summary>Êü•Áúã SIL Open Font License 1.1 ËÆ∏ÂèØËØÅÂéüÊñá</summary>
                        <pre><code>Copyright (c) 2005-2020, SIL International (http://www.sil.org/) with Reserved Font Names "SIL".

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL

-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a framework in which fonts may be shared and improved in partnership with others.

The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the copyright statement(s).

"Original Version" refers to the collection of Font Software components as distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting, or substituting ‚Äî in part or in whole ‚Äî any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.

"Author" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.

5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE FONT SOFTWARE OR THE USE OR OTHER DEALINGS IN THE FONT SOFTWARE.
</code></pre>
                    </details>
                </div>
                <div class="thanks-item">
                    <h4>Ê†∏ÂøÉÂäüËÉΩÂ∫ì</h4>
                    <p>‰ª•‰∏ãÈ°πÁõÆÂùáÂü∫‰∫é <strong>MIT License</strong> ÂçèËÆÆÔºåÁâπÊ≠§ÊÑüË∞¢„ÄÇ</p>
                    <ul>
                        <li><a href="https://html2canvas.hertzen.com/" target="_blank" rel="noopener noreferrer"><strong>html2canvas</strong></a> - ÂÆûÁé∞‰∫ÜÂ∞ÜÁΩëÈ°µÂÜÖÂÆπÂØºÂá∫‰∏∫ÂõæÁâáÁöÑÊ†∏ÂøÉÂäüËÉΩ„ÄÇ</li>
                        <li><a href="https://fengyuanchen.github.io/cropperjs/" target="_blank" rel="noopener noreferrer"><strong>Cropper.js</strong></a> - Êèê‰æõ‰∫ÜÂº∫Â§ßÁöÑÂõæÁâáË£ÅÂâ™ÂäüËÉΩ„ÄÇ</li>
                        <li><a href="https://sortablejs.github.io/Sortable/" target="_blank" rel="noopener noreferrer"><strong>SortableJS</strong></a> - Êèê‰æõ‰∫ÜÊµÅÁïÖÁöÑÊãñÊãΩÊéíÂ∫è‰ΩìÈ™å„ÄÇ</li>
                        <li><a href="https://masonry.desandro.com/" target="_blank" rel="noopener noreferrer"><strong>Masonry.js</strong></a> - Êèê‰æõ‰∫ÜÂº∫Â§ßÁöÑÁÄëÂ∏ÉÊµÅ/Á†å‰ΩìÂ∏ÉÂ±ÄÂäüËÉΩ„ÄÇ</li>
                    </ul>
                    <details>
                        <summary>Êü•Áúã MIT License ËÆ∏ÂèØËØÅÂéüÊñá</summary>
                        <pre><code>The MIT License (MIT)

Copyright (c) &lt;year&gt; &lt;copyright holders&gt;

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</code></pre>
                    </details>
                </div>
                <div class="thanks-item">
                    <h4>ËµÑÊ∫ê‰∏éÊúçÂä°</h4>
                    <ul>
                        <li><a href="https://iconify.design/" target="_blank" rel="noopener noreferrer"><strong>Iconify</strong></a>: Êèê‰æõ‰∫ÜÁªü‰∏ÄÁöÑÂõæÊ†áÊ£ÄÁ¥¢ÂíåÂä†ËΩΩÂäüËÉΩ„ÄÇÊú¨È°πÁõÆ‰ΩøÁî®ÁöÑÂõæÊ†áÂ∫ìÔºàÂ¶ÇMDI, Tabler, LucideÁ≠âÔºâÂùáÂü∫‰∫éÂØπÂïÜ‰∏öÂèãÂ•ΩÁöÑÂºÄÊ∫êÂçèËÆÆÂèëÂ∏É„ÄÇ</li>
                        <li><a href="https://heropatterns.com/" target="_blank" rel="noopener noreferrer"><strong>Hero Patterns</strong></a>: Êèê‰æõ‰∫ÜÁ≤æÁæé„ÄÅÂèØÂÆöÂà∂ÁöÑSVGËÉåÊôØÁ∫πÁêÜ (MIT License)„ÄÇ</li>
                    </ul>
                </div>
            </div>
            <div id="help-about" class="tab-content">
                <h4>ÂÖ≥‰∫é Blokko</h4>
                <p>BlokkoÊòØ‰∏Ä‰∏™Êñπ‰æøÂ§ßÂÆ∂Âø´ÈÄüÂà∂‰ΩúÊâ©Âàó/Ëá™Ëçê/ÁΩÆÈ°∂ÂõæÁöÑÂ∞èÂ∑•ÂÖ∑ÔºÅ</p>
                <p><strong>‰ΩúËÄÖÔºö</strong> ÂõõÂçÅ‰∏É</p>
                <p>Â¶ÇÊûú‰Ω†Âú®‰ΩøÁî®‰∏≠ÈÅáÂà∞BUGÔºåÂèØ‰ª•ÈÄöËøáÈìæÊé•ÁßÅ‰ø°ÊàëÔºÅ</p>
                <p><a href="https://weibo.com/u/5095783616" target="_blank" rel="noopener noreferrer"><strong>ÊàëÁöÑÂæÆÂçö‰∏ªÈ°µ</strong></a></p>
            </div>
            <div class="modal-actions" style="justify-content: center; margin-top: 20px;">
                <button id="help-modal-close-btn" class="btn btn-primary">ÂÖ≥Èó≠</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="icon-picker-modal">
        <div class="modal-container">
            <h3>ÈÄâÊã©ÂõæÊ†á</h3>
            <div class="form-group">
                <input type="text" id="icon-search" placeholder="ÊêúÁ¥¢ÂõæÊ†á (‰æãÂ¶Ç: bilibili, music, home, user)..." class="form-control">
            </div>
            <div id="icon-grid"></div>
            <div class="modal-actions">
                <button id="upload-icon-btn" class="btn btn-secondary">‰∏ä‰º†ÂõæÊ†á (.svg)</button>
                <input type="file" id="icon-upload-input" accept=".svg" style="display: none;">
                <button id="remove-icon-btn" class="btn btn-danger">ÁßªÈô§ÂõæÊ†á</button>
                <button id="icon-picker-close-btn" class="btn btn-default">ÂèñÊ∂à</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="texture-picker-modal">
        <div class="modal-container">
            <h3>ÈÄâÊã©ËÉåÊôØÁ∫πÁêÜ</h3>
            <div id="texture-grid"></div>
            <div class="modal-actions">
                <button id="remove-texture-btn" class="btn btn-danger">ÁßªÈô§Á∫πÁêÜ</button>
                <button id="texture-picker-close-btn" class="btn btn-default">ÂèñÊ∂à</button>
            </div>
        </div>
    </div>

    <div id="loading-overlay"><div class="spinner"></div><span id="loading-text">Ê≠£Âú®Â§ÑÁêÜ...</span></div>
    <div class="toast-notification-container" id="toast-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.2/Sortable.min.js"></script>
    <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
    <script src="https://code.iconify.design/3/3.1.1/iconify.min.js"></script>
    
    <script>
        // Hero Patterns data. Source: https://heropatterns.com/
        const HeroPatterns = [
            { name: 'Jigsaw', svg: (c, o) => `<svg width="60" height="60" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg"><path d="M41.512 41.512c.976.976 2.256.488 2.256-1.024v-6.728c0-1.512.732-2.256 2.256-2.256h6.728c1.512 0 2.016-.244 1.024-2.256-3.904-7.808-7.808-11.712-11.712-11.712-3.904 0-7.808 3.904-11.712 11.712-.992 2.012-.504 2.256 1.024 2.256h6.728c1.512 0 2.256.732 2.256 2.256v6.728c0 1.512.244 2.016 2.256 1.024zM59 60c.504 0 1-.488 1-1V38.864c0-1.512.732-2.256 2.256-2.256h10.128c1.008 0 1.512.22 1.512 1.248 0 4.88-3.904 9.76-11.712 9.76-7.808 0-11.712-4.88-11.712-9.76 0-1.028.504-1.248 1.512-1.248h10.128c1.512 0 2.256.732 2.256 2.256V59c0 .512.488 1 1 1h16.336c.512 0 1-.488 1-1V38.864c0-1.512.732-2.256 2.256-2.256h10.128c1.008 0 1.512.22 1.512 1.248 0 4.88-3.904 9.76-11.712 9.76-7.808 0-11.712-4.88-11.712-9.76 0-1.028.504-1.248 1.512-1.248h10.128c1.512 0 2.256.732 2.256 2.256V59c0 .512.488 1 1 1H59z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Overlapping Circles', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><circle cx="5" cy="5" r="5"/><circle cx="15" cy="5" r="5"/><circle cx="5" cy="15" r="5"/><circle cx="15" cy="15" r="5"/></g></svg>` },
            { name: 'Plus', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 2h2v2H2V2zm4 0h2v2H6V2zm4 0h2v2h-2V2zm4 0h2v2h-2V2zM2 6h2v2H2V6zm4 0h2v2H6V6zm4 0h2v2h-2V6zm4 0h2v2h-2V6zM2 10h2v2H2v-2zm4 0h2v2H6v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zM2 14h2v2H2v-2zm4 0h2v2H6v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'X-Equals', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 2.5a.5.5 0 01.5-.5h14a.5.5 0 01.5.5v1a.5.5 0 01-.5.5h-14a.5.5 0 01-.5-.5v-1zM17 6H3a1 1 0 000 2h14a1 1 0 000-2zM3 12h14a1 1 0 000-2H3a1 1 0 100 2zm15 3.5a.5.5 0 01-.5.5h-14a.5.5 0 01-.5-.5v-1a.5.5 0 01.5-.5h14a.5.5 0 01.5.5v1z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Brick Wall', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h20v20H0V0zm10 12h10v2H10v-2zM0 2h10v2H0V2zm0 8h10v2H0v-2zm10 0h10v2H10v-2zM0 6h10v2H0V6zm10-4h10v2H10V2zM0 14h10v2H0v-2zm10 4h10v2H10v-2z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Floating Cogs', svg: (c, o) => `<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M9 13.09V5.5c0-.828.672-1.5 1.5-1.5h5c.828 0 1.5.672 1.5 1.5v7.59a4.5 4.5 0 10-8 0zM5.5 13a3.5 3.5 0 000 7h15a3.5 3.5 0 000-7H5.5z"/><path d="M9 13.09V5.5c0-.828.672-1.5 1.5-1.5h5c.828 0 1.5.672 1.5 1.5v7.59a4.5 4.5 0 10-8 0zM5.5 13a3.5 3.5 0 000 7h15a3.5 3.5 0 000-7H5.5z" transform="rotate(180 13 13)"/></g></svg>` },
            { name: 'Polka Dots', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><circle cx="3" cy="3" r="3"/><circle cx="13" cy="13" r="3"/></g></svg>` },
            { name: 'Faceted', svg: (c, o) => `<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M0 40L40 0H20L0 20z" /><path d="M40 40V20L20 40z" /></g></svg>`},
            { name: 'Topography', svg: (c, o) => `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm5 8c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm10 0c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm13-8c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-5 8c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-10 0c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-5-18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Lines In Motion', svg: (c, o) => `<svg width="80" height="80" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><path d="M20 20v40h40V20H20zm20 38c-9.94 0-18-8.06-18-18s8.06-18 18-18 18 8.06 18 18-8.06 18-18 18z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Cicada Stripe', svg: (c, o) => `<svg width="6" height="6" viewBox="0 0 6 6" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>` },
            { name: 'Diamonds', svg: (c, o) => `<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M0 5h5L0 0v5zm10 0h-5l5-5v5zM0 5h5l5 5H5L0 5zm10 0h-5l-5 5h5l5-5z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Texture', svg: (c, o) => `<svg width="52" height="26" viewBox="0 0 52 26" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M10 10c0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6h2c0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4v2c-3.314 0-6-2.686-6-6 0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6zm25.464-1.95l8.486 8.486-1.414 1.414-8.486-8.486 1.414-1.414z" /><path d="M41.464 15.05l8.486-8.486-1.414-1.414-8.486 8.486 1.414 1.414z" /></g></svg>` },
            { name: 'Cross', svg: (c, o) => `<svg width="8" height="8" viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg"><path d="M4 0h1v3h3v1H5v3H4V4H1V3h3z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Rain', svg: (c, o) => `<svg width="4" height="4" viewBox="0 0 4 4" xmlns="http://www.w3.org/2000/svg"><path d="M1 3h1v1H1V3zm2-2h1v1H3V1z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Diagonal Lines', svg: (c, o) => `<svg width="4" height="4" viewBox="0 0 4 4" xmlns="http://www.w3.org/2000/svg"><path d="M-1 3h1v1H-1V3zm2-2h1v1H1V1zm2-2h1v1H3V-1z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Chevrons', svg: (c, o) => `<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M0 0l5 5-5 5h5l5-5-5-5H0z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
        ];

        document.addEventListener('DOMContentLoaded', () => {
            const App = {
                state: {},
                history: [],
                historyIndex: -1,
                isRestoringState: false,
                isEditingText: false,
                cropper: null,
                currentCropTarget: null,
                currentIconTarget: null, 
                sortableBlocksEditor: null,
                sortableBlocksPreview: null,
                cardSortables: {},
                imageCardSortables: {},
                masonryInstances: {},
                debouncedSaveToLocal: null,
                localFonts: [],
                uploadedFonts: [],
                presets: {},
                icons: [], 

                init() {
                    console.log("Blokko ÂàùÂßãÂåñ v1.4.0 ...");
                    this.elements = this.queryElements();
                    this.presets = this.getPresets();
                    this.state = this.getDefaultState();
                    this.debouncedSaveToLocal = this.debounce(this.saveToLocal, 500);
                    
                    this.bindCoreEvents();
                    this.bindEditorEvents();
                    this.bindPreviewEvents();
                    this.initResizer();
                    this.renderTexturePicker();
                    
                    this.loadPreferences();
                    this.loadFromLocal();
                    
                    this.history = [this.deepClone(this.state)];
                    this.historyIndex = 0;
                    this.updateUndoRedoButtons();
                    
                    this.syncAllControls();
                    this.renderAll(true); 
                    this.populateFontList(); 
                    this.initAllSortables();
                    this.updateExportSizePreview();
                    this.loadIcons(); 
                    
                    document.getElementById('personal-info-section').classList.remove('collapsed');

                    // --- NEW v1.4.0: First visit checks ---
                    this.handleFirstVisit();
                },

                getDefaultState() {
                    const lightTheme = this.getPresets().light;
                    return {
                        customIcons: [],
                        personalInfo: { 
                            nickname: "‰Ω†ÁöÑÊòµÁß∞", nicknameColor: lightTheme.pNicknameColor,
                            subtitle: "ËøôÊòØÂâØÊ†áÈ¢òÔºåÂèåÂáªÂèØÁºñËæë", subtitleColor: lightTheme.pSubtitleColor,
                            bio: "ËøôÊòØÁÆÄ‰ªãÔºåÂèåÂáªÂèØÁºñËæë", bioColor: lightTheme.pBioColor,
                            avatarDataUrl: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23cccccc'%3E%3Cpath d='M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z'/%3E%3C/svg%3E", 
                            avatarShape: '50%', avatarBorderSize: 4, avatarBorderColor: '#ffffff',
                            tags: [
                                { id: this.generateId('t'), icon: 'mdi:palette', text: 'ËÆæËÆ°Â∏à' },
                                { id: this.generateId('t'), icon: 'mdi:github', text: '‰ª£Á†ÅÁà±Â•ΩËÄÖ' }
                            ], 
                            tagBgColor: lightTheme.pTagBgColor, tagTextColor: lightTheme.pTagTextColor
                        },
                        pageStyles: {
                            pageBgMode: 'gradient',
                            pageBgSolidColor: lightTheme.pageBgSolidColor, pageBgImageDataUrl: null, 
                            pageBgGradientStart: lightTheme.pageBgGradientStart, pageBgGradientEnd: lightTheme.pageBgGradientEnd,
                            pageBgGradientAngle: 135,
                            pageOverlayColor: "#000000", pageOverlayOpacity: 0.3,
                            pageBgPattern: '', pageBgPatternColor: '#000000', pageBgPatternOpacity: 0.1, pageBgPatternDensity: 30,
                            headerBgMode: 'gradient',
                            headerBgColor: lightTheme.headerBgColor, headerTextColor: lightTheme.headerTextColor, headerOpacity: 1.0, 
                            headerBgGradientStart: lightTheme.headerBgGradientStart, headerBgGradientEnd: lightTheme.headerBgGradientEnd,
                            headerBgGradientAngle: 135,
                        },
                        blocks: [
                            { id: this.generateId('b'), type: 'text', title: "ÂçïÊéíÂç°ÁâáÂå∫Âùó", settings: { layout: 'single', masonryEnabled: false }, cards: [
                                { id: this.generateId('c'), icon: '', title: "ËøôÊòØÂçïÊéíÂç°Áâá", content: "ÂèåÂáªËøôÈáåËøõË°åÁºñËæë", opacity: 1.0, followGlobalOpacity: true }
                            ]},
                            { id: this.generateId('b'), type: 'text', title: "ÂèåÊéíÂç°ÁâáÂå∫Âùó", settings: { layout: 'dual', masonryEnabled: false }, cards: [
                                { id: this.generateId('c'), icon: '', title: "ËøôÊòØÂèåÊéíÂç°Áâá 1", content: "ÂèåÂáªËøôÈáåËøõË°åÁºñËæë", opacity: 1.0, followGlobalOpacity: true },
                                { id: this.generateId('c'), icon: '', title: "ËøôÊòØÂèåÊéíÂç°Áâá 2", content: "ÂèåÂáªËøôÈáåËøõË°åÁºñËæë", opacity: 1.0, followGlobalOpacity: true }
                            ]},
                            { id: this.generateId('b'), type: 'separator', title: "ÂàÜÂâ≤Á∫ø", settings: { style: 'solid', color: '#dddddd', thickness: 1, margin: 20 }},
                            { id: this.generateId('b'), type: 'image', title: "ÂõæÁâáÂå∫Âùó", settings: { layout: 'dual', masonryEnabled: false, textColor: '' }, cards: [] },
                            { id: this.generateId('b'), type: 'spacer', title: "ÁïôÁôΩÂùó", settings: { height: 20 }},
                        ],
                        globalCardStyles: { 
                            bgMode: 'solid', 
                            bgColor: lightTheme.gCardBgColor, textColor: lightTheme.gCardTextColor, opacity: 1.0,
                            bgGradientStart: lightTheme.gCardBgGradientStart, bgGradientEnd: lightTheme.gCardBgGradientEnd,
                            bgGradientAngle: 135,
                            shadowEnabled: true, radius: 12, textAlign: "left", lineHeight: "1.5", 
                            fontFamily: "", fontSize: "1rem",
                            textStrokeWidth: 0, textStrokeColor: "#000000",
                            borderWidth: 0, borderStyle: 'none', borderColor: '#cccccc',
                        }
                    };
                },
                
                getPresets() {
                    return {
                        light: {
                            pageBgSolidColor: "#f0f2f5", pageBgGradientStart: "#f0f2f5", pageBgGradientEnd: "#e6e9ed",
                            headerBgColor: "#ffffff", headerBgGradientStart: "#ffffff", headerBgGradientEnd: "#f7f7f7",
                            headerTextColor: "#1a1a1a",
                            gCardBgColor: "#ffffff", gCardTextColor: "#1a1a1a", gCardOpacity: 1.0,
                            gCardBgGradientStart: "#ffffff", gCardBgGradientEnd: "#f5f5f5",
                            pNicknameColor: "#1a1a1a", pSubtitleColor: "#555555", pBioColor: "#555555",
                            pTagBgColor: "#eef1f5", pTagTextColor: "#3c3c43",
                        },
                        dark: {
                            pageBgSolidColor: "#121417", pageBgGradientStart: "#121417", pageBgGradientEnd: "#1a1d21",
                            headerBgColor: "#1f2229", headerBgGradientStart: "#1f2229", headerBgGradientEnd: "#252930",
                            headerTextColor: "#f0f2f5",
                            gCardBgColor: "#2c303a", gCardTextColor: "#f0f2f5", gCardOpacity: 0.95,
                            gCardBgGradientStart: "#2c303a", gCardBgGradientEnd: "#343946",
                            pNicknameColor: "#f0f2f5", pSubtitleColor: "#a0aec0", pBioColor: "#a0aec0",
                            pTagBgColor: "#3e4451", pTagTextColor: "#e2e8f0",
                        },
                        mint: {
                            pageBgSolidColor: "#ccfbf1", pageBgGradientStart: "#ccfbf1", pageBgGradientEnd: "#a7f3d0",
                            headerBgColor: "#f0fdfa", headerBgGradientStart: "#f0fdfa", headerBgGradientEnd: "#e6fcf5",
                            headerTextColor: "#0f766e",
                            gCardBgColor: "#ffffff", gCardTextColor: "#134e4a", gCardOpacity: 1.0,
                            gCardBgGradientStart: "#ffffff", gCardBgGradientEnd: "#fafffd",
                            pNicknameColor: "#064e3b", pSubtitleColor: "#115e59", pBioColor: "#134e4a",
                            pTagBgColor: "#a7f3d0", pTagTextColor: "#065f46",
                        },
                        coffee: {
                            pageBgSolidColor: "#f3e8e2", pageBgGradientStart: "#f3e8e2", pageBgGradientEnd: "#e9d8cf",
                            headerBgColor: "#fdf8f6", headerBgGradientStart: "#fdf8f6", headerBgGradientEnd: "#faf3ef",
                            headerTextColor: "#432818",
                            gCardBgColor: "#ffffff", gCardTextColor: "#5e4534", gCardOpacity: 1.0,
                            gCardBgGradientStart: "#ffffff", gCardBgGradientEnd: "#fffbf8",
                            pNicknameColor: "#432818", pSubtitleColor: "#6f4e37", pBioColor: "#5e4534",
                            pTagBgColor: "#e3d5ca", pTagTextColor: "#432818",
                        }
                    };
                },

                queryElements() {
                    const q = (selector) => document.querySelector(selector);
                    return {
                        editorPanel: q('#editor-panel'),
                        previewPanel: q('#preview-panel'),
                        resizer: q('#resizer'),
                        themeToggleBtn: q('#theme-toggle-btn'), themeLabel: q('#theme-label'),
                        previewWrapper: q('#preview-wrapper'), previewOverlay: q('#preview-overlay'),
                        undoBtn: q('#undo-btn'), redoBtn: q('#redo-btn'),
                        importBtn: q('#import-btn'), exportBtn: q('#export-btn'),
                        exportTemplateBtn: q('#export-template-btn'), 
                        exportPngBtn: q('#export-png-btn'), configFileInput: q('#config-file-input'),
                        hdExportToggle: q('#hd-export-toggle'), customWidthToggle: q('#custom-width-toggle'), customWidthInput: q('#custom-width-input'), exportSizePreview: q('#export-size-preview'),
                        exportRoundedCornersToggle: q('#export-rounded-corners-toggle'), exportCornerRadiusInput: q('#export-corner-radius-input'),
                        previewHeader: q('#preview-header'), previewAvatar: q('#preview-avatar'),
                        previewNickname: q('#preview-nickname'), previewSubtitle: q('#preview-subtitle'),
                        previewBio: q('#preview-bio'), previewTagsContainer: q('#preview-tags-container'),
                        pageBgUpload: q('#page-bg-upload'), clearPageBgBtn: q('#clear-page-bg-btn'),
                        pageImageControls: q('#page-image-controls'),
                        cropperModal: q('#cropper-modal'), cropperImage: q('#cropper-image'),
                        cropperCancelBtn: q('#cropper-cancel-btn'), cropperSaveBtn: q('#cropper-save-btn'),
                        downloadModal: q('#download-modal'), downloadModalTitle: q('#download-modal-title'),
                        downloadModalContent: q('#download-modal-content'), downloadModalCloseBtn: q('#download-modal-close-btn'),
                        addTextBlockBtn: q('#add-text-block-btn'), addImageBlockBtn: q('#add-image-block-btn'),
                        addSeparatorBlockBtn: q('#add-separator-block-btn'), addSpacerBlockBtn: q('#add-spacer-block-btn'),
                        editorBlocksList: q('#editor-blocks-list'), previewBlocksContainer: q('#preview-blocks-container'),
                        fontFamilySelect: q('#font-family-select'),
                        fontSearchInput: q('#font-search-input'),
                        loadingOverlay: q('#loading-overlay'), loadingText: q('#loading-text'),
                        toastContainer: q('#toast-container'),
                        mobileEditToggle: q('#mobile-edit-toggle'),
                        body: document.body,
                        showHelpBtn: q('#show-help-btn'),
                        helpModal: q('#help-modal'),
                        helpModalCloseBtn: q('#help-modal-close-btn'),
                        tutorialCloseBtn: q('#tutorial-close-btn'),
                        iconPickerModal: q('#icon-picker-modal'),
                        iconGrid: q('#icon-grid'),
                        iconSearch: q('#icon-search'),
                        removeIconBtn: q('#remove-icon-btn'),
                        iconPickerCloseBtn: q('#icon-picker-close-btn'),
                        uploadIconBtn: q('#upload-icon-btn'), iconUploadInput: q('#icon-upload-input'),
                        resetBtn: q('#reset-btn'),
                        lockModeToggle: q('#lock-mode-toggle'),
                        tagManagerList: q('#tag-manager-list'),
                        newTagTextInput: q('#new-tag-text-input'),
                        addNewTagBtn: q('#add-new-tag-btn'),
                        showTexturePickerBtn: q('#show-texture-picker-btn'),
                        texturePickerModal: q('#texture-picker-modal'),
                        textureGrid: q('#texture-grid'),
                        removeTextureBtn: q('#remove-texture-btn'),
                        texturePickerCloseBtn: q('#texture-picker-close-btn'),
                        pageTextureControls: q('#page-texture-controls'),
                        currentTextureName: q('#current-texture-name'),
                        clearTextureBtn: q('#clear-texture-btn'),
                        newbieTipBar: q('#newbie-tip-bar'),
                        newbieTipCloseBtn: q('#newbie-tip-close-btn'),
                    };
                },

                bindCoreEvents() {
                    this.elements.themeToggleBtn.addEventListener('click', () => this.toggleTheme());
                    this.elements.undoBtn.addEventListener('click', () => this.undo());
                    this.elements.redoBtn.addEventListener('click', () => this.redo());
                    this.elements.importBtn.addEventListener('click', () => this.elements.configFileInput.click());
                    this.elements.exportBtn.addEventListener('click', () => this.exportConfig(false)); 
                    this.elements.exportTemplateBtn.addEventListener('click', () => this.exportConfig(true)); 
                    this.elements.exportPngBtn.addEventListener('click', () => this.exportPNG());
                    this.elements.configFileInput.addEventListener('change', e => this.handleConfigFile(e));
                    this.elements.downloadModalCloseBtn.addEventListener('click', () => this.hideDownloadModal());
                    this.elements.cropperCancelBtn.addEventListener('click', () => this.hideCropper());
                    this.elements.cropperSaveBtn.addEventListener('click', () => this.saveCrop());
                    this.elements.addTextBlockBtn.addEventListener('click', () => this.addBlock('text'));
                    this.elements.addImageBlockBtn.addEventListener('click', () => this.addBlock('image'));
                    this.elements.addSeparatorBlockBtn.addEventListener('click', () => this.addBlock('separator'));
                    this.elements.addSpacerBlockBtn.addEventListener('click', () => this.addBlock('spacer'));
                    document.getElementById('avatar-upload').addEventListener('change', e => this.handleImageUpload(e, 'avatar'));
                    this.elements.pageBgUpload.addEventListener('change', e => this.handleImageUpload(e, 'pageBg'));
                    this.elements.clearPageBgBtn.addEventListener('click', () => {
                        this.updateState('pageStyles.pageBgImageDataUrl', null, true)
                        this.showToast('ËÉåÊôØÂõæÂ∑≤Ê∏ÖÈô§', 'info');
                    });
                    document.getElementById('load-local-fonts-btn').addEventListener('click', () => this.loadLocalFonts());
                    document.getElementById('upload-font-btn').addEventListener('click', () => document.getElementById('font-upload-input').click());
                    document.getElementById('font-upload-input').addEventListener('change', e => this.handleFontUpload(e));
                    document.querySelectorAll('input[name="crop-ratio"]').forEach(i => i.addEventListener('change', () => this.updateCropAspectRatio()));
                    
                    this.elements.fontSearchInput.addEventListener('input', e => this.populateFontList(e.target.value));

                    document.querySelectorAll('[data-preset]').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const presetName = e.currentTarget.dataset.preset;
                            if(this.presets[presetName]) {
                                this.applyPreset(this.presets[presetName]);
                            }
                        });
                    });
                    
                    document.querySelectorAll('.editor-section legend').forEach(legend => {
                        legend.addEventListener('click', () => {
                            const section = legend.closest('.editor-section');
                            section.classList.toggle('collapsed');
                        });
                    });

                    document.querySelectorAll('.tabs .tab-btn').forEach(button => {
                        button.addEventListener('click', (e) => {
                            const parent = e.target.closest('.modal-container, .section-content, .editor-card-content');
                            if (!parent) return;
                            parent.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');
                            parent.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                            const targetTab = parent.querySelector(`#${button.dataset.tab}`);
                            if (targetTab) targetTab.classList.add('active');
                            
                            const sectionEl = button.closest('.editor-section');
                            if (!sectionEl) return;
                            
                            const newMode = button.dataset.tab.includes('gradient') ? 'gradient' : 'solid';

                            if (sectionEl.id === 'global-card-styles-section') {
                                this.updateState('globalCardStyles.bgMode', newMode, true);
                            } else if (sectionEl.id === 'page-styles-section' || sectionEl.id === 'header-styles-section') {
                                if (button.dataset.tab.startsWith('page-bg')) {
                                    this.updateState('pageStyles.pageBgMode', newMode, true);
                                } else if (button.dataset.tab.startsWith('header-bg')) {
                                    this.updateState('pageStyles.headerBgMode', newMode, true);
                                }
                            }
                        });
                    });

                    this.elements.mobileEditToggle.addEventListener('click', () => this.toggleEditorDrawer());
                    this.elements.body.addEventListener('click', (e) => {
                        if (e.target === this.elements.body && this.elements.body.classList.contains('editor-open')) {
                            this.toggleEditorDrawer(false);
                        }
                    });
                    this.elements.showHelpBtn.addEventListener('click', () => this.elements.helpModal.classList.add('visible'));
                    this.elements.helpModalCloseBtn.addEventListener('click', () => this.elements.helpModal.classList.remove('visible'));
                    
                    this.elements.tutorialCloseBtn.addEventListener('click', () => {
                        this.elements.helpModal.classList.remove('visible');
                        localStorage.setItem('blokkoTutorialSeen', 'true');
                    });
                    this.elements.newbieTipCloseBtn.addEventListener('click', () => {
                        this.elements.newbieTipBar.style.display = 'none';
                        localStorage.setItem('blokkoFirstVisit', 'false');
                    });

                    this.elements.iconPickerCloseBtn.addEventListener('click', () => this.hideIconPicker());
                    this.elements.removeIconBtn.addEventListener('click', () => this.selectIcon(null));
                    this.elements.iconSearch.addEventListener('input', this.debounce((e) => this.renderIconGrid(e.target.value), 300));
                    this.elements.iconGrid.addEventListener('click', (e) => {
                        const item = e.target.closest('.icon-grid-item');
                        if (item) {
                            if (e.target.closest('.delete-custom-icon-btn')) {
                                this.deleteCustomIcon(item.dataset.iconName);
                            } else {
                                this.selectIcon(item.dataset.icon);
                            }
                        }
                    });
                    
                    this.elements.uploadIconBtn.addEventListener('click', () => this.elements.iconUploadInput.click());
                    this.elements.iconUploadInput.addEventListener('change', e => this.handleIconUpload(e));

                    this.elements.resetBtn.addEventListener('click', () => this.resetToDefault());
                    this.elements.lockModeToggle.addEventListener('click', () => this.toggleLockMode());
                    
                    this.elements.addNewTagBtn.addEventListener('click', () => this.addNewTag());
                    this.elements.newTagTextInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.addNewTag();
                        }
                    });
                    this.elements.tagManagerList.addEventListener('click', e => {
                        const tagItem = e.target.closest('.tag-manager-item');
                        if (!tagItem) return;
                        const tagId = tagItem.dataset.tagId;
                        if (e.target.closest('.tag-icon-btn')) {
                            this.showIconPicker('tag', tagId);
                        } else if (e.target.closest('.tag-delete-btn')) {
                            this.deleteTag(tagId);
                        }
                    });
                     this.elements.tagManagerList.addEventListener('input', e => {
                        const tagItem = e.target.closest('.tag-manager-item');
                        if (tagItem && e.target.classList.contains('tag-text-input')) {
                           this.updateTag(tagItem.dataset.tagId, 'text', e.target.value, false);
                        }
                    });
                    this.elements.tagManagerList.addEventListener('change', e => {
                        const tagItem = e.target.closest('.tag-manager-item');
                        if (tagItem && e.target.classList.contains('tag-text-input')) {
                           this.updateTag(tagItem.dataset.tagId, 'text', e.target.value, true);
                        }
                    });

                    this.elements.hdExportToggle.addEventListener('change', () => {
                        if (this.elements.hdExportToggle.checked) {
                            this.elements.customWidthToggle.checked = false;
                            this.elements.customWidthInput.disabled = true;
                        }
                        this.updateExportSizePreview();
                    });
                    this.elements.customWidthToggle.addEventListener('change', () => {
                        if (this.elements.customWidthToggle.checked) {
                            this.elements.hdExportToggle.checked = false;
                            this.elements.hdExportToggle.disabled = true;
                            this.elements.customWidthInput.disabled = false;
                        } else {
                            this.elements.hdExportToggle.disabled = false;
                            this.elements.customWidthInput.disabled = true;
                        }
                        this.updateExportSizePreview();
                    });
                    this.elements.customWidthInput.addEventListener('input', () => this.updateExportSizePreview());
                    
                    this.elements.exportRoundedCornersToggle.addEventListener('change', (e) => {
                        this.elements.exportCornerRadiusInput.disabled = !e.target.checked;
                    });

                    this.elements.showTexturePickerBtn.addEventListener('click', () => this.elements.texturePickerModal.classList.add('visible'));
                    this.elements.texturePickerCloseBtn.addEventListener('click', () => this.elements.texturePickerModal.classList.remove('visible'));
                    this.elements.removeTextureBtn.addEventListener('click', () => this.selectTexture(null));
                    this.elements.clearTextureBtn.addEventListener('click', () => this.selectTexture(null));
                    this.elements.textureGrid.addEventListener('click', e => {
                        const item = e.target.closest('.texture-grid-item');
                        if (item) this.selectTexture(item.dataset.textureName);
                    });
                },
                
                bindEditorEvents() {
                    this.elements.editorPanel.addEventListener('input', e => {
                        if (this.isRestoringState) return;
                        const target = e.target;
                        const stateKey = target.dataset.stateKey;

                        if (stateKey) {
                            const value = target.type === 'checkbox' ? target.checked : (target.type === 'number' || target.type === 'range') ? parseFloat(target.value) : target.value;
                            this.updateState(stateKey, value, false);
                            if (target.type === 'color' && target.nextElementSibling?.dataset.colorSyncKey === stateKey) {
                                target.nextElementSibling.value = value;
                            }
                            if (stateKey === 'globalCardStyles.radius') {
                                document.getElementById('gCardRadiusValue').textContent = target.value;
                            }
                            if (target.type === 'range' && stateKey.endsWith('Angle')) {
                                target.previousElementSibling.querySelector('.angle-value').textContent = value;
                            }
                            return;
                        }

                        const hexSyncKey = target.dataset.colorSyncKey;
                        if (hexSyncKey) {
                            if (/^#[0-9A-F]{6}$/i.test(target.value)) {
                                target.previousElementSibling.value = target.value;
                                this.updateState(hexSyncKey, target.value, false);
                            }
                        }

                        const blockEl = target.closest('.editor-block');
                        if (blockEl) {
                             const blockId = blockEl.dataset.blockId;
                             if(target.type === 'text' && target.classList.contains('editor-block-title-input')){
                                 this.updateBlockTitle(blockId, target.value, false);
                             } else if (target.dataset.settingKey) {
                                 const value = target.type === 'checkbox' ? target.checked : (target.type === 'range' || target.type === 'number') ? parseFloat(target.value) : target.value;
                                 this.updateBlockSettings(blockId, target.dataset.settingKey, value, false);
                             } else if (target.dataset.cardKey) {
                                 const cardEl = target.closest('.editor-card');
                                 const value = target.type === 'checkbox' ? target.checked : target.value;
                                 if (cardEl) this.updateCard(blockId, cardEl.dataset.cardId, target.dataset.cardKey, value, false);
                             }
                        }
                    });

                    this.elements.editorPanel.addEventListener('change', e => {
                        if (this.isRestoringState) return;
                        const target = e.target;
                        
                        if (target.dataset.stateKey || target.closest('.editor-block') || target.dataset.colorSyncKey) {
                            this.pushHistory();
                        }
                    });

                    this.elements.editorPanel.addEventListener('click', e => {
                        const target = e.target;
                        const resetKey = target.dataset.resetKey;
                        if(resetKey) {
                            let basePreset = this.presets.light;
                            const darkIndicatorColor = this.state.globalCardStyles.textColor;
                            if (darkIndicatorColor === this.presets.dark.gCardTextColor) basePreset = this.presets.dark;
                            else if (darkIndicatorColor === this.presets.mint.gCardTextColor) basePreset = this.presets.mint;
                            else if (darkIndicatorColor === this.presets.coffee.gCardTextColor) basePreset = this.presets.coffee;

                            const keyMap = {
                                nicknameColor: 'pNicknameColor', subtitleColor: 'pSubtitleColor', bioColor: 'pBioColor',
                                tagBgColor: 'pTagBgColor', tagTextColor: 'pTagTextColor', avatarBorderColor: '#ffffff'
                            };
                            
                            const [section, key] = resetKey.split('.');
                            const presetKey = keyMap[key];
                            
                            let valueToReset = basePreset[presetKey] || this.presets.light[presetKey];
                            
                            this.updateState(resetKey, valueToReset, true);
                            this.syncControl(resetKey);
                            this.showToast('È¢úËâ≤Â∑≤ÈáçÁΩÆ', 'info');
                            return;
                        }

                        if (target.type === 'radio' && target.dataset.stateKey) {
                            this.updateState(target.dataset.stateKey, target.value, true);
                        }

                        const blockEl = target.closest('.editor-block');
                        if (blockEl) {
                            const blockId = blockEl.dataset.blockId;
                            if (target.closest('.block-delete-btn')) { if (window.confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Âå∫ÂùóÂêóÔºü')) this.deleteBlock(blockId); }
                            else if (target.closest('.block-up-btn')) this.moveBlockUp(blockId);
                            else if (target.closest('.block-down-btn')) this.moveBlockDown(blockId);
                            else if (target.closest('.add-card-btn')) this.addCard(blockId);
                            else if (target.closest('.add-image-btn')) this.addImageCard(blockId);
                            else if (target.closest('.card-delete-btn')) this.deleteCard(blockId, target.closest('.editor-card').dataset.cardId);
                            else if (target.closest('.card-clear-bg-btn')) {
                                this.updateCard(blockId, target.closest('.editor-card').dataset.cardId, 'bgImageDataUrl', null, true);
                                this.showToast('Âç°ÁâáËÉåÊôØÂõæÂ∑≤Ê∏ÖÈô§', 'info');
                            }
                            else if (target.closest('.crop-image-btn')) this.cropImage(blockId, target.closest('.editor-card').dataset.cardId);
                            else if (target.closest('.select-icon-btn')) { 
                                const cardId = target.closest('.editor-card').dataset.cardId;
                                this.showIconPicker('card', blockId, cardId);
                            }
                        }
                    });

                    this.elements.editorPanel.addEventListener('change', e => {
                       const target = e.target;
                       if (target.classList.contains('card-bg-upload')) {
                           const cardEl = target.closest('.editor-card');
                           const blockEl = target.closest('.editor-block');
                           if(cardEl && blockEl) {
                               this.handleCardBgUpload(e, blockEl.dataset.blockId, cardEl.dataset.cardId);
                           }
                       } else if (target.classList.contains('image-upload-input')) {
                            const blockEl = target.closest('.editor-block');
                            if (blockEl) {
                                this.handleImageGalleryUpload(blockEl.dataset.blockId, e.target.files);
                                e.target.value = '';
                            }
                       } else if (target.type === 'checkbox' && target.dataset.settingKey) {
                            const blockEl = target.closest('.editor-block');
                            if(blockEl){
                                this.updateBlockSettings(blockEl.dataset.blockId, target.dataset.settingKey, target.checked, true);
                                this.renderEditorBlockById(blockEl.dataset.blockId);
                            }
                       } else if (target.type === 'radio' && target.dataset.settingKey) {
                            const blockEl = target.closest('.editor-block');
                            if(blockEl) {
                                this.updateBlockSettings(blockEl.dataset.blockId, target.dataset.settingKey, target.value, true);
                                this.renderEditorBlockById(blockEl.dataset.blockId); 
                            }
                       } else if (target.type === 'checkbox' && target.dataset.cardKey) {
                            const blockEl = target.closest('.editor-block');
                            const cardEl = target.closest('.editor-card');
                            if (blockEl && cardEl) {
                                this.updateCard(blockEl.dataset.blockId, cardEl.dataset.cardId, target.dataset.cardKey, target.checked, true);
                                this.renderEditorCardById(blockEl.dataset.blockId, cardEl.dataset.cardId);
                            }
                       } else if (target.type === 'text' && target.classList.contains('editor-block-title-input')) {
                            const blockEl = target.closest('.editor-block');
                            if(blockEl) this.updateBlockTitle(blockEl.dataset.blockId, target.value, true);
                       }
                    });
                },

                bindPreviewEvents(){
                     this.elements.previewPanel.addEventListener('click', e => {
                        if (this.isEditingText) return;
                        
                        const blockWrapper = e.target.closest('.preview-block-wrapper');
                        const cardWrapper = e.target.closest('.preview-card, figure');
                        
                        const blockId = blockWrapper ? blockWrapper.dataset.blockId : null;
                        const cardId = cardWrapper ? cardWrapper.dataset.cardId : null;

                        if (blockId) {
                            this.focusOnEditorElement(blockId, cardId);
                        }
                     });

                     this.elements.previewWrapper.addEventListener('dblclick', e => {
                        if (this.elements.previewBlocksContainer.classList.contains('locked-mode')) return;
                        const target = e.target.closest('[data-state-key], [data-card-key], [data-tag-id]');
                        if (target && !this.isEditingText) {
                            const blockWrapper = target.closest('.preview-block-wrapper');
                            const cardWrapper = target.closest('.preview-card, figure');
                            const blockId = blockWrapper ? blockWrapper.dataset.blockId : null;
                            const cardId = cardWrapper ? cardWrapper.dataset.cardId : null;
                            if (blockId) {
                                this.focusOnEditorElement(blockId, cardId);
                            }

                            this.isEditingText = true;
                            target.contentEditable = true;
                            target.focus();
                            document.execCommand('selectAll', false, null);

                            const handleEditEnd = () => {
                                target.contentEditable = false;
                                this.isEditingText = false;
                                target.removeEventListener('blur', handleEditEnd);
                                target.removeEventListener('keydown', handleKeydown);

                                const value = target.innerText;
                                const stateKey = target.dataset.stateKey;
                                const cardKey = target.dataset.cardKey;
                                const tagId = target.dataset.tagId;

                                if (stateKey) {
                                    this.updateState(stateKey, value, true);
                                } else if (cardKey) {
                                    const cardEl = target.closest('.preview-card, figure');
                                    const blockEl = target.closest('.preview-block-wrapper');
                                    if (cardEl && blockEl) {
                                        const blockId = blockEl.dataset.blockId;
                                        this.updateCard(blockId, cardEl.dataset.cardId, cardKey, value, true);
                                        this.renderEditorCardById(blockId, cardEl.dataset.cardId);
                                        if (this.masonryInstances[blockId]) {
                                            this.masonryInstances[blockId].layout();
                                        }
                                    }
                                } else if(tagId){
                                    const newText = value.trim();
                                    if (newText) {
                                        this.updateTag(tagId, 'text', newText, true);
                                    } else {
                                        this.deleteTag(tagId);
                                    }
                                    this.renderTagManager();
                                }
                            };
                            
                            const handleKeydown = (ev) => {
                                if (ev.key === 'Enter' && !ev.shiftKey) { // Allow Shift+Enter for new lines
                                    ev.preventDefault();
                                    target.blur();
                                }
                            };

                            target.addEventListener('blur', handleEditEnd);
                            target.addEventListener('keydown', handleKeydown);
                        }
                    });
                    
                    this.elements.previewWrapper.addEventListener('input', e => {
                        const target = e.target;
                        if (target.contentEditable === 'true') {
                            const stateKey = target.dataset.stateKey;
                            const cardKey = target.dataset.cardKey;
                            const value = target.innerText;

                            const updateStateObject = (path, val) => {
                                let obj = this.state;
                                const keys = path.split('.');
                                for (let i = 0; i < keys.length - 1; i++) { obj = obj?.[keys[i]]; }
                                if(obj) obj[keys[keys.length - 1]] = val;
                            };

                            if (stateKey) {
                                updateStateObject(stateKey, value);
                                this.syncControl(stateKey);
                            } else if (cardKey) {
                                const cardEl = target.closest('.preview-card, figure');
                                const blockEl = target.closest('.preview-block-wrapper');
                                if (cardEl && blockEl) {
                                    const blockId = blockEl.dataset.blockId;
                                    const cardId = cardEl.dataset.cardId;
                                    const blockIndex = this.findBlockIndex(blockId);
                                    if (blockIndex > -1) {
                                        const cardIndex = this.state.blocks[blockIndex].cards.findIndex(c => c.id === cardId);
                                        if (cardIndex > -1) {
                                            updateStateObject(`blocks.${blockIndex}.cards.${cardIndex}.${cardKey}`, value);
                                            const editorCard = document.querySelector(`.editor-card[data-card-id="${cardId}"]`);
                                            if (editorCard) {
                                                const input = editorCard.querySelector(`[data-card-key="${cardKey}"]`);
                                                if (input) input.value = value;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                initResizer() {
                     const resizer = this.elements.resizer;
                        const editorPanel = this.elements.editorPanel;
                        let isResizing = false;
                    
                        resizer.addEventListener('mousedown', (e) => {
                            isResizing = true;
                            document.body.style.cursor = 'col-resize';
                            document.body.style.userSelect = 'none';
                    
                            document.addEventListener('mousemove', handleMouseMove);
                            document.addEventListener('mouseup', stopResize);
                        });
                    
                        const handleMouseMove = (e) => {
                            if (!isResizing) return;
                            const newWidth = e.clientX;
                            if (newWidth > 450 && newWidth < window.innerWidth * 0.7) {
                                editorPanel.style.width = `${newWidth}px`;
                                this.updateExportSizePreview();
                            }
                        };
                    
                        const stopResize = () => {
                            isResizing = false;
                            document.body.style.cursor = 'default';
                            document.body.style.userSelect = 'auto';
                            document.removeEventListener('mousemove', handleMouseMove);
                            document.removeEventListener('mouseup', stopResize);
                            this.updateExportSizePreview();
                        };
                },

                renderAll(isInitial = false) {
                    this.updateGlobalCardStyleVars();
                    this.renderPersonalInfo();
                    this.renderPageStyles();
                    this.renderEditorBlocks(isInitial);
                    this.renderPreviewBlocks();
                    this.renderTagManager();
                },
                
                renderPersonalInfo() {
                    const info = this.state.personalInfo;
                    this.elements.previewAvatar.src = info.avatarDataUrl;
                    this.elements.previewNickname.textContent = info.nickname;
                    this.elements.previewSubtitle.textContent = info.subtitle;
                    this.elements.previewBio.textContent = info.bio;
                    
                    this.elements.previewNickname.style.color = info.nicknameColor;
                    this.elements.previewSubtitle.style.color = info.subtitleColor;
                    this.elements.previewBio.style.color = info.bioColor;

                    this.elements.previewAvatar.style.borderRadius = info.avatarShape;
                    this.elements.previewAvatar.style.borderWidth = `${info.avatarBorderSize}px`;
                    this.elements.previewAvatar.style.borderColor = info.avatarBorderColor;
                    
                    this.elements.previewTagsContainer.innerHTML = (info.tags || [])
                        .map(tag => {
                            const iconHTML = tag.icon ? `<span class="iconify" data-icon="${tag.icon}"></span>` : '';
                            return `<span class="tag-pill" data-tag-id="${tag.id}" style="background-color:${info.tagBgColor}; color:${info.tagTextColor};">${iconHTML}<span>${this.escapeHTML(tag.text)}</span></span>`;
                        }).join('');
                },
                
                renderPageStyles() {
                    const styles = this.state.pageStyles;
                    const wrapper = this.elements.previewWrapper;
                    
                    let bgLayers = [];
                    let bgSizes = [];
                    let bgPositions = [];
                    let bgColor = 'transparent';

                    if (styles.pageBgPattern) {
                        const pattern = HeroPatterns.find(p => p.name === styles.pageBgPattern);
                        if(pattern) {
                            const coloredSvg = pattern.svg(styles.pageBgPatternColor, styles.pageBgPatternOpacity);
                            const base64Svg = btoa(unescape(encodeURIComponent(coloredSvg)));
                            bgLayers.push(`url("data:image/svg+xml;base64,${base64Svg}")`);
                            bgSizes.push(`${styles.pageBgPatternDensity}px`);
                            bgPositions.push('center');
                        }
                    }

                    if (styles.pageBgImageDataUrl) {
                        const overlayOpacity = parseFloat(styles.pageOverlayOpacity);
                        if (overlayOpacity > 0) {
                            const finalOverlayColor = this.hexToRgba(styles.pageOverlayColor, overlayOpacity);
                            bgLayers.push(`linear-gradient(${finalOverlayColor}, ${finalOverlayColor})`);
                            bgSizes.push('cover');
                            bgPositions.push('center');
                        }
                    }
                    
                    if (styles.pageBgImageDataUrl) {
                        bgLayers.push(`url(${styles.pageBgImageDataUrl})`);
                        bgSizes.push('cover');
                        bgPositions.push('center');
                    }
                    
                    if (styles.pageBgMode === 'gradient') {
                        bgLayers.push(`linear-gradient(${styles.pageBgGradientAngle}deg, ${styles.pageBgGradientStart}, ${styles.pageBgGradientEnd})`);
                        bgSizes.push('cover');
                        bgPositions.push('center');
                    } else {
                        bgColor = styles.pageBgSolidColor;
                    }

                    wrapper.style.backgroundColor = bgColor;
                    wrapper.style.backgroundImage = bgLayers.join(', ');
                    wrapper.style.backgroundSize = bgSizes.join(', ');
                    wrapper.style.backgroundPosition = bgPositions.join(', ');

                    if (styles.headerBgMode === 'gradient') {
                        const gradient = `linear-gradient(${styles.headerBgGradientAngle}deg, ${this.hexToRgba(styles.headerBgGradientStart, styles.headerOpacity)}, ${this.hexToRgba(styles.headerBgGradientEnd, styles.headerOpacity)})`;
                        this.elements.previewHeader.style.background = gradient;
                    } else {
                        this.elements.previewHeader.style.background = this.hexToRgba(styles.headerBgColor, styles.headerOpacity);
                    }
                    this.elements.previewHeader.style.color = styles.headerTextColor;

                    this.elements.previewNickname.style.color = this.state.personalInfo.nicknameColor;
                    this.elements.previewSubtitle.style.color = this.state.personalInfo.subtitleColor;
                    this.elements.previewBio.style.color = this.state.personalInfo.bioColor;
                    
                    this.elements.pageImageControls.style.display = styles.pageBgImageDataUrl ? 'block' : 'none';
                    this.elements.pageTextureControls.style.display = styles.pageBgPattern ? 'block' : 'none';
                },

                renderEditorBlocks(isInitial = false) {
                    const list = this.elements.editorBlocksList;
                    list.innerHTML = this.state.blocks.length ? this.state.blocks.map(b => this.createEditorBlockHTML(b, isInitial)).join('') : '<div class="empty-placeholder">ÊöÇÊó†Âå∫Âùó</div>';
                    this.state.blocks.forEach(block => {
                        const blockEl = list.querySelector(`.editor-block[data-block-id="${block.id}"]`);
                        if (!blockEl) return;
                        if (block.type === 'text') {
                            this.renderEditorCards(block.id, blockEl.querySelector('.card-editors-list'));
                        } else if (block.type === 'image') {
                            this.renderEditorImageCards(block.id, blockEl.querySelector('.image-card-editors-list'));
                        }
                    });
                },

                renderPreviewBlocks() {
                    this.elements.previewBlocksContainer.innerHTML = this.state.blocks.length ? this.state.blocks.map(b => `<div class="preview-block-wrapper" data-block-id="${b.id}">${this.createPreviewBlockHTML(b)}</div>`).join('') : '<div class="empty-placeholder">(È¢ÑËßàÂå∫) Êó†Âå∫Âùó</div>';
                    this.state.blocks.forEach(b => this.initMasonryForBlock(b.id));
                },

                createEditorBlockHTML(block, isInitial = false) {
                    let content = '';
                    const upDownBtns = `<div class="up-down-btns"><button class="btn btn-default block-up-btn">‚Üë</button><button class="btn btn-default block-down-btn">‚Üì</button></div>`;
                    
                    const masonryCheckboxHTML = `
                        <div class="masonry-toggle-container" style="${['dual', 'triple'].includes(block.settings.layout) ? 'display: block;' : 'display: none;'}">
                            <div class="checkbox-group" style="margin-top: 10px;">
                                <label><input type="checkbox" data-setting-key="masonryEnabled" ${block.settings.masonryEnabled ? 'checked' : ''}> ÂêØÁî®ÁÄëÂ∏ÉÊµÅ</label>
                            </div>
                        </div>`;
                    const layoutRadiosHTML = `
                        <div class="radio-group">
                            <label><input type="radio" data-setting-key="layout" name="block-layout-${block.id}" value="single" ${block.settings.layout === 'single' ? 'checked' : ''}> ÂçïÊéí</label>
                            <label><input type="radio" data-setting-key="layout" name="block-layout-${block.id}" value="dual" ${block.settings.layout === 'dual' ? 'checked' : ''}> ÂèåÊéí</label>
                            <label><input type="radio" data-setting-key="layout" name="block-layout-${block.id}" value="triple" ${block.settings.layout === 'triple' ? 'checked' : ''}> ‰∏âÊéí</label>
                        </div>`;

                    if (block.type === 'text') {
                        content = `<div class="form-group"><label>Â∏ÉÂ±Ä:</label>${layoutRadiosHTML}${masonryCheckboxHTML}</div>
                                   <div class="card-editors-list"></div><button class="btn btn-default add-card-btn" style="margin-top: 15px;">‚ûï Ê∑ªÂä†Âç°Áâá</button>`;
                    } else if (block.type === 'image') {
                        content = `<div class="form-group"><label>Â∏ÉÂ±Ä:</label>${layoutRadiosHTML}${masonryCheckboxHTML}</div>
                                   <div class="form-group"><label>ÊñáÂ≠óÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-setting-key="textColor" value="${block.settings.textColor || ''}"><input type="text" class="color-hex-input" data-color-sync-key="textColor" value="${block.settings.textColor || ''}" placeholder="ÂÖ®Â±ÄÈªòËÆ§"></div></div>
                                   <div class="image-card-editors-list"></div><button class="btn btn-default add-image-btn" style="margin-top: 15px;">‚ûï Ê∑ªÂä†ÂõæÁâá</button>
                                   <input type="file" class="image-upload-input" multiple accept="image/*" style="display: none;">`;
                    } else if (block.type === 'separator') {
                        const s = block.settings;
                        content = `<div class="form-group"><label>Ê†∑Âºè:</label><div class="radio-group"><label><input type="radio" name="sep-style-${block.id}" data-setting-key="style" value="solid" ${s.style==='solid'?'checked':''}>ÂÆûÁ∫ø</label><label><input type="radio" name="sep-style-${block.id}" data-setting-key="style" value="dashed" ${s.style==='dashed'?'checked':''}>ËôöÁ∫ø</label></div></div><div class="color-control-row"><div class="color-control-group"><label>È¢úËâ≤:</label><div class="input-group"><input type="color" data-setting-key="color" value="${s.color}"><input type="text" class="color-hex-input" data-color-sync-key="color" value="${s.color}"></div></div><div class="color-control-group"><label>Á≤óÁªÜ(px):</label><input type="range" data-setting-key="thickness" min="1" max="10" value="${s.thickness}"></div></div><div class="form-group"><label>ÂûÇÁõ¥Èó¥Ë∑ù(px):</label><input type="range" data-setting-key="margin" min="0" max="50" value="${s.margin}"></div>`;
                    } else if (block.type === 'spacer') {
                        const s = block.settings;
                        content = `<div class="form-group"><label>È´òÂ∫¶ (px): <span class="spacer-height-value">${s.height}</span></label><input type="range" data-setting-key="height" min="1" max="200" value="${s.height}"></div>`;
                    }

                    const collapsedClass = isInitial ? 'collapsed' : '';
                    return `<div class="editor-block ${collapsedClass}" data-block-id="${block.id}"><div class="editor-block-header"><span class="block-drag-handle">‚ò∞</span><input type="text" class="editor-block-title-input" value="${this.escapeHTML(block.title || '')}" placeholder="Âå∫ÂùóÊ†áÈ¢ò (ÂèØÁºñËæë)"><div class="block-actions">${upDownBtns}<button class="btn btn-danger btn-small block-delete-btn">Âà†Èô§</button></div></div><div class="editor-block-content">${content}</div></div>`;
                },

                createPreviewBlockHTML(block) {
                    let layoutClass = 'preview-cards-single';
                    if (block.settings.layout === 'dual') layoutClass = 'preview-cards-dual';
                    if (block.settings.layout === 'triple') layoutClass = 'preview-cards-triple';
                    
                    let cardsHTML = '';
                    if (block.type === 'text') {
                        cardsHTML = (block.cards || []).map(card => this.createPreviewCardHTML(card)).join('');
                    } else if (block.type === 'image') {
                        cardsHTML = (block.cards || []).map(card => this.createPreviewImageCardHTML(card, block.settings)).join('');
                    }

                    if (block.type === 'text' || block.type === 'image') {
                        return `<div class="preview-cards-container ${layoutClass}">${cardsHTML}</div>`;
                    } else if (block.type === 'separator') {
                         const s = block.settings;
                         return `<div class="separator-preview" style="margin: ${s.margin}px 0;"><div class="separator-preview-line" style="border-top: ${s.thickness}px ${s.style} ${s.color};"></div></div>`;
                    } else if (block.type === 'spacer') {
                        return `<div class="spacer-preview" style="height: ${block.settings.height}px;"></div>`;
                    }
                    return '';
                },

                createPreviewCardHTML(card) {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'preview-card';
                    cardEl.dataset.cardId = card.id;
                    cardEl.style.setProperty('--card-transition-name', `card-${card.id}`);
                    const iconHTML = card.icon ? `<span class="iconify" data-icon="${card.icon}"></span>` : '';
                    cardEl.innerHTML = `<div class="preview-card-inner">
                            <h3 class="preview-card-title" data-card-key="title">${iconHTML}${this.escapeHTML(card.title || '')}</h3>
                            <p class="preview-card-content" data-card-key="content">${this.escapeHTML(card.content || '')}</p>
                        </div>`;
                    this.applyCardStyles(cardEl, card);
                    return cardEl.outerHTML;
                },

                createPreviewImageCardHTML(card, blockSettings = {}) {
                    const textColorStyle = blockSettings.textColor ? `style="color: ${blockSettings.textColor};"` : '';
                    const figcaptionContent = (card.title || card.description) ? 
                        `<figcaption ${textColorStyle}>
                            ${card.title ? `<strong data-card-key="title">${this.escapeHTML(card.title)}</strong>` : ''}
                            <span data-card-key="description">${this.escapeHTML(card.description || '')}</span>
                        </figcaption>` 
                        : '';
                   return `<figure data-card-id="${card.id}"><img src="${card.url}" alt="${this.escapeHTML(card.title || '')}" loading="lazy">${figcaptionContent}</figure>`;
                },

                createEditorCardHTML(card) {
                    const s = (val, def) => val ?? def;
                    const followGlobalOpacity = card.followGlobalOpacity !== false;
                    const iconHTML = card.icon ? `<span class="iconify" data-icon="${card.icon}" style="font-size: 1.2em; vertical-align: middle; margin-right: 5px;"></span> ${card.icon}` : 'ÈÄâÊã©ÂõæÊ†á';
                    return `<span class="card-drag-handle">‚ò∞</span><div class="editor-card-header"><button class="btn btn-danger btn-small card-delete-btn">Âà†</button></div>
                        <div class="editor-card-content">
                            <div class="form-group"><label>Ê†áÈ¢ò:</label><div class="input-group"><input type="text" data-card-key="title" value="${this.escapeHTML(s(card.title, ''))}" style="border-right: none;"><button class="btn btn-default select-icon-btn" style="width: auto; flex-shrink: 0; border-radius: 0 6px 6px 0; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${iconHTML}</button></div></div>
                            <div class="form-group"><label>ÂÜÖÂÆπ:</label><textarea data-card-key="content" rows="4">${this.escapeHTML(s(card.content, ''))}</textarea></div>
                            <hr class="separator"><div class="card-style-grid">
                                <div class="form-group"><label>Â≠óÂè∑:</label><select data-card-key="fontSize"><option value="" ${s(card.fontSize, '') === '' ? 'selected' : ''}>ÈªòËÆ§</option><option value="0.9em" ${card.fontSize === '0.9em' ? 'selected' : ''}>Â∞è</option><option value="1em" ${card.fontSize === '1em' ? 'selected' : ''}>‰∏≠</option><option value="1.1em" ${card.fontSize === '1.1em' ? 'selected' : ''}>Â§ß</option></select></div>
                                <div class="form-group"><label>ÂØπÈΩê:</label><div class="radio-group"><label><input type="radio" name="card-${card.id}-align" value="" data-card-key="textAlign" ${s(card.textAlign, '') === '' ? 'checked':''}>ÈªòËÆ§</label><label><input type="radio" name="card-${card.id}-align" value="left" data-card-key="textAlign" ${card.textAlign === 'left' ?'checked':''}>Â∑¶</label><label><input type="radio" name="card-${card.id}-align" value="center" data-card-key="textAlign" ${card.textAlign === 'center' ?'checked':''}>‰∏≠</label><label><input type="radio" name="card-${card.id}-align" value="right" data-card-key="textAlign" ${card.textAlign === 'right' ?'checked':''}>Âè≥</label></div></div>
                                <div class="form-group"><label>Â≠óÈáç:</label><select data-card-key="fontWeight"><option value="" ${s(card.fontWeight, '')===''?'selected':''}>ÈªòËÆ§</option><option value="normal" ${card.fontWeight==='normal'?'selected':''}>Â∏∏ËßÑ</option><option value="bold" ${card.fontWeight==='bold'?'selected':''}>Á≤ó‰Ωì</option></select></div>
                                <div class="form-group checkbox-group"><label><input type="checkbox" data-card-key="textShadowEnabled" ${s(card.textShadowEnabled, false) ? 'checked':''}>ÊñáÂ≠óÈò¥ÂΩ±</label></div>
                            </div>
                            <hr class="separator"><div class="form-group"><label>ËÉåÊôØÂõæ:</label><div class="input-group simple"><input type="file" class="card-bg-upload" accept="image/*"><button class="btn btn-default btn-small card-clear-bg-btn">Ê∏ÖÈô§</button></div></div>
                            <div class="card-overlay-controls" style="${card.bgImageDataUrl?'':'display:none;'}"><label>ÂõæÁâáËíôÁâà:</label><div class="color-control-row"><div class="color-control-group"><label>È¢úËâ≤:</label><div class="input-group"><input type="color" data-card-key="overlayColor" value="${s(card.overlayColor, '#ffffff')}"><input class="color-hex-input" type="text" data-card-key="overlayColor" value="${s(card.overlayColor, '#ffffff')}"></div></div><div class="color-control-group"><label>‰∏çÈÄèÊòéÂ∫¶:</label><input type="range" data-card-key="overlayOpacity" min="0" max="1" step="0.05" value="${s(card.overlayOpacity,0.5)}"></div></div></div>
                            <hr class="separator">
                            <div class="color-control-row">
                                <div class="color-control-group"><label>ËÉåÊôØËâ≤:</label><div class="input-group"><input type="color" data-card-key="bgColor" value="${s(card.bgColor, '')}"><input class="color-hex-input" type="text" data-card-key="bgColor" value="${s(card.bgColor, '')}" placeholder="ÂÖ®Â±ÄÈªòËÆ§"></div></div>
                                <div class="color-control-group"><label>ÊñáÂ≠óÈ¢úËâ≤:</label><div class="input-group"><input type="color" data-card-key="textColor" value="${s(card.textColor, '')}"><input class="color-hex-input" type="text" data-card-key="textColor" value="${s(card.textColor, '')}" placeholder="ÂÖ®Â±ÄÈªòËÆ§"></div></div>
                            </div>
                            <div class="form-group checkbox-group"><label><input type="checkbox" data-card-key="followGlobalOpacity" ${followGlobalOpacity ? 'checked' : ''}>Ë∑üÈöèÂÖ®Â±Ä‰∏çÈÄèÊòéÂ∫¶</label></div>
                            <div class="form-group" style="${followGlobalOpacity ? 'display:none;' : 'display:block;'}"><label>Áã¨Á´ã‰∏çÈÄèÊòéÂ∫¶:</label><input type="range" data-card-key="opacity" min="0" max="1" step="0.05" value="${s(card.opacity, 1.0)}"></div>
                        </div>`;
                },

                createEditorImageCardHTML(card) {
                    return `<span class="card-drag-handle">‚ò∞</span>
                        <div class="editor-card-header"><button class="btn btn-danger btn-small card-delete-btn">Âà†</button></div>
                        <div class="editor-card-content">
                            <div class="image-card-editor-content">
                                <div class="image-card-editor-thumb">
                                    <div class="thumbnail-wrapper">
                                        <img src="${card.url}" loading="lazy">
                                        <div class="thumbnail-actions">
                                            <button class="btn btn-icon crop-image-btn" title="Ë£ÅÂâ™"><span class="iconify" data-icon="mdi:crop"></span></button>
                                        </div>
                                    </div>
                                </div>
                                <div class="image-card-editor-fields">
                                    <div class="form-group"><label>Ê†áÈ¢ò:</label><input type="text" data-card-key="title" value="${this.escapeHTML(card.title || '')}"></div>
                                    <div class="form-group"><label>ÊèèËø∞:</label><textarea data-card-key="description" rows="2">${this.escapeHTML(card.description || '')}</textarea></div>
                                </div>
                            </div>
                        </div>`;
                },
                
                applyCardStyles(cardEl, cardData) {
                    const g = this.state.globalCardStyles;
                    const use = (key, val) => (val === undefined || val === null || val === '') ? g[key] : val;
                    
                    const followGlobalOpacity = cardData.followGlobalOpacity !== false;
                    const finalOpacity = followGlobalOpacity ? g.opacity : (cardData.opacity ?? 1.0);
                    
                    const innerEl = cardEl.querySelector('.preview-card-inner');
                    if (!innerEl) return;
                    
                    if (parseFloat(finalOpacity) === 0) {
                        innerEl.style.setProperty('--card-bg-final', 'transparent');
                        innerEl.style.boxShadow = 'none';
                        innerEl.style.border = 'none';
                    } else {
                        const finalTextColor = cardData.textColor || g.textColor;
                        let finalBg;
                        if (cardData.bgImageDataUrl) {
                            finalBg = `url(${cardData.bgImageDataUrl})`;
                        } else if (cardData.bgColor) {
                            finalBg = this.hexToRgba(cardData.bgColor, finalOpacity);
                        } else {
                            if (g.bgMode === 'gradient') {
                                finalBg = `linear-gradient(${g.bgGradientAngle}deg, ${this.hexToRgba(g.bgGradientStart, finalOpacity)}, ${this.hexToRgba(g.bgGradientEnd, finalOpacity)})`;
                            } else {
                                finalBg = this.hexToRgba(g.bgColor, finalOpacity);
                            }
                        }
                        
                        innerEl.style.setProperty('--card-bg-final', finalBg);
                        innerEl.style.setProperty('--card-text-color', finalTextColor);
                        innerEl.style.textAlign = use('textAlign', cardData.textAlign);
                        innerEl.style.fontSize = cardData.fontSize || 'inherit'; 
                        innerEl.style.setProperty('--card-font-weight', cardData.fontWeight || 'normal');
                        innerEl.style.setProperty('--active-card-text-shadow', cardData.textShadowEnabled ? 'var(--preset-text-shadow)' : 'none');
                        
                        innerEl.style.setProperty('--card-overlay-color', cardData.overlayColor || '#FFF');
                        const overlayOpacity = cardData.bgImageDataUrl ? (cardData.overlayOpacity ?? 0.5) : 0;
                        innerEl.style.setProperty('--card-overlay-opacity', parseFloat(overlayOpacity) > 0 ? overlayOpacity : 0);
                        
                        innerEl.style.boxShadow = 'var(--active-card-shadow)';
                        innerEl.style.border = 'var(--active-card-border)';
                    }
                },

                updateState(keyPath, value, pushHistory = true) {
                    if (pushHistory && !this.isRestoringState) this.pushHistory();
                    let obj = this.state;
                    const keys = keyPath.split('.');
                    for (let i = 0; i < keys.length - 1; i++) { obj = obj?.[keys[i]]; }
                    if(obj) obj[keys[keys.length - 1]] = value;
                    this.debouncedSaveToLocal();
                    this.triggerRender(keyPath);
                },

                triggerRender(keyPath) {
                    const parts = keyPath.split('.');
                    const mainKey = parts[0];

                    if (mainKey === 'personalInfo' || mainKey === 'customIcons') {
                        if (parts[1] === 'tags') {
                            this.renderPersonalInfo();
                            this.renderTagManager();
                        } else {
                            this.renderPersonalInfo();
                        }
                    } else if (mainKey === 'pageStyles') {
                        this.renderPageStyles();
                    } else if (mainKey === 'globalCardStyles') {
                        this.updateGlobalCardStyleVars();
                        this.renderPreviewBlocks();
                    } else if (mainKey === 'blocks') {
                        const blockIndex = parseInt(parts[1]);
                        const block = this.state.blocks[blockIndex];
                        if (!block) return;
                        const blockId = block.id;

                        this.renderPreviewBlockById(blockId);
                        
                        if (parts[2] === 'cards') {
                            const cardIndex = parseInt(parts[3]);
                            const cardId = this.state.blocks[blockIndex]?.cards[cardIndex]?.id;
                            if (cardId) {
                                const cardProp = parts[4];
                                if (block.type === 'text' && (cardProp === 'icon' || cardProp === 'followGlobalOpacity' || cardProp === 'bgImageDataUrl')) {
                                    this.renderEditorCardById(blockId, cardId);
                                }
                            }
                        }
                    }
                },

                addCard(blockId) {
                    const block = this.findBlock(blockId);
                    if (!block || block.type !== 'text') return;
                    
                    const newCard = { id: this.generateId('c'), icon: '', title: `Êñ∞Âç°Áâá`, content: 'ÂèåÂáªÈ¢ÑËßàÂå∫ÂèØÁõ¥Êé•ÁºñËæëÂÜÖÂÆπ', opacity: 1.0, followGlobalOpacity: true };
                    
                    this.pushHistory();
                    block.cards.push(newCard);
                    this.debouncedSaveToLocal();
                    
                    this.renderEditorBlockById(blockId);
                    
                    const container = this.elements.previewBlocksContainer.querySelector(`[data-block-id="${blockId}"] > div`);
                    if (!container) {
                        this.renderPreviewBlockById(blockId);
                        return;
                    };

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = this.createPreviewCardHTML(newCard);
                    const newCardEl = tempDiv.firstChild;
                    container.appendChild(newCardEl);

                    const masonry = this.masonryInstances[blockId];
                    if (masonry) {
                        masonry.appended(newCardEl);
                        masonry.layout();
                    }

                    newCardEl.classList.add('adding');
                    newCardEl.addEventListener('animationend', () => {
                        newCardEl.classList.remove('adding');
                    }, { once: true });
                    
                    const newCardEditorEl = this.elements.editorBlocksList.querySelector(`.editor-card[data-card-id="${newCard.id}"]`);
                    if (newCardEditorEl) {
                        newCardEditorEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                },

                addImageCard(blockId) {
                    const blockEl = document.querySelector(`.editor-block[data-block-id="${blockId}"]`);
                    if (blockEl) {
                        blockEl.querySelector('.image-upload-input').click();
                    }
                },

                deleteCard(blockId, cardId) {
                    const block = this.findBlock(blockId);
                    if (!block) return;
                    
                    const cardEl = this.elements.previewBlocksContainer.querySelector(`[data-card-id="${cardId}"]`);
                    
                    const doDelete = () => {
                        this.pushHistory();
                        block.cards = block.cards.filter(c => c.id !== cardId);
                        this.debouncedSaveToLocal();
                        this.renderEditorBlockById(blockId);
                        
                        const masonry = this.masonryInstances[blockId];
                        if (!masonry) {
                            this.renderPreviewBlockById(blockId);
                        } else {
                            masonry.layout();
                        }

                        this.showToast('Âç°ÁâáÂ∑≤Âà†Èô§', 'info');
                    };

                    if (cardEl) {
                        const masonry = this.masonryInstances[blockId];
                        if (masonry) {
                            masonry.remove(cardEl);
                        }

                        cardEl.classList.add('removing');
                        cardEl.addEventListener('animationend', () => {
                            if (!masonry) {
                                cardEl.remove();
                            }
                            doDelete();
                        }, { once: true });

                    } else {
                        doDelete();
                    }
                },

                loadFromLocal() { 
                    const json = localStorage.getItem('blokkoState'); 
                    if (!json) {
                        // Don't show toast for first-time users, tutorial will handle it.
                        if (localStorage.getItem('blokkoFirstVisit') !== null) {
                            this.showToast('Ê¨¢Ëøé‰ΩøÁî® BlokkoÔºÅÂ∑≤‰∏∫ÊÇ®Âä†ËΩΩÈªòËÆ§Ê®°Êùø„ÄÇ', 'info');
                        }
                        return;
                    };
                    try { 
                        let saved = JSON.parse(json);
                        if (saved && saved.personalInfo) {
                            if (typeof saved.personalInfo.tags === 'string') {
                                saved.personalInfo.tags = saved.personalInfo.tags.split(/[,Ôºå„ÄÅ]/).map(t => t.trim()).filter(Boolean)
                                    .map(text => ({ id: this.generateId('t'), icon: null, text }));
                                this.showToast('ÊóßÁâàÈÖçÁΩÆÂ∑≤Âä†ËΩΩÔºåÊ†áÁ≠æÊï∞ÊçÆÂ∑≤Ëá™Âä®ËΩ¨Êç¢„ÄÇ', 'info');
                            }
                            
                            // Migration logic for image blocks
                            let migrated = false;
                            saved.blocks.forEach(block => {
                                if (block.type === 'image' && block.images && !block.cards) {
                                    block.cards = block.images.map(img => ({ ...img, id: this.generateId('ic') }));
                                    delete block.images;
                                    migrated = true;
                                }
                            });
                            if (migrated) {
                                this.showToast('ÊóßÁâàÂõæÁâáÂå∫ÂùóÂ∑≤Ëá™Âä®ÂçáÁ∫ß', 'info');
                            }

                            const defaultState = this.getDefaultState();
                            this.state = this.mergeDeep(defaultState, saved);

                            if (saved.uploadedFonts) {
                                this.uploadedFonts = saved.uploadedFonts;
                                this.uploadedFonts.forEach(font => {
                                    if (font.data) {
                                        try {
                                           const fontFace = new FontFace(font.family, this.base64ToArrayBuffer(font.data));
                                           fontFace.load().then(f => document.fonts.add(f)).catch(console.error);
                                        } catch(e) { console.error("Error loading font:", e)}
                                    }
                                });
                            }
                        }
                    } catch (e) { 
                        localStorage.removeItem('blokkoState'); 
                        this.showErrorModal('Âä†ËΩΩÂ≠òÊ°£Â§±Ë¥•', 'ÊÇ®ÁöÑÊú¨Âú∞Â≠òÊ°£ÂèØËÉΩÂ∑≤ÊçüÂùèÔºåÂ∑≤‰∏∫ÊÇ®Âä†ËΩΩÈªòËÆ§Ê®°Êùø„ÄÇÈîôËØØ‰ø°ÊÅØ: ' + e.message);
                        console.error("Failed to load state from localStorage:", e);
                    } 
                },
                
                mergeDeep(target, source) {
                    const isObject = (obj) => obj && typeof obj === 'object';
                    let output = { ...target };
                    if (isObject(target) && isObject(source)) {
                        Object.keys(source).forEach(key => {
                            if (isObject(source[key])) {
                                if (!(key in target)) {
                                    Object.assign(output, { [key]: source[key] });
                                } else if (Array.isArray(source[key])) {
                                    output[key] = source[key];
                                } else {
                                    output[key] = this.mergeDeep(target[key], source[key]);
                                }
                            } else {
                                Object.assign(output, { [key]: source[key] });
                            }
                        });
                    }
                    return output;
                },
                
                syncControl(stateKey) {
                    this.isRestoringState = true;
                    try {
                        const input = document.querySelector(`[data-state-key="${stateKey}"]`);
                        if (!input) return;
                        const value = stateKey.split('.').reduce((o, k) => o[k], this.state);
                        if (input.type === 'radio') {
                             document.querySelectorAll(`input[name="${input.name}"]`).forEach(radio => {
                                radio.checked = (radio.value == value);
                            });
                        } else if (input.type === 'checkbox') input.checked = !!value;
                        else input.value = value ?? '';
                        
                        if (input.type === 'color') {
                            const hexInput = document.querySelector(`[data-color-sync-key="${stateKey}"]`);
                            if(hexInput) hexInput.value = value || '';
                        }
                        if (input.type === 'range' && stateKey.endsWith('Angle')) {
                            input.previousElementSibling.querySelector('.angle-value').textContent = value;
                        }
                    } catch (e) {
                         console.error(`Error syncing control for ${stateKey}:`, e);
                    } finally {
                        this.isRestoringState = false;
                    }
                },

                syncAllControls() {
                    this.isRestoringState = true;
                    document.querySelectorAll('[data-state-key]').forEach(input => {
                        try {
                            const stateKey = input.dataset.stateKey;
                            if (stateKey === 'personalInfo.tags') return;
                            
                            const value = stateKey.split('.').reduce((o, k) => o[k], this.state);
                            if (input.type === 'radio') {
                                input.checked = (input.value == value);
                            }
                            else if (input.type === 'checkbox') input.checked = !!value;
                            else input.value = value ?? '';
                            
                            if (input.type === 'range' && stateKey.endsWith('Angle')) {
                                input.previousElementSibling.querySelector('.angle-value').textContent = value;
                            }
                        } catch (e) {}
                    });
                     document.querySelectorAll('.color-hex-input[data-color-sync-key]').forEach(hexInput => {
                        const colorInput = document.querySelector(`[data-state-key="${hexInput.dataset.colorSyncKey}"]`);
                        if(colorInput) hexInput.value = colorInput.value;
                     });
                     document.getElementById('gCardRadiusValue').textContent = this.state.globalCardStyles.radius;
                    
                    const gCardSection = document.getElementById('global-card-styles-section');
                    const gCardActiveTab = this.state.globalCardStyles.bgMode === 'gradient' ? 'card-bg-gradient' : 'card-bg-solid';
                    gCardSection.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === gCardActiveTab));
                    gCardSection.querySelectorAll('.tab-content').forEach(c => c.classList.toggle('active', c.id === gCardActiveTab));

                    const pageSection = document.getElementById('page-styles-section');
                    const pageActiveTab = this.state.pageStyles.pageBgMode === 'gradient' ? 'page-bg-gradient' : 'page-bg-solid';
                    pageSection.querySelectorAll('[data-tab^="page-bg-"]').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === pageActiveTab));
                    pageSection.querySelectorAll('#page-bg-solid, #page-bg-gradient').forEach(c => c.classList.toggle('active', c.id === pageActiveTab));

                    const headerSection = document.getElementById('header-styles-section');
                    const headerActiveTab = this.state.pageStyles.headerBgMode === 'gradient' ? 'header-bg-gradient' : 'header-bg-solid';
                    headerSection.querySelectorAll('[data-tab^="header-bg-"]').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === headerActiveTab));
                    headerSection.querySelectorAll('#header-bg-solid, #header-bg-gradient').forEach(c => c.classList.toggle('active', c.id === headerActiveTab));
                    
                    this.isRestoringState = false;
                },
                
                findBlock(blockId) { return this.state.blocks.find(b => b.id === blockId); },
                findBlockIndex(blockId) { return this.state.blocks.findIndex(b => b.id === blockId); },
                updateBlockTitle(blockId, title, pushHistory) { 
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) this.updateState(`blocks.${blockIndex}.title`, title, pushHistory);
                },
                updateBlockSettings(blockId, key, value, pushHistory) {
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) this.updateState(`blocks.${blockIndex}.settings.${key}`, value, pushHistory);
                },
                updateCard(blockId, cardId, key, value, pushHistory) {
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) {
                        const cardIndex = this.state.blocks[blockIndex].cards.findIndex(c => c.id === cardId);
                        if (cardIndex > -1) this.updateState(`blocks.${blockIndex}.cards.${cardIndex}.${key}`, value, pushHistory);
                    }
                },

                renderPreviewBlockById(blockId) {
                    const wrapper = this.elements.previewBlocksContainer.querySelector(`.preview-block-wrapper[data-block-id="${blockId}"]`);
                    const block = this.findBlock(blockId);
                    if (block && wrapper) {
                        wrapper.innerHTML = this.createPreviewBlockHTML(block);
                        this.initMasonryForBlock(blockId);
                    }
                },
                renderEditorBlockById(blockId) { 
                    const el = this.elements.editorBlocksList.querySelector(`.editor-block[data-block-id="${blockId}"]`); 
                    const block = this.findBlock(blockId); 
                    if (el && block) { 
                        const isCollapsed = el.classList.contains('collapsed');
                        const newHTML = this.createEditorBlockHTML(block);
                        el.outerHTML = newHTML;
                        const newEl = this.elements.editorBlocksList.querySelector(`.editor-block[data-block-id="${blockId}"]`);
                        if(isCollapsed) newEl.classList.add('collapsed'); 
                        else newEl.classList.remove('collapsed');
                        
                        if (block.type === 'text') {
                            this.renderEditorCards(block.id, newEl.querySelector('.card-editors-list'));
                        } else if (block.type === 'image') {
                            this.renderEditorImageCards(block.id, newEl.querySelector('.image-card-editors-list'));
                        }
                        
                        this.initSortablesForBlock(blockId);
                    } 
                },
                renderPreviewCardById(blockId, cardId) { 
                    const block = this.findBlock(blockId); 
                    const card = block?.cards.find(c => c.id === cardId); 
                    if (!card) return;

                    if (block.type === 'text') {
                        const el = this.elements.previewBlocksContainer.querySelector(`.preview-card[data-card-id="${cardId}"]`);
                        if (el) {
                            this.applyCardStyles(el, card);
                            const titleEl = el.querySelector('.preview-card-title');
                            const contentEl = el.querySelector('.preview-card-content');
                            const iconHTML = card.icon ? `<span class="iconify" data-icon="${card.icon}"></span>` : '';
                            if(titleEl) titleEl.innerHTML = `${iconHTML}${this.escapeHTML(card.title || '')}`;
                            if(contentEl) contentEl.innerHTML = this.escapeHTML(card.content || '');
                        }
                    } else if (block.type === 'image') {
                        const el = this.elements.previewBlocksContainer.querySelector(`figure[data-card-id="${cardId}"]`);
                        if (el) {
                           el.outerHTML = this.createPreviewImageCardHTML(card, block.settings);
                        }
                    }
                },
                renderEditorCardById(blockId, cardId) { 
                    const block = this.findBlock(blockId); 
                    const card = block?.cards.find(c => c.id === cardId); 
                    if (!card) return;
                    
                    if (block.type === 'text') {
                        const cardEl = this.elements.editorBlocksList.querySelector(`.editor-card[data-card-id="${cardId}"]`); 
                        if (cardEl) {
                            const followGlobal = card.followGlobalOpacity !== false;
                            cardEl.querySelector('.card-overlay-controls').style.display = card.bgImageDataUrl ? '' : 'none';
                            cardEl.querySelector('[data-card-key="opacity"]').closest('.form-group').style.display = followGlobal ? 'none' : 'block';
                            const iconBtn = cardEl.querySelector('.select-icon-btn');
                            if (iconBtn) {
                               iconBtn.innerHTML = card.icon ? `<span class="iconify" data-icon="${card.icon}" style="font-size: 1.2em; vertical-align: middle; margin-right: 5px;"></span> ${card.icon}` : 'ÈÄâÊã©ÂõæÊ†á';
                            }
                        }
                    } else if (block.type === 'image') {
                        const cardEl = this.elements.editorBlocksList.querySelector(`.editor-card[data-card-id="${cardId}"]`);
                        if (cardEl) {
                            cardEl.outerHTML = `<div class="editor-card" data-card-id="${card.id}">${this.createEditorImageCardHTML(card)}</div>`;
                        }
                    }
                },
                renderEditorCards(blockId, container) { 
                    if(!container) return; 
                    const block = this.findBlock(blockId); 
                    container.innerHTML = !block.cards?.length ? '<div class="empty-placeholder">ÊöÇÊó†Âç°Áâá</div>' : block.cards.map(c => `<div class="editor-card" data-card-id="${c.id}">${this.createEditorCardHTML(c)}</div>`).join(''); 
                },
                renderEditorImageCards(blockId, container) {
                    if(!container) return; 
                    const block = this.findBlock(blockId); 
                    container.innerHTML = !block.cards?.length ? '<div class="empty-placeholder">ÊöÇÊó†ÂõæÁâá</div>' : block.cards.map(c => `<div class="editor-card" data-card-id="${c.id}">${this.createEditorImageCardHTML(c)}</div>`).join(''); 
                },
                
                pushHistory() {
                     if (this.isRestoringState) return; 
                        if (this.historyIndex < this.history.length - 1) { 
                            this.history = this.history.slice(0, this.historyIndex + 1); 
                        } 
                        this.history.push(this.deepClone(this.state)); 
                        if (this.history.length > 50) this.history.shift(); 
                        this.historyIndex = this.history.length - 1;
                        this.updateUndoRedoButtons(); 
                },
                undo(){
                    if (this.historyIndex <= 0) return; 
                        this.isRestoringState = true; 
                        this.historyIndex--; 
                        this.state = this.deepClone(this.history[this.historyIndex]); 
                        this.renderAll(true); 
                        this.syncAllControls(); 
                        this.updateUndoRedoButtons(); 
                        this.isRestoringState = false; 
                        this.showToast('Â∑≤Êí§ÈîÄ', 'info');
                },
                redo(){
                     if (this.historyIndex >= this.history.length - 1) return; 
                        this.isRestoringState = true; 
                        this.historyIndex++; 
                        this.state = this.deepClone(this.history[this.historyIndex]); 
                        this.renderAll(true); 
                        this.syncAllControls(); 
                        this.updateUndoRedoButtons(); 
                        this.isRestoringState = false; 
                        this.showToast('Â∑≤ÈáçÂÅö', 'info');
                },
                updateUndoRedoButtons(){
                    this.elements.undoBtn.disabled = this.historyIndex <= 0; 
                    this.elements.redoBtn.disabled = this.historyIndex >= this.history.length - 1; 
                },
                
                async handleImageUpload(event, target, cardInfo = null){
                     const file = event.target.files[0]; 
                        if (!file) return; 
                        this.showLoading('Ê≠£Âú®Â§ÑÁêÜÂõæÁâá...');
                        try {
                            const reader = new FileReader(); 
                            reader.onload = async e => {
                                const compressedUrl = await this.compressImage(e.target.result, 0.85, 1200);
                                if (['avatar', 'pageBg', 'cardBg', 'imageCard'].includes(target)) {
                                    this.showCropper(compressedUrl, { type: target, ...cardInfo }); 
                                }
                                this.hideLoading();
                            }; 
                            reader.readAsDataURL(file); 
                        } catch(err) {
                            this.showErrorModal('ÂõæÁâáÂ§ÑÁêÜÂ§±Ë¥•', err.message);
                            this.hideLoading();
                        }
                        event.target.value = ''; 
                },
                handleCardBgUpload(event, blockId, cardId){
                    this.handleImageUpload(event, 'cardBg', { blockId, cardId });
                },
                async handleImageGalleryUpload(blockId, files){
                     const block = this.findBlock(blockId); 
                        if (!block || !files.length) return; 
                        this.showLoading(`Ê≠£Âú®‰∏ä‰º† ${files.length} Âº†ÂõæÁâá...`);
                        try {
                            this.pushHistory(); 
                            const newImages = await Promise.all(Array.from(files).map(f => this.readFileAsDataURL(f).then(this.compressImage)));
                            const newCards = newImages.map(url => ({ id: this.generateId('ic'), url, title: '', description: '' }));
                            block.cards.push(...newCards);
                            this.debouncedSaveToLocal();
                            this.renderEditorBlockById(blockId); 
                            this.renderPreviewBlockById(blockId); 
                        } catch (err) {
                            this.showErrorModal('ÂõæÁâá‰∏ä‰º†Â§±Ë¥•', err.message);
                        } finally {
                            this.hideLoading();
                        }
                },
                cropImage(blockId, cardId){
                    const block = this.findBlock(blockId);
                    const card = block?.cards.find(c => c.id === cardId);
                    if (card && card.url) {
                        this.showCropper(card.url, { type: 'imageCard', blockId, cardId });
                    }
                },
                
                showCropper(imageSrc, target){
                     this.currentCropTarget = target; 
                        this.elements.cropperModal.classList.add('visible'); 
                        this.elements.cropperImage.src = imageSrc; 
                        if (this.cropper) this.cropper.destroy(); 
                        this.cropper = new Cropper(this.elements.cropperImage, { aspectRatio: NaN, viewMode: 1, background: false }); 
                },
                hideCropper(){
                     this.elements.cropperModal.classList.remove('visible'); 
                        if (this.cropper) { 
                            this.cropper.destroy(); 
                            this.cropper = null; 
                        } 
                },
                async saveCrop(){
                     if (!this.cropper || !this.currentCropTarget) return;
                        this.showLoading('Ê≠£Âú®ÂéãÁº©Ë£ÅÂâ™ÂêéÁöÑÂõæÁâá...');
                        try {
                            const dataUrl = this.cropper.getCroppedCanvas()?.toDataURL();
                            if (!dataUrl) {
                                this.showErrorModal('Ë£ÅÂâ™Â§±Ë¥•', 'Êó†Ê≥ïËé∑ÂèñË£ÅÂâ™ÂêéÁöÑÂõæÁâáÊï∞ÊçÆ„ÄÇ');
                                return;
                            }

                            const { type, blockId, cardId } = this.currentCropTarget;
                            let maxWidth = 1024;
                            if (type === 'pageBg') maxWidth = 1920;
                            if (type === 'avatar' || type === 'cardBg') maxWidth = 400;
                            
                            const finalDataUrl = await this.compressImage(dataUrl, 0.85, maxWidth);

                            this.pushHistory();
                            if (type === 'avatar') {
                                this.updateState('personalInfo.avatarDataUrl', finalDataUrl, false);
                            } else if (type === 'pageBg') {
                                this.updateState('pageStyles.pageBgImageDataUrl', finalDataUrl, false);
                            } else if (type === 'imageCard') {
                                this.updateCard(blockId, cardId, 'url', finalDataUrl, false);
                            } else if (type === 'cardBg') {
                                this.updateCard(blockId, cardId, 'bgImageDataUrl', finalDataUrl, false);
                            }
                            this.hideCropper();
                        } catch (err) {
                            console.error('Save crop failed:', err);
                            this.showErrorModal('‰øùÂ≠òË£ÅÂâ™Â§±Ë¥•', 'Â§ÑÁêÜÂõæÁâáÊó∂ÂèëÁîüÈîôËØØ„ÄÇ');
                        } finally {
                            this.hideLoading();
                        }
                },
                updateCropAspectRatio(){
                     if(this.cropper) this.cropper.setAspectRatio(parseFloat(document.querySelector('input[name="crop-ratio"]:checked').value)); 
                },
                
                async loadLocalFonts(){
                     if (!window.queryLocalFonts) {
                            this.showErrorModal('ÂäüËÉΩ‰∏çÊîØÊåÅ', 'ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅËÆøÈóÆÊú¨Âú∞Â≠ó‰Ωì„ÄÇËØ∑Â∞ùËØï‰ΩøÁî®‚Äú‰∏ä‰º†Â≠ó‰Ωì‚ÄùÂäüËÉΩ„ÄÇ');
                            return;
                        }
                        try {
                            this.showLoading('Ê≠£Âú®Âä†ËΩΩÊú¨Âú∞Â≠ó‰Ωì...');
                            const fonts = await window.queryLocalFonts();
                            this.localFonts = fonts.map(font => ({ family: font.family, fullName: font.fullName, type: 'local' }));
                            this.populateFontList();
                            this.showToast(`Âä†ËΩΩ‰∫Ü ${this.localFonts.length} ‰∏™Êú¨Âú∞Â≠ó‰Ωì`, 'success');
                        } catch (err) {
                            console.error('Êó†Ê≥ïËÆøÈóÆÊú¨Âú∞Â≠ó‰Ωì:', err);
                            this.showErrorModal('Âä†ËΩΩÊú¨Âú∞Â≠ó‰ΩìÂ§±Ë¥•', 'ËøôÊòØ‰∏Ä‰∏™ÂÆûÈ™åÊÄßÁöÑÊµèËßàÂô®ÂäüËÉΩÔºåÂèØËÉΩÂõ†ÂÆâÂÖ®ËÆæÁΩÆÊàñÊµèËßàÂô®ÁâàÊú¨ËÄå‰∏çÁ®≥ÂÆö„ÄÇÂ¶ÇÊûúÊåÅÁª≠Â§±Ë¥•ÔºåÂª∫ËÆÆ‰ΩøÁî®‚Äú‰∏ä‰º†Â≠ó‰Ωì‚ÄùÂäüËÉΩ„ÄÇ');
                        } finally {
                            this.hideLoading();
                        }
                },
                async handleFontUpload(event){
                     const file = event.target.files[0];
                        if (!file) return;
                        this.showLoading('Ê≠£Âú®‰∏ä‰º†Âπ∂Âä†ËΩΩÂ≠ó‰Ωì...');
                        try {
                            const fontData = await this.readFileAsArrayBuffer(file);
                            const fontName = file.name.replace(/\.[^/.]+$/, "");
                            if (this.uploadedFonts.some(f => f.family === fontName) || this.localFonts.some(f => f.family === fontName)) {
                                this.showErrorModal('Â≠ó‰ΩìÂ∑≤Â≠òÂú®', `Â≠ó‰Ωì "${fontName}" Â∑≤Â≠òÂú®!`);
                                return;
                            }
                            const fontFace = new FontFace(fontName, fontData.slice(0));
                            await fontFace.load();
                            document.fonts.add(fontFace);
                            
                            const fontDataBase64 = await this.arrayBufferToBase64(fontData);
                            this.uploadedFonts.push({ family: fontName, fullName: `${fontName} (‰∏ä‰º†)`, data: fontDataBase64, type: 'uploaded' });
                            this.populateFontList();
                            this.updateState('globalCardStyles.fontFamily', fontName, true);
                            this.showToast(`Â≠ó‰Ωì "${fontName}" ‰∏ä‰º†ÊàêÂäü`, 'success');
                        } catch (error) {
                            console.error('Â≠ó‰Ωì‰∏ä‰º†Â§±Ë¥•:', error);
                            this.showErrorModal('Â≠ó‰Ωì‰∏ä‰º†Â§±Ë¥•', 'Â≠ó‰ΩìÊñá‰ª∂Êó†ÊïàÊàñÂä†ËΩΩÂ§±Ë¥•„ÄÇ');
                        } finally {
                            event.target.value = '';
                            this.hideLoading();
                        }
                },
                
                populateFontList(searchTerm = ''){
                     const select = this.elements.fontFamilySelect;
                        const currentFont = this.state.globalCardStyles.fontFamily;
                        select.innerHTML = '';
                        
                        const recommendedFonts = [
                            { family: 'Noto Sans SC', fullName: 'ÊÄùÊ∫êÈªë‰Ωì' },
                            { family: 'Noto Serif SC', fullName: 'ÊÄùÊ∫êÂÆã‰Ωì' },
                            { family: 'ZCOOL KuaiLe', fullName: 'Á´ôÈÖ∑Âø´‰πê‰Ωì' },
                            { family: 'ZCOOL XiaoWei', fullName: 'Á´ôÈÖ∑Â∞èËñá‰Ωì' },
                        ];

                        const allFonts = [...this.uploadedFonts, ...this.localFonts];
                        const categories = { cjk: [], sans: [], serif: [], uploaded: [], other: [] };
                        
                        const filteredFonts = searchTerm
                            ? allFonts.filter(font => 
                                font.family.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                font.fullName.toLowerCase().includes(searchTerm.toLowerCase()))
                            : allFonts;

                        filteredFonts.forEach(font => {
                            if (recommendedFonts.some(rf => rf.family === font.family)) return; // Skip if it's a recommended font
                            const category = this.getFontCategory(font);
                            if (!categories[category].some(f => f.family === font.family)) {
                                 categories[category].push(font);
                            }
                        });

                        const requiredFonts = this.getAllRequiredFonts();
                        requiredFonts.forEach(reqFont => {
                            if (!allFonts.some(f => f.family === reqFont) && !recommendedFonts.some(rf => rf.family === reqFont)) {
                               const placeholderFont = { family: reqFont, fullName: `${reqFont} (ÈúÄË¶ÅÈáçÊñ∞‰∏ä‰º†)`, type: 'uploaded', missing: true };
                               if (!categories.uploaded.some(f => f.family === reqFont)) {
                                   categories.uploaded.push(placeholderFont);
                               }
                            }
                        });

                        const createOptgroup = (label, fonts) => {
                            if (fonts.length === 0) return '';
                            const options = fonts
                                .sort((a, b) => a.fullName.localeCompare(b.fullName))
                                .map(f => `<option value="${this.escapeHTML(f.family)}" ${f.missing?'disabled':''}>${this.escapeHTML(f.fullName)}</option>`)
                                .join('');
                            return `<optgroup label="${label}">${options}</optgroup>`;
                        };

                        let html = '<option value="">Á≥ªÁªüÈªòËÆ§</option>';
                        html += createOptgroup('Êé®ËçêÂ≠ó‰Ωì', recommendedFonts);
                        html += createOptgroup('Â∑≤‰∏ä‰º†Â≠ó‰Ωì', categories.uploaded);
                        html += createOptgroup('‰∏≠Êñá / CJK', categories.cjk);
                        html += createOptgroup('Êó†Ë°¨Á∫ø (Sans-serif)', categories.sans);
                        html += createOptgroup('Ë°¨Á∫ø (Serif)', categories.serif);
                        html += createOptgroup('ÂÖ∂‰ªñ', categories.other);

                        select.innerHTML = html;
                        select.value = currentFont;
                },
                
                getFontCategory(font){
                     if (font.type === 'uploaded') return 'uploaded';
                        const name = (font.family + font.fullName).toLowerCase();
                        if (/(hei|song|ming|gothic|kai|fang|yuan|deng|Èªë|ÂÆã|Êòé|„Ç¥„Ç∑„ÉÉ„ÇØ|Ê•∑|Âúì)/.test(name) || /[\u4e00-\u9fa5]/.test(name)) {
                            return 'cjk';
                        }
                        if (name.includes('serif')) return 'serif';
                        if (name.includes('sans')) return 'sans';
                        return 'other';
                },
                getAllRequiredFonts(){
                     const fonts = new Set();
                        if (this.state.globalCardStyles.fontFamily) {
                            fonts.add(this.state.globalCardStyles.fontFamily);
                        }
                        return Array.from(fonts);
                },
                
                applyPreset(preset){
                     this.pushHistory(); 
                        
                        this.state.pageStyles.pageBgSolidColor = preset.pageBgSolidColor; 
                        this.state.pageStyles.pageBgGradientStart = preset.pageBgGradientStart;
                        this.state.pageStyles.pageBgGradientEnd = preset.pageBgGradientEnd;

                        this.state.pageStyles.headerBgColor = preset.headerBgColor;
                        this.state.pageStyles.headerBgGradientStart = preset.headerBgGradientStart;
                        this.state.pageStyles.headerBgGradientEnd = preset.headerBgGradientEnd;
                        this.state.pageStyles.headerTextColor = preset.headerTextColor; 
                        
                        this.state.globalCardStyles.bgColor = preset.gCardBgColor; 
                        this.state.globalCardStyles.bgGradientStart = preset.gCardBgGradientStart;
                        this.state.globalCardStyles.bgGradientEnd = preset.gCardBgGradientEnd;
                        this.state.globalCardStyles.textColor = preset.gCardTextColor; 
                        this.state.globalCardStyles.opacity = preset.gCardOpacity; 
                        
                        this.state.personalInfo.nicknameColor = preset.pNicknameColor;
                        this.state.personalInfo.subtitleColor = preset.pSubtitleColor;
                        this.state.personalInfo.bioColor = preset.pBioColor;
                        this.state.personalInfo.tagBgColor = preset.pTagBgColor;
                        this.state.personalInfo.tagTextColor = preset.pTagTextColor;
                        
                        this.state.pageStyles.pageBgMode = 'gradient';
                        this.state.pageStyles.headerBgMode = 'gradient';
                        this.state.globalCardStyles.bgMode = 'solid';

                        this.debouncedSaveToLocal();
                        this.renderAll(); 
                        this.syncAllControls();
                        this.showToast('È¢ÑËÆæÂ∑≤Â∫îÁî®', 'success');
                },
                
                readFileAsDataURL(file){return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    })},
                readFileAsArrayBuffer(file){return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(file);
                    })},
                compressImage(dataUrl, quality = 0.8, maxWidth = 1024){return new Promise(resolve => {
                        const img = new Image();
                        img.onload = () => {
                            let { width, height } = img;
                            if (width > maxWidth) {
                                height = (maxWidth / width) * height;
                                width = maxWidth;
                            }
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            resolve(canvas.toDataURL('image/jpeg', quality));
                        };
                        img.src = dataUrl;
                    })},
                
                toggleTheme(){
                    const isDark = document.documentElement.classList.toggle('dark-mode'); 
                    localStorage.setItem('blokkoTheme', isDark ? 'dark' : 'light'); 
                    this.elements.themeLabel.textContent = isDark ? 'ÊöóÈªëÊ®°Âºè' : 'Êòé‰∫ÆÊ®°Âºè'; 
                },
                loadPreferences(){
                    if (localStorage.getItem('blokkoTheme') === 'dark') { 
                        this.elements.themeLabel.textContent = 'ÊöóÈªëÊ®°Âºè'; 
                    } 
                },
                saveToLocal(){
                     try { 
                            const stateToSave = this.deepClone(this.state);
                            stateToSave.uploadedFonts = this.uploadedFonts;
                            localStorage.setItem('blokkoState', JSON.stringify(stateToSave)); 
                        } catch (e) {
                            console.error("Save to localStorage failed:", e);
                            if (e.name === 'QuotaExceededError') {
                                this.showErrorModal('Ëá™Âä®‰øùÂ≠òÂ§±Ë¥•', 'ÊµèËßàÂô®Â≠òÂÇ®Á©∫Èó¥Â∑≤Êª°ÔºÅÊÇ®Ê∑ªÂä†ÁöÑÂõæÁâáÊàñÂ≠ó‰ΩìÊñá‰ª∂ËøáÂ§ß„ÄÇËØ∑Á´ãÂç≥‚ÄúÂØºÂá∫ÈÖçÁΩÆ‚ÄùÊù•Â§á‰ªΩÊÇ®ÁöÑÂ∑•‰ΩúÔºåÁÑ∂ÂêéÂ∞ùËØïÁßªÈô§‰∏Ä‰∫õÂõæÁâáÊàñÂ≠ó‰Ωì‰ª•ÊÅ¢Â§çËá™Âä®‰øùÂ≠òÂäüËÉΩ„ÄÇ');
                            }
                        } 
                },
                
                generateFilename(type){
                    const nickname = (this.state.personalInfo.nickname || '').replace(/[^a-z0-9\u4e00-\u9fa5]/gi, '_').substring(0, 15) || 'Blokko';
                    const date = new Date();
                    const dateString = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
                    const randomString = Math.random().toString(36).substring(2, 8);
                    return `${nickname}-${dateString}-${type}-${randomString}`;
                },
                
                exportConfig(isTemplate = false){
                     let stateToSave = this.deepClone(this.state);
                        
                        if (isTemplate) {
                            stateToSave.personalInfo.nickname = "‰Ω†ÁöÑÊòµÁß∞";
                            stateToSave.personalInfo.subtitle = "ËøôÊòØÂâØÊ†áÈ¢ò";
                            stateToSave.personalInfo.bio = "ËøôÊòØÁÆÄ‰ªã";
                            stateToSave.personalInfo.tags = this.getDefaultState().personalInfo.tags;
                            stateToSave.personalInfo.avatarDataUrl = this.getDefaultState().personalInfo.avatarDataUrl;
                            stateToSave.pageStyles.pageBgImageDataUrl = null;
                            stateToSave.pageStyles.pageBgPattern = '';
                            stateToSave.customIcons = [];

                            stateToSave.blocks.forEach(block => {
                                if (block.type === 'text' || block.type === 'image') {
                                    block.title = block.type === 'text' ? "ÊñáÊú¨Âå∫Âùó" : "ÂõæÁâáÂå∫Âùó";
                                    block.cards.forEach(card => {
                                        if (block.type === 'text') {
                                            card.title = "Âç°ÁâáÊ†áÈ¢ò";
                                            card.content = "Âç°ÁâáÂÜÖÂÆπ";
                                            card.bgImageDataUrl = null;
                                        }
                                    });
                                    if(block.type === 'image') block.cards = [];
                                }
                            });
                            this.showToast('Ê®°ÊùøÂ∑≤ÂØºÂá∫', 'success');
                        } else {
                            stateToSave.uploadedFonts = this.uploadedFonts;
                            this.showToast('ÈÖçÁΩÆÂ∑≤ÂØºÂá∫', 'success');
                        }
                        
                        const blob = new Blob([JSON.stringify(stateToSave, null, 2)], { type: 'application/json' }); 
                        const filename = this.generateFilename(isTemplate ? 'Template' : 'Config') + '.json';
                        this.showDownloadModal(URL.createObjectURL(blob), filename, isTemplate ? 'Ê®°ÊùøÂ∑≤ÁîüÊàê' : 'ÈÖçÁΩÆÂ∑≤ÁîüÊàê');
                },
                
                async handleConfigFile(e){
                    const file = e.target.files[0]; 
                        if (!file) return;

                        if (!window.confirm('ÂØºÂÖ•ÈÖçÁΩÆÂ∞ÜË¶ÜÁõñÂΩìÂâçÊâÄÊúâÂÜÖÂÆπÔºåÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü')) {
                            e.target.value = '';
                            return;
                        }

                        this.showLoading('Ê≠£Âú®ÂØºÂÖ•ÈÖçÁΩÆ...');
                        await this.sleep(100); 
                        
                        const reader = new FileReader(); 
                        reader.onload = async (re) => { 
                            try { 
                                let importedState = JSON.parse(re.target.result); 
                                if (!importedState || !importedState.personalInfo || !importedState.blocks) throw new Error('Invalid file format'); 
                                
                                if (typeof importedState.personalInfo.tags === 'string') {
                                    importedState.personalInfo.tags = importedState.personalInfo.tags.split(/[,Ôºå„ÄÅ]/).map(t => t.trim()).filter(Boolean)
                                        .map(text => ({ id: this.generateId('t'), icon: null, text }));
                                    this.showToast('ÊóßÁâàÈÖçÁΩÆÂ∑≤ÂØºÂÖ•Âπ∂Ëá™Âä®ÂçáÁ∫ß„ÄÇ', 'info');
                                }

                                let migrated = false;
                                importedState.blocks.forEach(block => {
                                    if (block.type === 'image' && block.images && !block.cards) {
                                        block.cards = block.images.map(img => ({ ...img, id: this.generateId('ic') }));
                                        delete block.images;
                                        migrated = true;
                                    }
                                });
                                if (migrated) {
                                    this.showToast('ÊóßÁâàÂõæÁâáÂå∫ÂùóÂ∑≤Ëá™Âä®ÂçáÁ∫ß', 'info');
                                }

                                this.state = this.mergeDeep(this.getDefaultState(), importedState);
                                
                                this.uploadedFonts = [];
                                
                                if (importedState.uploadedFonts) {
                                    this.uploadedFonts = importedState.uploadedFonts;
                                    const fontLoadPromises = this.uploadedFonts.map(font => {
                                        if (font.data) {
                                            try {
                                               const fontFace = new FontFace(font.family, this.base64ToArrayBuffer(font.data));
                                               return fontFace.load().then(f => document.fonts.add(f));
                                            } catch (fontError) {
                                                console.error(`Failed to load font ${font.family} from config:`, fontError);
                                                return Promise.resolve();
                                            }
                                        }
                                        return Promise.resolve();
                                    });
                                    await Promise.all(fontLoadPromises);
                                }

                                this.history = [this.deepClone(this.state)];
                                this.historyIndex = 0;
                                this.renderAll(true); 
                                this.syncAllControls(); 
                                this.populateFontList();
                                this.initAllSortables();
                                this.updateExportSizePreview();
                                this.showToast('ÈÖçÁΩÆÂØºÂÖ•ÊàêÂäü', 'success');
                            } catch(err) { 
                                this.showErrorModal('ÂØºÂÖ•Â§±Ë¥•', 'ÈÖçÁΩÆÊñá‰ª∂Ê†ºÂºè‰∏çÊ≠£Á°ÆÊàñÂ∑≤ÊçüÂùè„ÄÇËØ∑Á°Æ‰øùÊÇ®ÂØºÂÖ•ÁöÑÊòØÁî±Êú¨Â∑•ÂÖ∑ÁîüÊàêÁöÑ .json Êñá‰ª∂„ÄÇ');
                                console.error(err);
                            } finally {
                                this.hideLoading();
                            }
                        }; 
                        reader.readAsText(file); 
                        e.target.value = ''; 
                },
                
                async bakeOverlaysForExport(clone) {
                    const style = document.createElement('style');
                    clone.appendChild(style);
                    
                    const pageWrapper = clone;
                    const styles = this.state.pageStyles;
                    let pageBgLayers = [];
                    let pageBgSizes = [];
                    let pageBgPositions = [];
                    let pageBgColor = 'transparent';

                    if (styles.pageBgPattern) {
                        const pattern = HeroPatterns.find(p => p.name === styles.pageBgPattern);
                        if (pattern) {
                            const coloredSvg = pattern.svg(styles.pageBgPatternColor, styles.pageBgPatternOpacity);
                            const base64Svg = btoa(unescape(encodeURIComponent(coloredSvg)));
                            pageBgLayers.push(`url("data:image/svg+xml;base64,${base64Svg}")`);
                            pageBgSizes.push(`${styles.pageBgPatternDensity}px`);
                            pageBgPositions.push('center');
                        }
                    }
                    if (styles.pageBgImageDataUrl) {
                        const overlayOpacity = parseFloat(styles.pageOverlayOpacity);
                        if (overlayOpacity > 0) {
                            const finalOverlayColor = this.hexToRgba(styles.pageOverlayColor, overlayOpacity);
                            pageBgLayers.push(`linear-gradient(${finalOverlayColor}, ${finalOverlayColor})`);
                            pageBgSizes.push('cover');
                            pageBgPositions.push('center');
                        }
                        pageBgLayers.push(`url(${styles.pageBgImageDataUrl})`);
                        pageBgSizes.push('cover');
                        pageBgPositions.push('center');
                    }
                    if (styles.pageBgMode === 'gradient') {
                        pageBgLayers.push(`linear-gradient(${styles.pageBgGradientAngle}deg, ${styles.pageBgGradientStart}, ${styles.pageBgGradientEnd})`);
                    } else {
                        pageBgColor = styles.pageBgSolidColor;
                    }

                    pageWrapper.style.backgroundColor = pageBgColor;
                    pageWrapper.style.backgroundImage = pageBgLayers.join(', ');
                    pageWrapper.style.backgroundSize = pageBgSizes.join(', ');
                    pageWrapper.style.backgroundPosition = bgPositions.join(', ');
                    
                    clone.querySelectorAll('.preview-card-inner').forEach(cardInner => {
                        const computed = getComputedStyle(cardInner);
                        const beforeComputed = getComputedStyle(cardInner, '::before');
                        const afterComputed = getComputedStyle(cardInner, '::after');
                        
                        let backgroundStyle = beforeComputed.getPropertyValue('background');
                        const overlayOpacity = parseFloat(afterComputed.getPropertyValue('opacity'));
                        const bgImage = beforeComputed.getPropertyValue('background-image');

                        if (overlayOpacity > 0 && bgImage !== 'none') {
                            const overlayColor = afterComputed.getPropertyValue('background-color');
                             if(overlayColor !== 'rgba(0, 0, 0, 0)') {
                                const overlayGradient = `linear-gradient(${overlayColor}, ${overlayColor})`;
                                backgroundStyle = `${overlayGradient}, ${backgroundStyle}`;
                            }
                        }
                        cardInner.style.background = backgroundStyle;
                        cardInner.style.border = computed.border;
                        cardInner.style.boxShadow = computed.boxShadow;
                    });
                    
                    style.innerHTML += `#${clone.id} .preview-card-inner::before, #${clone.id} .preview-card-inner::after { content: none !important; background: none !important; display: none !important; }`;
                },
                
                async exportPNG(){
                    this.showLoading('Ê≠£Âú®ÂáÜÂ§áÂØºÂá∫...');
                    
                    const isCustomWidth = this.elements.customWidthToggle.checked;
                    const isHD = this.elements.hdExportToggle.checked;
                    let targetWidth = 1200;
                    if (isCustomWidth) {
                        targetWidth = parseInt(this.elements.customWidthInput.value, 10) || 1200;
                    } else if (isHD) {
                        targetWidth = 1800;
                    }
                    const sourceWidth = 600;
                    const scale = targetWidth / sourceWidth;

                    const exportRounded = this.elements.exportRoundedCornersToggle.checked;
                    const cornerRadius = parseInt(this.elements.exportCornerRadiusInput.value, 10) || 20;

                    const originalElement = this.elements.previewWrapper;
                    let clone = null;
                    
                    const wasDrawerOpen = this.elements.editorPanel.classList.contains('is-open');
                    if (wasDrawerOpen) {
                        this.toggleEditorDrawer(false);
                        await this.sleep(100);
                    }
                    
                    document.body.classList.add('export-mode');

                    try {
                        clone = originalElement.cloneNode(true);
                        clone.id = `export-clone-${Date.now()}`;
                        
                        const style = document.createElement('style');
                        style.innerHTML = `#${clone.id}, #${clone.id} * { transition: none !important; animation: none !important; } #${clone.id} .preview-card:hover .preview-card-inner { transform: none !important; box-shadow: var(--active-card-shadow, none) !important; }`;
                        clone.appendChild(style);

                        clone.style.position = 'absolute';
                        clone.style.left = '-9999px';
                        clone.style.top = '0px';
                        clone.style.borderRadius = '0';
                        clone.style.width = `${sourceWidth}px`;
                        
                        document.body.appendChild(clone);
                        await this.sleep(100);

                        this.showLoading('Ê≠£Âú®Â§ÑÁêÜÊ†∑Âºè (ÁÉòÁÑô)...');
                        await this.bakeOverlaysForExport(clone);
                        await this.sleep(100);

                        this.showLoading('Ê≠£Âú®Ê∏≤ÊüìÂõæÁâá...');
                        const canvas = await html2canvas(clone, { scale: scale, useCORS: true, backgroundColor: null, logging: false });

                        let finalCanvas = canvas;
                        if (exportRounded && cornerRadius > 0) {
                            this.showLoading('Ê≠£Âú®Â∫îÁî®ÂúÜËßí...');
                            finalCanvas = document.createElement('canvas');
                            finalCanvas.width = canvas.width;
                            finalCanvas.height = canvas.height;
                            const ctx = finalCanvas.getContext('2d');
                            const scaledRadius = cornerRadius * scale;
                            
                            ctx.beginPath();
                            ctx.moveTo(scaledRadius, 0);
                            ctx.lineTo(finalCanvas.width - scaledRadius, 0);
                            ctx.arcTo(finalCanvas.width, 0, finalCanvas.width, scaledRadius, scaledRadius);
                            ctx.lineTo(finalCanvas.width, finalCanvas.height - scaledRadius);
                            ctx.arcTo(finalCanvas.width, finalCanvas.height, finalCanvas.width - scaledRadius, finalCanvas.height, scaledRadius);
                            ctx.lineTo(scaledRadius, finalCanvas.height);
                            ctx.arcTo(0, finalCanvas.height, 0, finalCanvas.height - scaledRadius, scaledRadius);
                            ctx.lineTo(0, scaledRadius);
                            ctx.arcTo(0, 0, scaledRadius, 0, scaledRadius);
                            ctx.closePath();
                            ctx.clip();
                            ctx.drawImage(canvas, 0, 0);
                        }

                        const dataUrl = finalCanvas.toDataURL('image/png');
                        const filename = this.generateFilename('Image') + '.png';
                        this.showDownloadModal(dataUrl, filename, 'ÂõæÁâáÂ∑≤ÁîüÊàê');

                    } catch (err) {
                        console.error("PNG export failed:", err);
                        this.showErrorModal('ÂØºÂá∫Â§±Ë¥•', `ÁîüÊàêÂõæÁâáÊó∂ÂèëÁîüÈîôËØØ: ${err.message}.`);
                    } finally {
                        if (clone && clone.parentNode) {
                            clone.parentNode.removeChild(clone);
                        }
                        if (wasDrawerOpen) {
                            this.toggleEditorDrawer(true);
                        }
                        document.body.classList.remove('export-mode');
                        this.hideLoading();
                    }
                },
                
                updateExportSizePreview(){
                    const el = this.elements.previewWrapper;
                    if (!el || el.clientWidth === 0) return;

                    const isCustomWidth = this.elements.customWidthToggle.checked;
                    const isHD = this.elements.hdExportToggle.checked;
                    let targetWidth = 1200;

                    if (isCustomWidth) {
                        targetWidth = parseInt(this.elements.customWidthInput.value, 10) || 1200;
                    } else if (isHD) {
                        targetWidth = 1800;
                    }
                    
                    const aspectRatio = el.clientHeight / el.clientWidth;
                    const finalHeight = Math.round(targetWidth * aspectRatio);

                    this.elements.exportSizePreview.textContent = `ÂØºÂá∫Â∞∫ÂØ∏: ${targetWidth}x${finalHeight}px`;
                    
                    let buttonText = 'ÂØºÂá∫‰∏∫ÂõæÁâá';
                    if (isCustomWidth) {
                        buttonText += ` (${targetWidth}px)`;
                    } else {
                        buttonText += isHD ? ' (1800px)' : ' (1200px)';
                    }
                    this.elements.exportPngBtn.textContent = buttonText;
                },
                
                arrayBufferToBase64(buffer){
                    return new Promise((resolve, reject) => {
                            const blob = new Blob([buffer], {type: 'application/octet-stream'});
                            const reader = new FileReader();
                            reader.onload = e => resolve(e.target.result);
                            reader.onerror = e => reject(e);
                            reader.readAsDataURL(blob);
                        });
                },
                base64ToArrayBuffer(base64){
                    const binaryString = atob(base64.split(',')[1]);
                        const len = binaryString.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        return bytes.buffer;
                },
                
                showDownloadModal(url, filename, title){
                    this.elements.downloadModalTitle.textContent = title; 
                        const content = this.elements.downloadModalContent; 
                        content.innerHTML = `<a href="${url}" download="${filename}">ÁÇπÂáª‰∏ãËΩΩ: ${filename}</a>`; 
                        if (url.startsWith('data:image')) content.insertAdjacentHTML('afterbegin', `<img src="${url}">`); 
                        this.elements.downloadModal.classList.add('visible'); 
                },
                hideDownloadModal(){ this.elements.downloadModal.classList.remove('visible'); },
                showErrorModal(title, message){
                    const existingModal = document.querySelector('.error-modal');
                        if (existingModal) existingModal.remove();
                        const modal = document.createElement('div');
                        modal.className = 'error-modal';
                        modal.innerHTML = `<h3>${title}</h3><p>${message}</p><button class="btn btn-primary" onclick="this.closest('.error-modal').remove()">Á°ÆÂÆö</button>`;
                        document.body.appendChild(modal);
                },
                
                showLoading(text = 'Ê≠£Âú®Â§ÑÁêÜ...'){
                    this.elements.loadingText.textContent = text;
                        this.elements.loadingOverlay.classList.add('visible');
                },
                hideLoading(){
                    this.elements.loadingOverlay.classList.remove('visible');
                },
                showToast(message, type = 'info'){
                     const toast = document.createElement('div');
                        toast.className = `toast-notification ${type}`;
                        toast.textContent = message;
                        this.elements.toastContainer.appendChild(toast);
                        setTimeout(() => {
                            toast.remove();
                        }, 5000);
                },
                
                updateGlobalCardStyleVars(){
                     const g = this.state.globalCardStyles;
                        const r = document.documentElement.style; 
                        
                        r.setProperty('--g-card-bg-color', g.bgColor);
                        r.setProperty('--g-card-text-color',g.textColor); 
                        r.setProperty('--g-card-opacity',g.opacity); 
                        r.setProperty('--g-card-border-radius',`${g.radius}px`); 
                        r.setProperty('--g-card-text-align',g.textAlign); 
                        r.setProperty('--g-card-line-height',g.lineHeight); 
                        r.setProperty('--active-card-font-family',g.fontFamily?`'${g.fontFamily}', sans-serif`:''); 
                        r.setProperty('--active-card-font-size',g.fontSize);
                        r.setProperty('--g-card-text-stroke', g.textStrokeWidth > 0 ? `${g.textStrokeWidth}px ${g.textStrokeColor}` : '0px transparent');
                        
                        const regularShadow = g.shadowEnabled ? 'var(--g-card-shadow)' : 'none';
                        if (g.borderStyle === 'solid' && g.borderWidth > 0) {
                            const borderShadow = `0 0 0 ${g.borderWidth}px ${g.borderColor}`;
                            r.setProperty('--active-card-shadow', `${borderShadow}, ${regularShadow}`);
                            r.setProperty('--active-card-border', 'none');
                        } else {
                            r.setProperty('--active-card-border', g.borderWidth > 0 ? `${g.borderWidth}px ${g.borderStyle} ${g.borderColor}` : 'none');
                            r.setProperty('--active-card-shadow', regularShadow);
                        }
                },
                
                initAllSortables(){
                     this.initSortableBlocksEditor();
                        this.initSortableBlocksPreview();
                        this.state.blocks.forEach(b => this.initSortablesForBlock(b.id));
                },
                initSortablesForBlock(blockId){
                     const block = this.findBlock(blockId);
                        if (!block) return;
                        if (block.type === 'text') this.initSortableCards(blockId);
                        if (block.type === 'image') this.initSortableImageCards(blockId);
                },
                initSortableBlocksEditor(){
                    if(this.sortableBlocksEditor) this.sortableBlocksEditor.destroy(); 
                    this.sortableBlocksEditor = new Sortable(this.elements.editorBlocksList, { handle: '.block-drag-handle', animation: 150, ghostClass: 'sortable-ghost', onEnd: e => { this.pushHistory(); const [m] = this.state.blocks.splice(e.oldIndex, 1); this.state.blocks.splice(e.newIndex, 0, m); this.debouncedSaveToLocal(); this.renderPreviewBlocks(); } }); 
                },
                initSortableBlocksPreview(){
                    if(this.sortableBlocksPreview) this.sortableBlocksPreview.destroy(); 
                    this.sortableBlocksPreview = new Sortable(this.elements.previewBlocksContainer, { animation: 150, ghostClass: 'sortable-ghost', onEnd: e => { this.pushHistory(); const [m] = this.state.blocks.splice(e.oldIndex, 1); this.state.blocks.splice(e.newIndex, 0, m); this.debouncedSaveToLocal(); this.renderEditorBlocks(); } });
                },
                initSortableCards(blockId){
                    const list = this.elements.editorBlocksList.querySelector(`[data-block-id="${blockId}"] .card-editors-list`); 
                    if (list) { if(this.cardSortables[blockId]) this.cardSortables[blockId].destroy(); this.cardSortables[blockId] = new Sortable(list, { handle: '.card-drag-handle', animation: 150, ghostClass: 'sortable-ghost', onEnd: e => { const b = this.findBlock(blockId); if (b) { this.pushHistory(); const [m] = b.cards.splice(e.oldIndex, 1); b.cards.splice(e.newIndex, 0, m); this.debouncedSaveToLocal(); this.renderPreviewBlockById(blockId); } } }); } 
                },
                initSortableImageCards(blockId){
                    const container = this.elements.editorBlocksList.querySelector(`[data-block-id="${blockId}"] .image-card-editors-list`);
                    if (container) { if (this.imageCardSortables[blockId]) this.imageCardSortables[blockId].destroy(); this.imageCardSortables[blockId] = new Sortable(container, { handle: '.card-drag-handle', animation: 150, ghostClass: 'sortable-ghost', onEnd: e => { const block = this.findBlock(blockId); if (block) { this.pushHistory(); const [moved] = block.cards.splice(e.oldIndex, 1); block.cards.splice(e.newIndex, 0, moved); this.debouncedSaveToLocal(); this.renderPreviewBlockById(blockId); } } }); }
                },

                initMasonryForBlock(blockId) {
                    this.destroyMasonryForBlock(blockId); 
                    const block = this.findBlock(blockId);
                    if (block && (block.type === 'text' || block.type === 'image') && ['dual', 'triple'].includes(block.settings.layout) && block.settings.masonryEnabled) {
                        const previewEl = this.elements.previewBlocksContainer.querySelector(`[data-block-id="${blockId}"] .preview-cards-container`);
                        if (previewEl) {
                            previewEl.classList.add('masonry-active');
                            const itemSelector = block.type === 'text' ? '.preview-card' : 'figure';
                            this.masonryInstances[blockId] = new Masonry(previewEl, {
                                itemSelector: itemSelector,
                                gutter: 15
                            });
                        }
                    }
                },
                destroyMasonryForBlock(blockId) {
                    if (this.masonryInstances[blockId]) {
                        this.masonryInstances[blockId].destroy();
                        delete this.masonryInstances[blockId];
                        const previewEl = this.elements.previewBlocksContainer.querySelector(`[data-block-id="${blockId}"] .preview-cards-container`);
                        if (previewEl) {
                            previewEl.classList.remove('masonry-active');
                        }
                    }
                },
                
                toggleEditorDrawer(forceState){
                    const isOpen = this.elements.editorPanel.classList.toggle('is-open', forceState);
                    this.elements.body.classList.toggle('editor-open', isOpen);
                },
                resetToDefault() {
                    if (window.confirm('Ë≠¶ÂëäÔºöÊ≠§Êìç‰ΩúÂ∞ÜÊ∏ÖÁ©∫ÊÇ®ÊâÄÊúâÁöÑÂÜÖÂÆπÂíåÊ†∑ÂºèËÆæÁΩÆÔºåÂπ∂ÊÅ¢Â§çÂà∞ÂàùÂßãÊ®°Êùø„ÄÇÊ≠§ËøáÁ®ã‰∏çÂèØÊí§ÈîÄÔºåÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü')) {
                        localStorage.removeItem('blokkoState');
                        localStorage.removeItem('blokkoFirstVisit');
                        localStorage.removeItem('blokkoTutorialSeen');
                        this.state = this.getDefaultState();
                        this.history = [this.deepClone(this.state)];
                        this.historyIndex = 0;
                        this.updateUndoRedoButtons();
                        this.renderAll(true);
                        this.syncAllControls();
                        this.showToast('Â∑≤ÊÅ¢Â§ç‰∏∫ÈªòËÆ§Ê®°Êùø', 'success');
                    }
                },

                toggleLockMode() {
                    const sortableInstance = Sortable.get(this.elements.previewBlocksContainer);
                    const isLocked = !sortableInstance.options.disabled;
                    sortableInstance.option('disabled', isLocked);
                    
                    this.elements.previewBlocksContainer.classList.toggle('locked-mode', isLocked);
                    const button = this.elements.lockModeToggle;
                    
                    if (isLocked) {
                        button.textContent = 'ÈîÅÂÆö‰∏≠';
                        button.title = 'È¢ÑËßàÊ®°Âºè (ÁÇπÂáªÂàáÊç¢‰∏∫ÁºñËæëÊ®°Âºè)';
                    } else {
                        button.textContent = 'ÁºñËæë‰∏≠';
                        button.title = 'ÁºñËæëÊ®°Âºè (ÁÇπÂáªÂàáÊç¢‰∏∫È¢ÑËßàÊ®°Âºè)';
                    }
                },
                
                renderTagManager() {
                    const tags = this.state.personalInfo.tags || [];
                    if (!tags.length) {
                        this.elements.tagManagerList.innerHTML = `<div class="empty-tag-list">ÊöÇÊó†Ê†áÁ≠æ</div>`;
                        return;
                    }
                    this.elements.tagManagerList.innerHTML = tags.map(tag => {
                        const iconHTML = tag.icon ? `<span class="iconify" data-icon="${tag.icon}"></span>` : 'Êó†';
                        return `<div class="tag-manager-item" data-tag-id="${tag.id}">
                            <button class="btn btn-default btn-icon tag-icon-btn">${iconHTML}</button>
                            <input type="text" class="tag-text-input" value="${this.escapeHTML(tag.text)}">
                            <button class="btn btn-danger btn-icon tag-delete-btn"><span class="iconify" data-icon="mdi:delete"></span></button>
                        </div>`;
                    }).join('');
                },
                addNewTag() {
                    const text = this.elements.newTagTextInput.value.trim();
                    if (!text) return;
                    this.pushHistory();
                    this.state.personalInfo.tags.push({ id: this.generateId('t'), icon: null, text });
                    this.debouncedSaveToLocal();
                    this.renderPersonalInfo();
                    this.renderTagManager();
                    this.elements.newTagTextInput.value = '';
                    this.elements.newTagTextInput.focus();
                },
                deleteTag(tagId) {
                    this.pushHistory();
                    this.state.personalInfo.tags = this.state.personalInfo.tags.filter(t => t.id !== tagId);
                    this.debouncedSaveToLocal();
                    this.renderPersonalInfo();
                    this.renderTagManager();
                },
                updateTag(tagId, key, value, pushHistory) {
                    const tagIndex = this.state.personalInfo.tags.findIndex(t => t.id === tagId);
                    if (tagIndex > -1) this.updateState(`personalInfo.tags.${tagIndex}.${key}`, value, pushHistory);
                },

                async loadIcons(){
                     this.showLoading('Ê≠£Âú®Âä†ËΩΩÂõæÊ†áÂ∫ì...');
                     try {
                         await this.sleep(100);
                         this.showToast('ÂõæÊ†áÂ∫ìÂä†ËΩΩÂÆåÊàê', 'info');
                     } catch(e) {
                         this.showErrorModal('ÂõæÊ†áÂ∫ìÂä†ËΩΩÂ§±Ë¥•', 'Êó†Ê≥ïËøûÊé•Âà∞ Iconify APIÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•„ÄÇ');
                     } finally {
                        this.hideLoading();
                     }
                },
                async renderIconGrid(searchTerm = ''){
                     this.elements.iconGrid.innerHTML = `<div class="spinner" style="margin: 40px auto;"></div>`;

                     let customIconsHTML = '';
                     if (this.state.customIcons && this.state.customIcons.length > 0) {
                         customIconsHTML = this.state.customIcons.map(icon => 
                            `<div class="icon-grid-item" data-icon="${icon.dataUrl}" data-icon-name="${icon.name}" title="${this.escapeHTML(icon.name)}">
                                <img src="${icon.dataUrl}" style="width: 24px; height: 24px;">
                                <button class="btn btn-icon btn-danger btn-small delete-custom-icon-btn" title="Âà†Èô§Ê≠§ÂõæÊ†á">
                                    <span class="iconify" data-icon="mdi:delete"></span>
                                </button>
                            </div>`
                        ).join('');
                        customIconsHTML = `<h4>Ëá™ÂÆö‰πâÂõæÊ†á</h4><div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 10px;">${customIconsHTML}</div><hr class="separator"><h4>Âú®Á∫øÂõæÊ†á</h4>`;
                     }

                     if (!searchTerm) {
                         this.elements.iconGrid.innerHTML = customIconsHTML + '<p style="text-align: center; color: var(--text-placeholder);">ËØ∑ËæìÂÖ•ÂÖ≥ÈîÆËØçÊêúÁ¥¢Âú®Á∫øÂõæÊ†á</p>';
                         return;
                     }
                     try {
                        const prefixes = 'lucide,tabler,mdi,ph,fa6-solid,fa6-brands';
                        const response = await fetch(`https://api.iconify.design/search?query=${encodeURIComponent(searchTerm)}&limit=99&prefixes=${prefixes}`);
                        const data = await response.json();

                        let onlineIconsHTML;
                        if (data.icons.length === 0) {
                            onlineIconsHTML = '<p style="text-align: center; color: var(--text-placeholder);">Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÂú®Á∫øÂõæÊ†á</p>';
                        } else {
                            onlineIconsHTML = data.icons.map(name => 
                                `<div class="icon-grid-item" data-icon="${name}" title="${name}"><span class="iconify" data-icon="${name}"></span></div>`
                            ).join('');
                        }
                        this.elements.iconGrid.innerHTML = customIconsHTML + onlineIconsHTML;
                     } catch(e) {
                        this.elements.iconGrid.innerHTML = customIconsHTML + '<p style="text-align: center; color: var(--color-danger);">ÊêúÁ¥¢Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªú„ÄÇ</p>';
                     }
                },
                showIconPicker(type, id, cardId = null){
                     this.currentIconTarget = { type, id, cardId };
                     this.elements.iconPickerModal.classList.add('visible');
                     this.renderIconGrid(this.elements.iconSearch.value);
                     this.elements.iconSearch.focus();
                },
                hideIconPicker(){
                     this.elements.iconPickerModal.classList.remove('visible');
                     this.currentIconTarget = null;
                     this.elements.iconSearch.value = '';
                     this.elements.iconGrid.innerHTML = '';
                },
                selectIcon(iconClass){
                    if (this.currentIconTarget) {
                        const { type, id, cardId } = this.currentIconTarget;
                        if (type === 'card') {
                            this.updateCard(id, cardId, 'icon', iconClass, true);
                        } else if (type === 'tag') {
                            this.updateTag(id, 'icon', iconClass, true);
                        }
                    }
                    this.hideIconPicker();
                },
                async handleIconUpload(event) {
                    const file = event.target.files[0];
                    if (!file || file.type !== 'image/svg+xml') {
                        this.showToast('ËØ∑‰∏ä‰º†‰∏Ä‰∏™.svgÊ†ºÂºèÁöÑÂõæÊ†áÊñá‰ª∂', 'error');
                        return;
                    }

                    if (this.state.customIcons.some(icon => icon.name === file.name)) {
                        this.showToast(`Â∑≤Â≠òÂú®Âêç‰∏∫ "${file.name}" ÁöÑÂõæÊ†á`, 'error');
                        return;
                    }

                    try {
                        const dataUrl = await this.readFileAsDataURL(file);
                        this.pushHistory();
                        this.state.customIcons.push({ name: file.name, dataUrl: dataUrl });
                        this.debouncedSaveToLocal();
                        this.renderIconGrid(this.elements.iconSearch.value);
                        this.showToast(`ÂõæÊ†á "${file.name}" ‰∏ä‰º†ÊàêÂäü`, 'success');
                    } catch (error) {
                        this.showErrorModal('ÂõæÊ†á‰∏ä‰º†Â§±Ë¥•', error.message);
                    } finally {
                        event.target.value = '';
                    }
                },
                deleteCustomIcon(iconName) {
                    if (window.confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§Ëá™ÂÆö‰πâÂõæÊ†á "${iconName}" ÂêóÔºü`)) {
                        this.pushHistory();
                        this.state.customIcons = this.state.customIcons.filter(icon => icon.name !== iconName);
                        this.debouncedSaveToLocal();
                        this.renderIconGrid(this.elements.iconSearch.value);
                        this.showToast(`ÂõæÊ†á "${iconName}" Â∑≤Âà†Èô§`, 'info');
                    }
                },

                renderTexturePicker() {
                    this.elements.textureGrid.innerHTML = HeroPatterns.map(p => {
                        const svg = p.svg('var(--text-primary)', 0.5);
                        const base64Svg = btoa(unescape(encodeURIComponent(svg)));
                        return `<div class="texture-grid-item" data-texture-name="${p.name}">
                                    <div class="texture-preview" style="background-image: url(data:image/svg+xml;base64,${base64Svg});"></div>
                                    <span class="texture-name">${p.name}</span>
                                </div>`;
                    }).join('');
                },
                selectTexture(textureName) {
                    this.updateState('pageStyles.pageBgPattern', textureName, true);
                    if (textureName) this.elements.currentTextureName.textContent = textureName;
                    this.elements.texturePickerModal.classList.remove('visible');
                },

                focusOnEditorElement(blockId, cardId = null) {
                    if (window.innerWidth <= 768) return;

                    const editorBlockEl = this.elements.editorBlocksList.querySelector(`.editor-block[data-block-id="${blockId}"]`);
                    if (!editorBlockEl) return;

                    const mainSection = editorBlockEl.closest('.editor-section');
                    if (mainSection && mainSection.classList.contains('collapsed')) {
                        mainSection.classList.remove('collapsed');
                    }
                    
                    setTimeout(() => {
                        let targetEl = editorBlockEl;

                        if (cardId) {
                            const cardEl = editorBlockEl.querySelector(`.editor-card[data-card-id="${cardId}"]`);
                            if (cardEl) {
                                targetEl = cardEl;
                            }
                        }

                        targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        targetEl.style.transition = 'outline 0.1s ease-in-out, box-shadow 0.2s ease-in-out';
                        targetEl.style.outline = '2px solid var(--color-primary)';
                        targetEl.style.boxShadow = '0 0 12px rgba(0, 122, 255, 0.4)';
                        setTimeout(() => {
                            targetEl.style.outline = '';
                            targetEl.style.boxShadow = '';
                        }, 1500);
                    }, 150);
                },

                handleFirstVisit() {
                    const tutorialSeen = localStorage.getItem('blokkoTutorialSeen');
                    const firstVisit = localStorage.getItem('blokkoFirstVisit');
                    
                    if (!tutorialSeen) {
                        this.showTutorial();
                    } else if (firstVisit === null) {
                        this.elements.newbieTipBar.style.display = 'flex';
                        localStorage.setItem('blokkoFirstVisit', 'true');
                    }
                },

                showTutorial() {
                    const modal = this.elements.helpModal;
                    modal.classList.add('visible');
                    
                    modal.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                    modal.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    
                    modal.querySelector('[data-tab="help-tutorial"]').classList.add('active');
                    modal.querySelector('#help-tutorial').classList.add('active');
                },

                hexToRgba(hex, alpha=1){
                    if(!hex || parseFloat(alpha) === 0) return 'transparent';
                    if (hex.startsWith('rgba')) {
                        return hex.replace(/, ?\d?\.?\d+\)$/, `, ${alpha})`);
                    }
                    const match = hex.match(/\w\w/g);
                    if (!match) return `rgba(0,0,0,${alpha})`;
                    const [r, g, b] = match.map(x => parseInt(x, 16)); 
                    return `rgba(${r},${g},${b},${alpha})`;
                },
                
                debounce(func, wait){
                     let timeout; 
                     return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), wait); }; 
                },
                generateId(p){ return `${p}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}` },
                deepClone(obj){ return JSON.parse(JSON.stringify(obj)) },
                escapeHTML(str){ return (str || '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'})[m]) },
                sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)) },

                async addBlock(type) {
                    this.pushHistory();
                    
                    const sortable = Sortable.get(this.elements.previewBlocksContainer);
                    const wasDisabled = sortable.options.disabled;
                    if (wasDisabled) sortable.option('disabled', false);

                    let newBlock;
                    const defaultState = this.getDefaultState();
                    switch(type) {
                        case 'text':
                            newBlock = defaultState.blocks.find(b => b.type === 'text');
                            newBlock.id = this.generateId('b');
                            newBlock.cards[0].id = this.generateId('c');
                            break;
                        case 'image':
                            newBlock = defaultState.blocks.find(b => b.type === 'image');
                            newBlock.id = this.generateId('b');
                            break;
                        case 'separator':
                            newBlock = defaultState.blocks.find(b => b.type === 'separator');
                            newBlock.id = this.generateId('b');
                            break;
                        case 'spacer':
                            newBlock = defaultState.blocks.find(b => b.type === 'spacer');
                            newBlock.id = this.generateId('b');
                            break;
                    }
                    this.state.blocks.push(this.deepClone(newBlock));
                    this.debouncedSaveToLocal();

                    this.renderAll();
                    await this.sleep(10);
                    this.initAllSortables();
                    if (wasDisabled) sortable.option('disabled', true);
                    
                    const newEditorBlock = this.elements.editorBlocksList.querySelector(`[data-block-id="${newBlock.id}"]`);
                    if(newEditorBlock) newEditorBlock.scrollIntoView({ behavior: 'smooth', block: 'center' });
                },
                async deleteBlock(blockId) {
                    this.pushHistory();
                    
                    this.destroyMasonryForBlock(blockId);

                    const sortable = Sortable.get(this.elements.previewBlocksContainer);
                    const wasDisabled = sortable.options.disabled;
                    if (wasDisabled) sortable.option('disabled', false);

                    this.state.blocks = this.state.blocks.filter(b => b.id !== blockId);
                    this.debouncedSaveToLocal();

                    this.renderAll();
                    await this.sleep(10);
                    this.initAllSortables();
                    if (wasDisabled) sortable.option('disabled', true);
                    this.showToast('Âå∫ÂùóÂ∑≤Âà†Èô§', 'info');
                },
            };

            App.init();
        });
    </script>
</body>
</html>
