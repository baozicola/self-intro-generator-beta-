<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Blokko v1.5.2 (Internal): -->
    <title>Blokko-ä¸ªäººç®€ä»‹ç”Ÿæˆå™¨ï¼ (v1.5.2)-æ¥ç©2077å§ï¼</title>
    
    <script>
        // Anti-FOUC (Flash of Unstyled Content) Script
        try {
            if (localStorage.getItem('blokkoTheme') === 'dark') {
                document.documentElement.classList.add('dark-mode');
            }
        } catch (e) {
            console.error('Failed to apply theme from localStorage', e);
        }
    </script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" />

    <!-- v1.3.1: Add Recommended Fonts via reliable CDN -->
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Sans+SC:400,700&display=swap">
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:400,700&display=swap">
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=ZCOOL+KuaiLe&display=swap">
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=ZCOOL+XiaoWei&display=swap">

    <style>
        /* CSS å˜é‡ */
        :root {
            --bg-editor: #ffffff; --bg-preview-pane: #f0f2f5; --bg-preview-page: #ffffff;
            --bg-card: #ffffff; --bg-input: #f9f9f9; --bg-section: #fdfdfd;
            --bg-modal-overlay: rgba(0, 0, 0, 0.6); --bg-inset: #f0f2f5;
            --bg-image-thumb: #eeeeee; --bg-image-upload-hover: #eef5ff;
            --text-primary: #1a1a1a; --text-secondary: #555555; --text-label: #333333;
            --text-placeholder: #999; --text-on-primary: #ffffff; --text-action: #007AFF;
            --border-color: #e8e8e8; --border-input: #d1d5db; --border-dashed: #cccccc;
            --shadow-light: rgba(0, 0, 0, 0); --shadow-medium: rgba(0, 0, 0, 0);
            --preset-text-shadow: none;
            --color-primary: #007AFF; --color-primary-hover: #0056CC; --color-danger: #ff4757;
            --color-danger-hover: #e03c48; --color-secondary: #8e8e93; --color-secondary-hover: #636366;
            --header-height: 55px; --transition-speed: 0.3s; --transition-short: 0.2s;
            --layer-panel-width: 280px; --inspector-panel-width: 380px;
            /* Global Card Styles */
            --g-card-bg-color: var(--bg-card); --g-card-text-color: var(--text-primary); --g-card-opacity: 1;
            --g-card-shadow: none;
            --g-card-border-radius: 12px; --g-card-text-align: left;
            --g-card-line-height: 1.5; --g-card-font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --g-card-font-size: 1rem;
            --g-card-text-stroke: 0px transparent;
            --g-card-border: 1px solid transparent;
            /* Active Card Styles */
            --active-card-shadow: var(--g-card-shadow); --active-card-border: var(--g-card-border);
            --active-card-text-shadow: none; --active-card-font-family: var(--g-card-font-family);
            --active-card-font-size: var(--g-card-font-size); 
        }
        html.dark-mode {
            --bg-editor: #1f2229; --bg-preview-pane: #121417; --bg-preview-page: #1f2229;
            --bg-card: #2c303a; --bg-input: #2c303a; --bg-section: #252830;
            --bg-modal-overlay: rgba(0, 0, 0, 0.7); --bg-inset: #2c2c2e;
            --bg-image-thumb: #3e4451; --bg-image-upload-hover: #2c3e50;
            --text-primary: #f0f2f5; --text-secondary: #a0aec0; --text-label: #e2e8f0;
            --text-placeholder: #777; --text-on-primary: #ffffff; --text-action: #3498db;
            --border-color: #3e4451; --border-input: #4a5160; --border-dashed: #555;
            --shadow-light: rgba(0, 0, 0, 0); --shadow-medium: rgba(0, 0, 0, 0);
            --preset-text-shadow: none;
            --g-card-bg-color: var(--bg-card); --g-card-text-color: var(--text-primary);
            --g-card-shadow: none;
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { font-family: var(--g-card-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif); background-color: var(--bg-preview-pane); color: var(--text-primary); transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        .app-header { width: 100%; height: var(--header-height); background: var(--bg-editor); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; position: fixed; top: 0; left: 0; z-index: 100; box-shadow: 0 2px 8px var(--shadow-light); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        .header-actions-wrapper { display: flex; align-items: center; gap: 15px; }
        .app-header-title { font-size: 1.25rem; font-weight: 700; }
        .theme-switch-wrapper { display: flex; align-items: center; gap: 10px; }
        .theme-switch-wrapper span { font-size: 0.9rem; color: var(--text-secondary); }
        .app-container { display: flex; height: 100vh; padding-top: var(--header-height); }

        .layer-panel, .inspector-panel {
            background: var(--bg-editor);
            height: calc(100vh - var(--header-height));
            overflow-y: auto;
            flex-shrink: 0;
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        .layer-panel {
            width: var(--layer-panel-width);
            border-right: 1px solid var(--border-color);
            padding: 15px;
        }
        .inspector-panel {
            width: var(--inspector-panel-width);
            min-width: 350px;
            max-width: 60vw;
            border-left: 1px solid var(--border-color);
            padding: 25px;
        }
        .resizer {
            width: 5px;
            height: calc(100vh - var(--header-height));
            background: var(--border-color);
            cursor: col-resize;
            z-index: 50;
            flex-shrink: 0;
        }
        .resizer:hover { background: var(--color-primary); }
        .preview-panel {
            flex-grow: 1;
            height: calc(100vh - var(--header-height));
            overflow-y: auto;
            display: flex;
            justify-content: center;
            padding: 40px 20px;
            background: var(--bg-preview-pane);
            transition: background-color var(--transition-speed) ease;
        }
        
        .panel-header {
            font-size: 1.1rem;
            font-weight: 700;
            padding-bottom: 10px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .back-to-global-btn {
            font-size: 0.9rem;
            font-weight: normal;
            color: var(--text-action);
            cursor: pointer;
            background: none;
            border: none;
            padding: 4px 8px;
        }
        .back-to-global-btn:hover { text-decoration: underline; }

        .layer-item-container { margin-bottom: 5px; }
        .layer-list .layer-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: background-color var(--transition-short), border-color var(--transition-short);
        }
        .layer-list .layer-item:hover { background-color: var(--bg-input); }
        .layer-list .layer-item.selected {
            background-color: var(--bg-image-upload-hover);
            border-color: var(--color-primary);
            font-weight: 600;
        }
        .layer-toggle {
            background: none; border: none; cursor: pointer; color: var(--text-secondary);
            width: 20px; height: 20px; padding: 0; font-size: 1.2rem;
            flex-shrink: 0; display: flex; align-items: center; justify-content: center;
            transition: transform var(--transition-short);
        }
        .layer-item-container:not(.is-expandable) .layer-toggle { visibility: hidden; }
        .layer-item-container.is-expanded .layer-toggle { transform: rotate(90deg); }
        .layer-list .layer-item .layer-icon {
            font-size: 1.1em;
            color: var(--text-secondary);
        }
        .layer-list .layer-item .layer-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-left: 4px;
        }
        .layer-actions { display: flex; align-items: center; gap: 4px; }
        .layer-actions .btn-icon {
            width: 26px; height: 26px; padding: 0; font-size: 1.1rem;
            background: none; border: none; color: var(--text-secondary);
        }
        .layer-actions .btn-icon:hover { background: var(--border-color); }
        .layer-item.is-hidden .layer-name, .layer-item.is-hidden .layer-icon { opacity: 0.5; }
        .layer-item.is-hidden .layer-name { text-decoration: line-through; }
        
        .card-layer-list {
            list-style: none; padding-left: 30px; margin: 5px 0; display: none;
        }
        .layer-item-container.is-expanded .card-layer-list { display: block; }
        .card-layer-item {
            font-size: 0.9rem; padding: 6px 8px; border-radius: 4px;
            color: var(--text-secondary); white-space: nowrap; overflow: hidden;
            text-overflow: ellipsis; cursor: pointer; /* Changed to pointer */
        }
        .card-layer-item:hover, .card-layer-item.selected { background-color: var(--bg-input); }
        .card-layer-item.sortable-ghost { background-color: var(--bg-image-upload-hover); }

        .layer-list hr { border: none; border-top: 1px solid var(--border-color); margin: 15px 0; }
        
        .inspector-state { display: none; }
        .inspector-state.active { display: block; animation: fadeIn 0.3s ease; }
        .inspector-placeholder { text-align: center; color: var(--text-placeholder); padding: 40px 10px; font-style: italic; }
        .inspector-placeholder .iconify { font-size: 2rem; margin-bottom: 10px; }

        .preview-block-wrapper.selected, .preview-header.selected {
            outline: 2px solid var(--color-primary);
        }
        .preview-block-wrapper.is-hidden { display: none; }
        
        body.export-mode .preview-panel { justify-content: flex-start; }
        .preview-wrapper { width: 100%; max-width: 600px; min-height: fit-content; border-radius: 20px; box-shadow: 0 4px 16px var(--shadow-medium); padding: 20px; padding-bottom: 40px; transition: all var(--transition-speed) ease; position: relative; overflow: hidden; font-family: var(--active-card-font-family); font-size: var(--active-card-font-size); }
        .preview-wrapper::before { content: none; }
        .preview-overlay { display: none; }
        .preview-header, .preview-blocks-container { position: relative; z-index: 2; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box; }
        [data-state-key]:hover, [data-card-key]:hover, [data-separator-text-key]:hover, .tag-pill:hover { outline: 1px dashed var(--color-primary); cursor: text; }
        [contenteditable="true"] { outline: 2px solid var(--color-primary); box-shadow: 0 0 8px rgba(0, 122, 255, 0.5); background-color: rgba(0, 122, 255, 0.1); border-radius: 4px; }
        .btn { display: inline-block; border: none; padding: 10px 16px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: background-color var(--transition-short) ease, transform var(--transition-short) ease, box-shadow var(--transition-short) ease; text-align: center; width: 100%; color: var(--text-on-primary); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .btn-primary { background: var(--color-primary); } .btn-primary:hover:not(:disabled) { background: var(--color-primary-hover); box-shadow: 0 4px 8px rgba(0,122,255,0.3); }
        .btn-secondary { background: var(--color-secondary); } .btn-secondary:hover:not(:disabled) { background: var(--color-secondary-hover); box-shadow: 0 4px 8px rgba(142,142,147,0.3); }
        .btn-danger { background: var(--color-danger); } .btn-danger:hover:not(:disabled) { background: var(--color-danger-hover); box-shadow: 0 4px 8px rgba(255,71,87,0.3); }
        .btn-default { background-color: var(--bg-input); border: 1px solid var(--border-input); color: var(--text-secondary); } .btn-default:hover:not(:disabled) { background-color: var(--border-color); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .btn:active:not(:disabled) { transform: scale(0.98); } .btn:disabled { background: #999; cursor: not-allowed; opacity: 0.6; }
        .btn-small { padding: 6px 10px; font-size: 0.9rem; }
        .btn-icon { width: auto; padding: 6px 10px; font-size: 0.9rem; display: flex; align-items: center; justify-content: center; }
        .editor-section { width: 100%; background: var(--bg-section); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; margin-bottom: 15px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; box-shadow: 0 2px 8px var(--shadow-light); }
        .editor-section legend { font-size: 1.1rem; font-weight: 700; color: var(--text-primary); margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); width: 100%; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .editor-section legend::after { content: " â–¼"; font-size: 0.8rem; }
        .editor-section.collapsed legend::after { content: " â–¶"; }
        .editor-section.collapsed .section-content { display: none; }
        .section-content { padding-top: 15px; }

        .advanced-toggle-label { font-size: 0.85rem; font-weight: normal; color: var(--text-action); }
        .advanced-setting { display: none; }
        .show-advanced .advanced-setting { display: block; animation: fadeIn 0.3s; }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .section-header h4 { margin: 0; }

        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-size: 0.9rem; font-weight: 600; color: var(--text-label); margin-bottom: 8px; }
        .form-group input[type="text"], .form-group input[type="number"], .form-group input[type="file"], .form-group select, .form-group textarea { width: 100%; padding: 10px; font-size: 14px; background: var(--bg-input); border: 1px solid var(--border-input); border-radius: 6px; color: var(--text-primary); transition: all var(--transition-short) ease; max-width: 100%; overflow-wrap: break-word; }
        .form-group input[type="text"]:focus, .form-group input[type="number"]:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2); }
        .form-group textarea { min-height: 80px; resize: vertical; }
        .input-group { display: flex; align-items: center; gap: 0; border: 1px solid var(--border-input); border-radius: 6px; overflow: hidden;}
        .input-group:focus-within { border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2); }
        .input-group.simple { border: none; border-radius: 0; gap: 10px; } .input-group.simple:focus-within { box-shadow: none; }
        .input-group input[type="color"] { flex-shrink: 0; width: 40px; height: 38px; border: none; background: transparent; cursor: pointer; }
        .input-group input[type="text"].color-hex-input { flex-grow: 1; border: none; border-left: 1px solid var(--border-input); border-radius: 0; padding-left: 10px; background-color: var(--bg-input); color: var(--text-primary); }
        .input-group input[type="text"].color-hex-input:focus { outline: none; box-shadow: none; }
        .input-group input[type="range"] { flex-grow: 1; height: 20px; cursor: pointer; min-width: 100px; }
        .radio-group { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; background: var(--bg-input); border: 1px solid var(--border-input); border-radius: 6px; padding: 10px; }
        .radio-group label { margin: 0; font-weight: normal; display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.9rem; }
        .color-control-row { display: flex; flex-wrap: wrap; gap: 15px; align-items: flex-start; min-width: 0; }
        .color-control-group { flex: 1; min-width: 150px; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer; }
        .checkbox-group label { display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer; margin: 0; }
        .checkbox-group input[type="checkbox"] { width: auto; height: auto; }
        hr.separator { border: none; border-top: 1px solid var(--border-color); margin: 20px 0; }
        .tabs { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 15px; }
        .tab-btn { padding: 8px 12px; cursor: pointer; border: none; background: none; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid transparent; }
        .tab-btn.active { color: var(--text-primary); border-bottom-color: var(--color-primary); }
        .tab-content { display: none; } .tab-content.active { display: block; }
        .gradient-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .gradient-angle-control { grid-column: 1 / -1; }
        .preview-header { padding: 30px 15px; text-align: center; border-radius: 16px; transition: all var(--transition-speed) ease; overflow-wrap: break-word; }
        #preview-avatar { width: 90px; height: 90px; border: 4px solid var(--bg-preview-page); box-shadow: 0 4px 12px var(--shadow-light); object-fit: cover; background-color: #fff; transition: all var(--transition-speed) ease; }
        #preview-nickname { margin: 12px 0 5px; font-size: 1.6rem; font-weight: 700; color: var(--text-primary); transition: color var(--transition-speed) ease; }
        #preview-subtitle { margin: 0 0 8px; font-size: 1rem; font-weight: 400; color: var(--text-primary); opacity: 0.7; transition: color var(--transition-speed) ease, margin var(--transition-speed) ease; }
        #preview-bio { margin: 0; font-size: 0.9rem; line-height: 1.4; color: var(--text-primary); opacity: 0.8; transition: color var(--transition-speed) ease; white-space: pre-wrap; }
        #preview-subtitle:empty, #preview-bio:empty { display: none; }
        .tags-container { margin-top: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
        .tag-pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 12px; font-size: 0.8rem; font-weight: 600; border-radius: 16px; transition: all var(--transition-speed) ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .editor-block { background: var(--bg-editor); border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px var(--shadow-light); transition: all var(--transition-speed) ease; opacity: 1; transform: scale(1); }
        .sortable-ghost { background: var(--bg-image-upload-hover) !important; border: 2px dashed var(--color-primary); box-shadow: none !important; opacity: 0.8 !important; }
        .editor-block.sortable-chosen { box-shadow: 0 4px 12px var(--shadow-medium); transform: scale(1.02); }
        .editor-block-header { display: flex; align-items: center; padding: 0 10px; background: var(--bg-section); border-bottom: 1px solid var(--border-color); border-radius: 8px 8px 0 0; }
        .block-drag-handle { font-size: 1.5rem; color: var(--text-placeholder); padding: 10px; cursor: grab; flex-shrink: 0; }
        .block-drag-handle:active { cursor: grabbing; }
        .editor-block-title-input { font-weight: 600; color: var(--text-primary); margin: 0; flex-grow: 1; padding: 10px; border: 1px solid transparent; background: transparent; font-size: 1em; min-width: 0; overflow-wrap: break-word; border-radius: 4px; }
        .editor-block-title-input:hover { border-color: var(--border-input); }
        .editor-block-title-input:focus { outline: 1px solid var(--color-primary); background: var(--bg-input); border-color: var(--color-primary); }
        .block-actions { display: flex; align-items: center; gap: 5px; margin-left: auto; flex-shrink: 0; }
        .up-down-btns { display: flex; gap: 2px; }
        .up-down-btns button { font-size: 1rem; width: 28px; height: 28px; padding: 0; line-height: 28px; }
        .block-settings { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding-left: 10px; flex-shrink: 0; }
        .block-settings label { font-size: 0.9rem; margin: 0; color: var(--text-secondary); cursor: pointer; }
        .block-delete-btn { width: auto; padding: 6px 10px; font-size: 0.9rem; flex-shrink: 0; }
        .editor-block-content { padding: 15px; overflow-x: hidden; }
        .card-editors-list .empty-placeholder, .image-card-editors-list .empty-placeholder { text-align: center; padding: 15px; color: var(--text-placeholder); font-size: 0.9rem; }
        .editor-card { background: var(--bg-section); border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 15px; position: relative; padding-left: 40px; opacity: 1; transform: scale(1); }
        .editor-card.sortable-chosen { box-shadow: 0 3px 8px var(--shadow-medium); transform: scale(1.01); }
        .editor-card.is-active { border-color: var(--color-primary); background-color: var(--bg-image-upload-hover); }
        .card-drag-handle { position: absolute; top: 0; left: 0; bottom: 0; width: 40px; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; color: var(--text-placeholder); cursor: grab; border-right: 1px solid var(--border-color); }
        .card-drag-handle:active { cursor: grabbing; }
        .editor-card-header { display: flex; justify-content: flex-end; padding: 8px 10px; border-bottom: 1px solid var(--border-color); }
        .card-delete-btn { width: auto; padding: 4px 8px; font-size: 0.8rem; }
        .editor-card-content { padding: 15px; }
        .card-bg-control { display: flex; align-items: center; gap: 10px; }
        .card-bg-control input[type="file"] { flex-grow: 1; }
        .card-overlay-controls { border: 1px solid var(--border-input); border-radius: 6px; padding: 10px; margin-top: 10px; background: var(--bg-input); }
        .card-style-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
        .image-card-editor-content { display: flex; gap: 15px; align-items: flex-start; }
        .image-card-editor-thumb { flex-shrink: 0; width: 80px; }
        .image-card-editor-fields { flex-grow: 1; }
        .thumbnail-wrapper { position: relative; width: 100%; padding-top: 100%; background: var(--bg-image-thumb); border-radius: 6px; overflow: hidden; transition: all var(--transition-short) ease; }
        .thumbnail-wrapper img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transition: transform var(--transition-short) ease; }
        .thumbnail-wrapper:hover { transform: scale(1.05); }
        .thumbnail-wrapper:hover img { transform: scale(1.05); }
        .thumbnail-actions { position: absolute; top: 3px; right: 3px; display: flex; gap: 4px; opacity: 0; transition: opacity var(--transition-short) ease; }
        .thumbnail-wrapper:hover .thumbnail-actions { opacity: 1; }
        .thumbnail-actions .btn { width: 24px; height: 24px; padding: 0; font-size: 0.8rem; line-height: 24px; border-radius: 50%; background: rgba(0,0,0,0.6); color: white; border: none; }
        .thumbnail-actions .btn:hover { background: rgba(0,0,0,0.8); }
        .preview-blocks-container { margin-top: 20px; display: flex; flex-direction: column; gap: 20px; width: 100%; box-sizing: border-box; }
        .preview-blocks-container.locked-mode * { cursor: default !important; pointer-events: none !important; }
        #preview-blocks-container .empty-placeholder { text-align: center; padding: 50px 0; color: var(--text-placeholder); }
        .preview-block-wrapper.sortable-drag { opacity: 1 !important; }
        .preview-block-wrapper { cursor: pointer; }
        .preview-cards-container { width: 100%; }
        .preview-cards-single { display: flex; flex-direction: column; gap: 15px; }
        .preview-cards-dual { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .preview-cards-triple { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .masonry-active { display: block; position: relative; } /* Override grid */
        .masonry-active.preview-cards-dual .preview-card, .masonry-active.preview-cards-dual figure { width: calc(50% - 7.5px); margin-bottom: 15px; }
        .masonry-active.preview-cards-triple .preview-card, .masonry-active.preview-cards-triple figure { width: calc(33.333% - 10px); margin-bottom: 15px; }
        .preview-card { box-sizing: border-box; width: 100%; view-transition-name: var(--card-transition-name); }
        .preview-card-inner { width: 100%; height: 100%; box-sizing: border-box; position: relative; overflow: hidden; color: var(--card-text-color, var(--g-card-text-color)); border-radius: var(--g-card-border-radius); box-shadow: var(--active-card-shadow, none); border: var(--active-card-border, none); font-weight: var(--card-font-weight, normal); text-shadow: var(--active-card-text-shadow, none); padding: 15px; word-wrap: break-word; transition: all var(--transition-short) ease; -webkit-text-stroke: var(--g-card-text-stroke); line-height: var(--g-card-line-height); background-clip: padding-box; }
        .preview-card-inner::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 0; background-size: cover; background-position: center; border-radius: inherit; background: var(--card-bg-final); transition: background var(--transition-speed) ease; }
        .preview-card-inner::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--card-overlay-color, transparent); opacity: var(--card-overlay-opacity, 0); border-radius: inherit; z-index: 1; pointer-events: none; transition: all var(--transition-short) ease; }
        .preview-card:hover .preview-card-inner { transform: scale(1.02); box-shadow: 0 6px 16px var(--shadow-medium); }
        .preview-card.adding, figure.adding { animation: fadeInScale 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .preview-card.removing, figure.removing { animation: fadeOutScale 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .preview-card-title, .preview-card-content { position: relative; z-index: 2; margin: 0; word-wrap: break-word; overflow-wrap: break-word; color: inherit; }
        .preview-card-title { font-size: 1.1em; font-weight: inherit; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        .preview-card-title .iconify, .tag-pill .iconify { font-size: 1.1em; line-height: 1; vertical-align: middle; }
        .preview-card-content { font-size: 0.95em; line-height: inherit; white-space: pre-wrap; }
        .preview-cards-container figure { margin: 0; display: flex; flex-direction: column; transition: transform 0.3s ease; }
        .preview-cards-container figure img { width: 100%; display: block; border-radius: 8px; height: auto; max-width: 100%; transition: transform 0.3s ease; }
        .preview-cards-container figure:hover img { transform: scale(1.05); }
        .preview-cards-container figure figcaption { text-align: center; margin-top: 8px; padding: 5px; overflow-wrap: break-word; color: var(--g-card-text-color); border-radius: 8px; }
        .preview-cards-container figure figcaption strong { display: block; font-weight: 600; margin-bottom: 3px; }
        .separator-preview { display: flex; align-items: center; justify-content: center; }
        .separator-preview-line { flex-grow: 1; height: 1px; }
        .spacer-preview { transition: height 0.3s ease; }
        .font-controls { display: flex; flex-direction: column; gap: 8px; margin-top: 8px; align-items: stretch; }
        .font-controls select { width: 100%; }
        .font-controls .buttons { display: flex; gap: 10px; }
        .font-controls .buttons .btn { flex-grow: 1; padding: 8px 12px; font-size: 13px; width: auto; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-modal-overlay); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility 0s var(--transition-speed) ease; backdrop-filter: blur(5px); pointer-events: none; }
        .modal-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; pointer-events: auto; }
        .modal-container { background: var(--bg-editor); border-radius: 16px; box-shadow: 0 10px 30px var(--shadow-medium); padding: 25px; width: 90%; max-width: 500px; border: 1px solid var(--border-color); transform: scale(0.95); opacity: 0; transition: all var(--transition-speed) ease; }
        .modal-overlay.visible .modal-container { transform: scale(1); opacity: 1; }
        .modal-container h3 { margin-top: 0; margin-bottom: 20px; font-size: 1.25rem; color: var(--text-primary); }
        .cropper-img-container { width: 100%; height: 300px; margin-bottom: 20px; background: var(--bg-input); border-radius: 8px; overflow: hidden; }
        .cropper-img-container img { max-width: 100%; }
        .modal-actions { display: flex; gap: 15px; justify-content: flex-end; margin-top: 15px; }
        .modal-actions .btn { width: auto; min-width: 100px; }
        #download-modal-content { text-align: center; }
        #download-modal-content img { max-width: 100%; max-height: 50vh; border-radius: 8px; border: 1px solid var(--border-color); margin-bottom: 15px; }
        #download-modal-content a { display: block; background: var(--color-primary); color: white; text-decoration: none; padding: 12px 20px; border-radius: 8px; font-size: 1rem; font-weight: 600; margin-bottom: 20px; transition: background-color var(--transition-short) ease; }
        #download-modal-content a:hover { background-color: var(--color-primary-hover); }
        .crop-ratios { margin-bottom: 15px; }
        .crop-ratios label { margin-right: 10px; font-size: 0.9rem; cursor: pointer; }
        .error-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--bg-editor); color: var(--text-primary); padding: 25px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.3); z-index: 2000; max-width: 90%; width: 450px; border: 1px solid var(--border-color); }
        .error-modal h3 { color: var(--color-danger); margin-top: 0; }
        .error-modal p { margin: 10px 0; font-size: 0.95rem; }
        .error-modal .btn { margin-top: 15px; float: right; }
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; font-size: 1.2rem; backdrop-filter: blur(5px); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s 0.3s; pointer-events: none; }
        #loading-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; pointer-events: auto; }
        .spinner { width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--color-primary); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        .toast-notification-container { position: fixed; bottom: 20px; right: 20px; z-index: 9999; display: flex; flex-direction: column; gap: 10px; }
        .toast-notification { background-color: var(--bg-card); color: var(--text-primary); padding: 12px 18px; border-radius: 8px; box-shadow: 0 4px 12px var(--shadow-medium); border: 1px solid var(--border-color); opacity: 0; transform: translateX(100%); animation: toast-in 0.5s forwards, toast-out 0.5s 4.5s forwards; font-size: 0.9rem; }
        .toast-notification.success { border-left: 4px solid #2ecc71; }
        .toast-notification.error { border-left: 4px solid var(--color-danger); }
        .toast-notification.info { border-left: 4px solid var(--color-primary); }
        #icon-picker-modal .modal-container, #texture-picker-modal .modal-container { max-width: 700px; }
        #icon-grid, #texture-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 10px; max-height: 50vh; overflow-y: auto; padding: 10px; border: 1px solid var(--border-input); border-radius: 8px; background: var(--bg-input); }
        #texture-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
        .icon-grid-item { display: flex; align-items: center; justify-content: center; height: 50px; font-size: 1.5rem; color: var(--text-primary); border-radius: 6px; cursor: pointer; transition: background-color var(--transition-short); position: relative; }
        .icon-grid-item:hover, .texture-grid-item:hover { background-color: var(--border-color); }
        .icon-grid-item .delete-custom-icon-btn { position: absolute; top: 2px; right: 2px; width: 18px; height: 18px; padding: 0; font-size: 0.7rem; line-height: 18px; border-radius: 50%; display: none; }
        .icon-grid-item:hover .delete-custom-icon-btn { display: flex; }
        .texture-grid-item { display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 6px; cursor: pointer; transition: background-color var(--transition-short); padding: 5px; }
        .texture-preview { width: 100%; height: 80px; border: 1px solid var(--border-color); border-radius: 4px; background-size: 20px; }
        .texture-name { font-size: 0.75rem; margin-top: 5px; color: var(--text-secondary); text-align: center; }
        #tag-manager-list { display: flex; flex-direction: column; gap: 10px; max-height: 250px; overflow-y: auto; padding: 10px; border: 1px solid var(--border-input); border-radius: 6px; background-color: var(--bg-input); margin-bottom: 15px; }
        .tag-manager-item { display: flex; align-items: center; gap: 8px; background-color: var(--bg-section); padding: 8px; border-radius: 4px; border: 1px solid var(--border-color); cursor: grab; }
        .tag-manager-item .tag-icon-btn { flex-shrink: 0; width: 32px; height: 32px; padding: 0; font-size: 1.2rem; cursor: pointer; }
        .tag-manager-item .tag-text-input { flex-grow: 1; border: none; background: transparent; padding: 4px 6px; cursor: text; }
        .tag-manager-item .tag-delete-btn { flex-shrink: 0; width: 32px; height: 32px; padding: 0; cursor: pointer; }
        .empty-tag-list { text-align: center; color: var(--text-placeholder); padding: 20px 0; }
        .inset-controls { border: 1px solid var(--border-input); border-radius: 6px; padding: 15px; margin-top: 10px; background: var(--bg-input); }
        #help-modal .tab-content { max-height: 60vh; overflow-y: auto; padding: 15px; }
        #help-thanks .thanks-item { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        #help-thanks .thanks-item:last-child { border-bottom: none; }
        #help-thanks h4 { margin-top: 0; margin-bottom: 8px; }
        #help-thanks p { margin: 4px 0; }
        #help-thanks details { margin-top: 10px; }
        #help-thanks summary { cursor: pointer; font-weight: 600; color: var(--text-action); }
        #help-thanks pre { white-space: pre-wrap; word-wrap: break-word; background: var(--bg-input); padding: 10px; border-radius: 6px; font-size: 0.8rem; max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); }
        
        .palette-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(40px, 1fr)); gap: 10px; margin-top: 10px; }
        .palette-color { width: 100%; padding-top: 100%; border-radius: 8px; cursor: pointer; border: 2px solid var(--border-color); transition: transform var(--transition-short); position: relative; }
        .palette-color:hover { transform: scale(1.1); }
        .color-tooltip { position: absolute; bottom: 110%; left: 50%; transform: translateX(-50%); background: var(--bg-card); color: var(--text-primary); padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; white-space: nowrap; box-shadow: var(--shadow-medium); opacity: 0; visibility: hidden; transition: opacity var(--transition-short); }
        .palette-color:hover .color-tooltip { opacity: 1; visibility: visible; }
        #color-context-menu { position: fixed; z-index: 10000; background: var(--bg-editor); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: var(--shadow-medium); padding: 5px; display: none; min-width: 180px;}
        #color-context-menu ul { list-style: none; margin: 0; padding: 0; }
        #color-context-menu li { padding: 8px 12px; cursor: pointer; border-radius: 4px; font-size: 0.9rem; }
        #color-context-menu li:hover { background: var(--bg-input); }
        #color-context-menu hr { border: none; border-top: 1px solid var(--border-color); margin: 4px 0; }
        
        @keyframes toast-in { to { opacity: 1; transform: translateX(0); } }
        @keyframes toast-out { to { opacity: 0; transform: translateX(100%); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInScale { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        @keyframes fadeOutScale { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.9); } }
        .preview-header { animation: fadeIn 0.4s ease forwards; }
        
        #mobile-layer-toggle, #mobile-inspector-toggle { display: none; }

        @media (max-width: 1024px) {
            .app-header-title { display: none; } 
            #mobile-layer-toggle, #mobile-inspector-toggle { display: block; z-index: 201; }
            .resizer { display: none; }
            .layer-panel, .inspector-panel {
                position: fixed; top: var(--header-height);
                width: 85%; max-width: 350px;
                height: calc(100vh - var(--header-height)); z-index: 200;
                transition: transform 0.3s ease-in-out;
                overflow-x: hidden;
            }
            .layer-panel { left: 0; transform: translateX(-100%); border-right: 1px solid var(--border-color); }
            .inspector-panel { right: 0; transform: translateX(100%); border-left: 1px solid var(--border-color); }
            .layer-panel.is-open, .inspector-panel.is-open { transform: translateX(0); }

            .preview-panel { width: 100%; padding: 20px 10px; }
            body.panels-open::after {
                content: ''; position: fixed; top: var(--header-height); left: 0; width: 100%;
                height: calc(100vh - var(--header-height)); background: rgba(0,0,0,0.4); z-index: 199;
                opacity: 1; pointer-events: auto; transition: opacity 0.3s ease-in-out;
            }
            .color-control-row, .gradient-controls { flex-direction: column; gap: 10px; }
            .gradient-controls { grid-template-columns: 1fr; }
            .color-control-group { width: 100%; min-width: 0; }
        }
    </style>
</head>
<body>

    <header class="app-header">
        <button id="mobile-layer-toggle" class="btn btn-default btn-icon" style="width: auto; padding: 6px 12px;"><span class="iconify" data-icon="mdi:layers-outline"></span> å†…å®¹</button>
        <div class="app-header-title">Blokko (v1.5.2)</div>
        <div class="header-actions-wrapper">
            <button id="lock-mode-toggle" class="btn btn-default" style="width: auto; padding: 6px 12px;" title="åˆ‡æ¢ç¼–è¾‘/é¢„è§ˆæ¨¡å¼">ç¼–è¾‘ä¸­</button>
            <button id="show-help-btn" class="btn btn-default btn-icon" style="width: auto; padding: 6px 12px;"><span class="iconify" data-icon="mdi:help-circle-outline"></span> å¸®åŠ©</button>
            <div class="theme-switch-wrapper">
                <span id="theme-label">æ˜äº®æ¨¡å¼</span>
                <button id="theme-toggle-btn" class="btn btn-default" style="width: auto; padding: 6px 12px;">åˆ‡æ¢</button>
            </div>
            <button id="mobile-inspector-toggle" class="btn btn-default btn-icon" style="width: auto; padding: 6px 12px;"><span class="iconify" data-icon="mdi:pencil-ruler"></span> æ ·å¼</button>
        </div>
    </header>

    <div class="app-container">
        <aside class="layer-panel" id="layer-panel">
            <h3 class="panel-header">å†…å®¹å›¾å±‚</h3>
            <div class="layer-list" id="layer-list">
                <!-- Layer items will be dynamically inserted here -->
            </div>
            <hr>
            <div class="form-group" style="display: flex; flex-wrap: wrap; gap: 10px;">
                <button id="add-text-block-btn" class="btn btn-default">â• æ–‡æœ¬</button>
                <button id="add-image-block-btn" class="btn btn-default">ğŸ–¼ï¸ å›¾ç‰‡</button>
                <button id="add-separator-block-btn" class="btn btn-default">ã€°ï¸ åˆ†éš”</button>
                <button id="add-spacer-block-btn" class="btn btn-default">âµ ç•™ç™½</button>
            </div>
        </aside>

        <main class="preview-panel" id="preview-panel">
            <div class="preview-wrapper" id="preview-wrapper">
                <div class="preview-overlay" id="preview-overlay"></div>
                <header class="preview-header" id="preview-header">
                    <img id="preview-avatar" src="" alt="Avatar">
                    <h1 id="preview-nickname" data-state-key="personalInfo.nickname"></h1>
                    <h2 id="preview-subtitle" data-state-key="personalInfo.subtitle"></h2>
                    <p id="preview-bio" data-state-key="personalInfo.bio"></p>
                    <div class="tags-container" id="preview-tags-container"></div>
                </header>
                <main class="preview-blocks-container" id="preview-blocks-container"></main>
            </div>
        </main>
        
        <div class="resizer" id="resizer"></div>

        <aside class="inspector-panel" id="inspector-panel">
            <!-- Inspector content will be dynamically inserted here -->
        </aside>
    </div>

    <div class="modal-overlay" id="cropper-modal"><div class="modal-container"><h3 id="cropper-title">è£å‰ªå›¾ç‰‡</h3><div class="crop-ratios radio-group"><label><input type="radio" name="crop-ratio" value="NaN" checked> è‡ªç”±</label><label><input type="radio" name="crop-ratio" value="1"> 1:1</label><label><input type="radio" name="crop-ratio" value="1.3333"> 4:3</label><label><input type="radio" name="crop-ratio" value="1.7777"> 16:9</label></div><div class="cropper-img-container"><img id="cropper-image" src=""></div><div class="modal-actions"><button id="cropper-cancel-btn" class="btn btn-default">å–æ¶ˆ</button><button id="cropper-save-btn" class="btn btn-primary">ç¡®è®¤</button></div></div></div>
    <div class="modal-overlay" id="download-modal"><div class="modal-container"><h3 id="download-modal-title">ä¸‹è½½å·²å‡†å¤‡å¥½</h3><div id="download-modal-content"></div><div class="modal-actions" style="justify-content: center;"><button id="download-modal-close-btn" class="btn btn-default">å…³é—­</button></div></div></div>
    
    <div class="modal-overlay" id="confirm-modal">
        <div class="modal-container">
            <h3 id="confirm-modal-title">è¯·ç¡®è®¤</h3>
            <p id="confirm-modal-message" style="margin: 15px 0;"></p>
            <div class="modal-actions">
                <button id="confirm-modal-cancel-btn" class="btn btn-default">å–æ¶ˆ</button>
                <button id="confirm-modal-ok-btn" class="btn btn-primary">ç¡®è®¤</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="help-modal">
        <div class="modal-container" style="max-width: 700px;">
            <div class="tabs">
                <button class="tab-btn" data-tab="help-tutorial">æ–°æ‰‹æ•™ç¨‹</button>
                <button class="tab-btn active" data-tab="help-instructions">ä½¿ç”¨è¯´æ˜</button>
                <button class="tab-btn" data-tab="help-changelog">æ›´æ–°æ—¥å¿—</button>
                <button class="tab-btn" data-tab="help-thanks">æ„Ÿè°¢ä¿¡æ¯</button>
                <button class="tab-btn" data-tab="help-about">å…³äº</button>
            </div>
            <div id="help-tutorial" class="tab-content">
                <h4>æ¬¢è¿æ¥åˆ° Blokkoï¼âœ¨</h4>
                <p>åˆ«æ‹…å¿ƒï¼Œè¿™ä¸ªå°æ•™ç¨‹å°†å¸¦ä½ å¿«é€Ÿä¸Šæ‰‹ï¼Œæ•´ä¸ªè¿‡ç¨‹åªéœ€ä¸€åˆ†é’Ÿï¼å½“ç„¶å¦‚æœä½ æœ‰ç±»ä¼¼å·¥å…·ä½¿ç”¨ç»éªŒï¼Œæˆ–æ˜¯å·²ç»ç†Ÿç»ƒä½¿ç”¨çš„è¯ï¼Œçœ‹å®Œé‡è¦æç¤ºï¼Œå°±æ”¾å¿ƒå…³æ‰å§!</p>
                
                <h4>âš ï¸ å…³äºç‰ˆæƒçš„é‡è¦æç¤º</h4>
                <p><strong>Blokko æ˜¯ä¸€ä¸ªå®Œå…¨å…è´¹çš„æœ¬åœ°åˆ›ä½œå·¥å…·ã€‚å½“æ‚¨ä½¿ç”¨â€œä¸Šä¼ å­—ä½“â€ã€â€œä¸Šä¼ å›¾ç‰‡/å›¾æ ‡â€åŠŸèƒ½æ—¶ï¼Œæ‚¨éœ€è¦å¯¹è¿™äº›ç´ æè´Ÿè´£ã€‚è¯·ç¡®ä¿æ‚¨ä¸Šä¼ å’Œä½¿ç”¨çš„ä»»ä½•æ–‡ä»¶éƒ½å·²è·å¾—äº†åŸç‰ˆæƒæ–¹çš„åˆæ³•æˆæƒï¼Œæˆ–ä½¿ç”¨æ— ç‰ˆæƒå¯å•†ç”¨ç´ æã€‚</strong></p>
                <p><strong>å› ä½¿ç”¨æœªæˆæƒç´ æè€Œäº§ç”Ÿçš„ä»»ä½•ç‰ˆæƒé—®é¢˜ï¼Œå°†ç”±æ‚¨è‡ªè¡Œæ‰¿æ‹…ã€‚æ¢è¨€ä¹‹ï¼Œè‡ªå·±ä¸Šä¼ ç´ æï¼Œä¸€å®šè¦æ³¨æ„ç‰ˆæƒä¿¡æ¯å“¦ï¼</strong></p>
                
                <h4>å†™åœ¨æ­£å¼å¼€å§‹å‰</h4>
                <p>Blokko æ˜¯ä¸€ä¸ªå…è´¹çš„å·¥å…·ï¼Œè®¾è®¡ä¹‹åˆæ˜¯ä¸ºäº†ç”µè„‘ç«¯ç¼–è¾‘ä½¿ç”¨çš„ï¼Œå»ºè®®ä½¿ç”¨PCç«¯çš„Edgeæµè§ˆå™¨å’ŒChromeæµè§ˆå™¨æ¥ä½¿ç”¨ä½“éªŒæœ€ä½³ï¼Œç§»åŠ¨ç«¯ä¹Ÿåšäº†åŸºç¡€çš„é€‚é…ï¼Œç«–å±çŠ¶æ€ä¸‹å»ºè®®ä½¿ç”¨viaæµè§ˆå™¨ï¼Œå¹¶å¼€å¯å…¨å±æ¨¡å¼ä½¿ç”¨ã€‚</p>
                
                <h4>ç¬¬ä¸€æ­¥ï¼šæ ¸å¿ƒæŠ€å·§ - åŒå‡»ç¼–è¾‘ï¼</h4>
                <p>Blokko æœ€ä¾¿æ·çš„æ“ä½œå°±æ˜¯â€œåŒå‡»â€ã€‚é¢„è§ˆåŒºåŸŸé‡Œä½ çœ‹åˆ°çš„æ‰€æœ‰æ–‡å­—ï¼ˆæ¯”å¦‚æ˜µç§°ã€ç®€ä»‹ã€å¡ç‰‡æ ‡é¢˜å’Œå†…å®¹ï¼‰ï¼Œç›´æ¥åŒå‡»å®ƒä»¬ï¼Œå°±å¯ä»¥ç«‹åˆ»å¼€å§‹ç¼–è¾‘ï¼Œéå¸¸æ–¹ä¾¿ï¼ï¼ˆéœ€è¦æŠŠæœ€ä¸Šæ–¹æŒ‰é’®åˆ‡æ¢æˆâ€œç¼–è¾‘ä¸­â€çŠ¶æ€å“¦ï¼‰</p>
                
                <h4>ç¬¬äºŒæ­¥ï¼šè°ƒæ•´ä½ çš„ä¸ªäººä¿¡æ¯</h4>
                <p>åœ¨å·¦ä¾§çš„ â€œå†…å®¹å›¾å±‚â€ é¢æ¿ï¼Œç‚¹å‡» â€œğŸ‘¤ ä¸ªäººä¿¡æ¯â€ å›¾å±‚ï¼Œå³ä¾§çš„ â€œæ ·å¼æ£€æŸ¥å™¨â€ å°±ä¼šæ˜¾ç¤ºå‡ºæ‰€æœ‰ç›¸å…³è®¾ç½®ï¼Œä½ å¯ä»¥åœ¨é‚£é‡Œä¸Šä¼ å¤´åƒã€ä¿®æ”¹æ˜µç§°ã€æ·»åŠ æ ‡ç­¾ç­‰ã€‚</p>
                
                <h4>ç¬¬ä¸‰æ­¥ï¼šæ·»åŠ å’Œç®¡ç†å†…å®¹</h4>
                <p>åœ¨å·¦ä¸‹è§’çš„ â€œâ•â€ æŒ‰é’®å¯ä»¥æ·»åŠ ä¸åŒç±»å‹çš„å±•ç¤ºæ¨¡å—ã€‚åœ¨ â€œå†…å®¹å›¾å±‚â€ é¢æ¿ï¼Œä½ å¯ä»¥é€šè¿‡æ‹–æ‹½æ¥æ’åºæ‰€æœ‰åŒºå—ã€‚</p>
                
                <h4>ç¬¬å››æ­¥ï¼šç¾åŒ–ä¸å¯¼å‡º</h4>
                <p>å½“ä½ å¯¹å†…å®¹æ»¡æ„åï¼Œå¯ä»¥ç‚¹å‡»ä¸åŒçš„å›¾å±‚æ¥è°ƒæ•´æ ·å¼ï¼Œæˆ–è€…åœ¨æœªé€‰ä¸­ä»»ä½•å›¾å±‚æ—¶ï¼Œåœ¨å³ä¾§é¢æ¿è°ƒæ•´å…¨å±€æ ·å¼ã€‚å…¨éƒ¨å®Œæˆåï¼Œåœ¨å³ä¾§é¢æ¿çš„ â€œå…¨å±€ä¸å¯¼å‡ºâ€ è®¾ç½®ä¸­ï¼Œæ»‘åˆ°æœ€ä¸‹æ–¹ï¼Œç‚¹å‡» â€œå¯¼å‡ºä¸ºå›¾ç‰‡â€ æŒ‰é’®ï¼Œå°±å¯ä»¥ä¿å­˜ä½ çš„æ°ä½œå•¦ï¼</p>
            </div>
            <div id="help-instructions" class="tab-content active">
                <h4>æ¬¢è¿ä½¿ç”¨ Blokkoï¼</h4>
                <p><strong><span class="iconify" data-icon="mdi:cursor-default-click-outline" style="vertical-align: -0.2em;"></span> åŒå‡»ç¼–è¾‘ï¼š</strong> é¢„è§ˆåŒºåŸŸçš„å¤§éƒ¨åˆ†æ–‡æœ¬å†…å®¹ï¼ˆå¦‚æ˜µç§°ã€ç®€ä»‹ã€å¡ç‰‡æ ‡é¢˜å’Œå†…å®¹ï¼‰éƒ½å¯ä»¥é€šè¿‡åŒå‡»ç›´æ¥è¿›è¡Œç¼–è¾‘ã€‚</p>
                <p><strong><span class="iconify" data-icon="mdi:drag" style="vertical-align: -0.2em;"></span> æ‹–æ‹½æ’åºï¼š</strong> åœ¨å·¦ä¾§â€œå†…å®¹å›¾å±‚â€é¢æ¿ï¼Œä½ å¯ä»¥æ‹–åŠ¨å›¾å±‚æ¥è¿›è¡Œæ’åºã€‚</p>
                <p><strong><span class="iconify" data-icon="mdi:view-dashboard-variant-outline" style="vertical-align: -0.2em;"></span> ç€‘å¸ƒæµå¸ƒå±€ï¼š</strong> å¯¹äºå¤šåˆ—åŒºå—ï¼ˆåŒæ’/ä¸‰æ’ï¼‰ï¼Œå¯ä»¥åœ¨å³ä¾§æ£€æŸ¥å™¨ä¸­å‹¾é€‰â€œå¯ç”¨ç€‘å¸ƒæµâ€ï¼Œä½¿å¡ç‰‡/å›¾ç‰‡é«˜åº¦è‡ªé€‚åº”ï¼Œå¸ƒå±€æ›´ç´§å‡‘ã€‚</p>
                <p><strong><span class="iconify" data-icon="mdi:lock-open-variant-outline" style="vertical-align: -0.2em;"></span> é”å®šæ¨¡å¼ï¼š</strong> ç‚¹å‡»å³ä¸Šè§’çš„ "ç¼–è¾‘ä¸­" æŒ‰é’®å¯åˆ‡æ¢åˆ° "é¢„è§ˆä¸­"ï¼Œæ­¤æ¨¡å¼ä¸‹ç¦ç”¨åŒå‡»ç¼–è¾‘ï¼Œæ–¹ä¾¿åœ¨æ‰‹æœºä¸Šé¡ºç•…æ»‘åŠ¨æµè§ˆã€‚</p>
                <p><strong><span class="iconify" data-icon="mdi:import" style="vertical-align: -0.2em;"></span> å¯¼å…¥/å¯¼å‡ºï¼š</strong> åœ¨å³ä¾§æ£€æŸ¥å™¨çš„â€œå…¨å±€ä¸å¯¼å‡ºâ€è®¾ç½®ä¸­ï¼Œå¯ä»¥å¯¼å…¥/å¯¼å‡º .json é…ç½®æ–‡ä»¶ï¼Œæ–¹ä¾¿å¤‡ä»½å’Œåˆ†äº«ã€‚</p>
                <p><strong><span class="iconify" data-icon="mdi:content-save" style="vertical-align: -0.2em;"></span> æœ¬åœ°ä¿å­˜ï¼š</strong> ä½ çš„æ‰€æœ‰ä¿®æ”¹éƒ½ä¼šè‡ªåŠ¨ä¿å­˜åœ¨å½“å‰æµè§ˆå™¨ä¸­ï¼Œåˆ·æ–°é¡µé¢ä¸ä¼šä¸¢å¤±è¿›åº¦ï¼ˆè¯·å‹¿ä½¿ç”¨æ— ç—•æ¨¡å¼ï¼‰ã€‚</p>
                
                <hr class="separator">
                <h4>ğŸ”’ éšç§ä¸æ•°æ®å®‰å…¨</h4>
                <p>Blokko è¢«è®¾è®¡ä¸ºä¸€ä¸ªçº¯å®¢æˆ·ç«¯å·¥å…·ã€‚</p>
                <p><strong>æ‚¨çš„åˆ›ä½œ100%åœ¨æœ¬åœ°ï¼š</strong> æ‚¨çš„æ‰€æœ‰åˆ›ä½œæ•°æ®ï¼ŒåŒ…æ‹¬æ‚¨ä¸Šä¼ çš„å¤´åƒã€èƒŒæ™¯å›¾ã€å­—ä½“æ–‡ä»¶ã€å¡ç‰‡å†…å®¹ç­‰ï¼Œæ°¸è¿œä¸ä¼šç¦»å¼€æ‚¨çš„ç”µè„‘ã€‚æ‰€æœ‰å¤„ç†éƒ½åœ¨æ‚¨çš„æµè§ˆå™¨ä¸­å®Œæˆï¼Œäº‘ç«¯ä¸ä¼šå­˜å‚¨æ‚¨çš„ä»»ä½•ä¿¡æ¯ã€‚</p>
                <p><strong>ç¬¬ä¸‰æ–¹æœåŠ¡ï¼ˆå›¾æ ‡æœç´¢ï¼‰ï¼š</strong></p>
                <ul>
                    <li>ä¸ºäº†æä¾›â€œåœ¨çº¿å›¾æ ‡æœç´¢â€åŠŸèƒ½ï¼Œæœ¬å·¥å…·è°ƒç”¨äº† Iconify.design çš„å…¬å…±APIã€‚</li>
                    <li>å½“æ‚¨åœ¨å›¾æ ‡æœç´¢æ¡†ä¸­è¾“å…¥å…³é”®è¯æ—¶ï¼Œè¿™ä¸ªå…³é”®è¯ä¼šè¢«å‘é€åˆ° Iconify çš„æœåŠ¡å™¨ä»¥è·å–æœç´¢ç»“æœã€‚</li>
                    <li>æ­¤è¿‡ç¨‹æ˜¯åŒ¿åçš„ï¼Œä¸åŒ…å«æ‚¨çš„ä»»ä½•ä¸ªäººä¿¡æ¯æˆ–åˆ›ä½œå†…å®¹ã€‚</li>
                </ul>
		   </div>
            <div id="help-changelog" class="tab-content">
                <h4>v1.5.2</h4>
                <ul>
                    <li><b>ã€æ–°å¢ã€‘</b> <b>æ ‘çŠ¶å›¾å±‚ & åµŒå¥—æ’åº</b>: å·¦ä¾§â€œå†…å®¹å›¾å±‚â€é¢æ¿ç°åœ¨æ”¯æŒæŠ˜å ã€‚ç‚¹å‡»åŒºå—æ—çš„ç®­å¤´å¯å±•å¼€/æ”¶èµ·å…¶å†…éƒ¨çš„å¡ç‰‡åˆ—è¡¨ï¼Œå¹¶æ”¯æŒåœ¨åŒºå—å†…æ‹–åŠ¨å¡ç‰‡è¿›è¡Œæ’åºã€‚</li>
                    <li><b>ã€æ–°å¢ã€‘</b> <b>åŒºå—æ˜¾/éšåˆ‡æ¢</b>: åœ¨å·¦ä¾§å›¾å±‚é¢æ¿ä¸­ï¼Œä¸ºæ¯ä¸ªåŒºå—å¢åŠ äº†â€œçœ¼ç›â€å›¾æ ‡ï¼Œå¯ä¸€é”®åœ¨é¢„è§ˆä¸­æ˜¾ç¤ºæˆ–éšè—æ•´ä¸ªåŒºå—ã€‚</li>
                    <li><b>ã€æ–°å¢ã€‘</b> <b>æ ·å¼å¤åˆ¶ (åŒºå—)</b>: åœ¨å·¦ä¾§å›¾å±‚é¢æ¿ä¸­ï¼Œä¸ºæ¯ä¸ªåŒºå—å¢åŠ äº†â€œå¤åˆ¶â€å›¾æ ‡ï¼Œå¯å¿«é€Ÿåˆ›å»ºä¸€ä¸ªæ ·å¼ç›¸åŒä½†å†…å®¹ä¸ºç©ºçš„æ–°åŒºå—ã€‚</li>
                    <li><b>ã€æ–°å¢ã€‘</b> <b>æ ‡ç­¾æ‹–æ‹½æ’åº</b>: åœ¨ä¸ªäººä¿¡æ¯è®¾ç½®çš„â€œæ ‡ç­¾ç®¡ç†å™¨â€ä¸­ï¼Œç°åœ¨å¯ä»¥é€šè¿‡æ‹–æ‹½æ¥è°ƒæ•´æ ‡ç­¾çš„æ˜¾ç¤ºé¡ºåºã€‚</li>
                    <li><b>ã€ä¼˜åŒ–ã€‘</b> <b>â€œåŸºç¡€/é«˜çº§â€æ ·å¼åˆ†ç¦»</b>: ä¸ºäº†ç®€åŒ–ç•Œé¢ï¼Œå³ä¾§æ£€æŸ¥å™¨ä¸­çš„å¤æ‚è®¾ç½®é¡¹ï¼ˆå¦‚æè¾¹ã€çº¹ç†ã€ç‹¬ç«‹ä¸é€æ˜åº¦ç­‰ï¼‰è¢«é»˜è®¤éšè—ï¼Œå¯é€šè¿‡â€œæ˜¾ç¤ºé«˜çº§é€‰é¡¹â€å¼€å…³æ¥æ˜¾ç¤ºã€‚</li>
                    <li><b>ã€ä¼˜åŒ–ã€‘</b> <b>å¡ç‰‡é¢œè‰²é‡ç½®</b>: ä¸ºå¡ç‰‡ç‹¬ç«‹çš„é¢œè‰²è®¾ç½®é¡¹å¢åŠ äº†â€œé‡ç½®â€æŒ‰é’®ï¼Œå¯ä¸€é”®æ¸…é™¤ç‹¬ç«‹è®¾ç½®ï¼Œä½¿å…¶å›é€€è‡³å…¨å±€æ ·å¼ã€‚</li>
                    <li><b>ã€è°ƒæ•´ã€‘</b> <b>ç§»é™¤æ‰€æœ‰é˜´å½±</b>: æ ¹æ®è®¾è®¡åé¦ˆï¼Œå®Œå…¨ç§»é™¤äº†åº”ç”¨å†…æ‰€æœ‰çš„ `box-shadow` é˜´å½±æ•ˆæœï¼Œä½¿é£æ ¼æ›´ç»Ÿä¸€ã€‚åŒæ—¶ä¿ç•™äº†æ—§é…ç½®æ–‡ä»¶çš„å…¼å®¹æ€§ã€‚</li>
                    <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†åˆ é™¤åŒºå—åï¼Œå…¶åœ¨å·¦ä¾§å›¾å±‚é¢æ¿ä¸­ä»ä¼šæ®‹ç•™æ˜¾ç¤ºçš„BUGã€‚</li>
                    <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†åœ¨æ£€æŸ¥å™¨ä¸­æ‰‹åŠ¨è¾“å…¥HEXé¢œè‰²ä»£ç æ— æ³•ç”Ÿæ•ˆçš„é—®é¢˜ã€‚</li>
                    <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†ä½¿ç”¨æ™ºèƒ½å–è‰²æˆ–é‡ç½®é¢œè‰²åï¼Œæ£€æŸ¥å™¨ä¸­å¯¹åº”çš„é¢œè‰²é€‰æ‹©å™¨å’ŒHEXä»£ç ä¸ä¼šåŒæ­¥æ›´æ–°çš„é—®é¢˜ã€‚</li>
                    <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†å½“å¡ç‰‡æ–‡å­—è®¾ä¸ºâ€œå±…å³â€å¯¹é½æ—¶ï¼Œå¡ç‰‡æ ‡é¢˜æœªåŒæ­¥å±…å³çš„é—®é¢˜ã€‚</li>
                </ul>
                <hr class="separator">
                <h4>v1.5.1</h4>
                <ul>
                    <li><b>ã€æ–°å¢ã€‘</b> <b>æ™ºèƒ½å–è‰² & è°ƒè‰²æ¿</b>: æ–°å¢ç‹¬ç«‹çš„â€œæ™ºèƒ½å–è‰²â€é¢æ¿ï¼Œå¯ä¸Šä¼ å›¾ç‰‡è‡ªåŠ¨æå–8ç§æ¨èè‰²ï¼Œå¹¶é€šè¿‡å³é”®å¿«æ·åº”ç”¨ã€‚</li>
                    <li><b>ã€æ–°å¢ã€‘</b> <b>å¢å¼ºç‰ˆåˆ†éš”ç¬¦</b>: åˆ†éš”ç¬¦ç°å·²æ”¯æŒåµŒå…¥æ–‡å­—å’Œå›¾æ ‡ï¼Œå¹¶å¯è‡ªå®šä¹‰æ–‡å­—é¢œè‰²ã€‚</li>
                    <li><b>ã€ä¼˜åŒ–ã€‘</b> <b>å›¾å±‚åŒå‡»é‡å‘½å</b>: ç°åœ¨å¯ä»¥ç›´æ¥åœ¨å·¦ä¾§â€œå†…å®¹å›¾å±‚â€é¢æ¿åŒå‡»åŒºå—åç§°è¿›è¡Œé‡å‘½åã€‚</li>
                    <li><b>ã€ä¼˜åŒ–ã€‘</b> <b>å­—ä½“å®æ—¶é¢„è§ˆ</b>: å­—ä½“é€‰æ‹©ä¸‹æ‹‰æ¡†ç°åœ¨ä¼šä»¥å¯¹åº”çš„å­—ä½“æ ·å¼æ˜¾ç¤ºé€‰é¡¹ã€‚</li>
                    <li><b>ã€ä¼˜åŒ–ã€‘</b> <b>äº¤äº’ä½“éªŒ</b>: ä½¿ç”¨ä½“éªŒæ›´ä½³çš„è‡ªå®šä¹‰æ¨¡æ€æ¡†æ›¿ä»£äº†æµè§ˆå™¨çš„åŸç”Ÿç¡®è®¤å¼¹çª—ï¼›æå‡äº†åº”ç”¨çš„åˆå§‹åŠ è½½é€Ÿåº¦ã€‚</li>
                    <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†å³ä¾§æ£€æŸ¥å™¨ä¸­éƒ¨åˆ†åŒºåŸŸæ— æ³•æ­£å¸¸å±•å¼€/æ”¶èµ·çš„é—®é¢˜ã€‚</li>
                    <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†ç§»åŠ¨ç«¯è§†å›¾ä¸‹ï¼Œâ€œä¸‰æ’â€åŒºå—æ— æ³•æ­£ç¡®æ˜¾ç¤ºä¸ºä¸‰åˆ—çš„BUGã€‚</li>
                    <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†åˆ‡æ¢â€œç¼–è¾‘/é¢„è§ˆâ€æ¨¡å¼åï¼Œå¯èƒ½å¯¼è‡´æ— æ³•æ‹–æ‹½æ’åºçš„BUGã€‚</li>
                    <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†é¢œè‰²é€‰æ‹©å™¨ä¸HEXè¾“å…¥æ¡†å†…å®¹åœ¨æŸäº›æƒ…å†µä¸‹ä¸åŒæ­¥çš„BUGã€‚</li>
                </ul>
                <hr class="separator">
                <h4>v1.5.0</h4>
                <ul>
                    <li><b>ã€æ–°å¢ã€‘</b> <b>å…¨æ–°ä¸‰æ å¼å¸ƒå±€</b>: é‡æ„ä¸ºâ€œå†…å®¹å›¾å±‚(å·¦) - å®æ—¶é¢„è§ˆ(ä¸­) - æ ·å¼æ£€æŸ¥å™¨(å³)â€çš„ä¸‰æ å¸ƒå±€ï¼Œæ“ä½œæµç¨‹æ›´æ¸…æ™°ã€‚</li>
                    <li><b>ã€æ–°å¢ã€‘</b> <b>ä¸Šä¸‹æ–‡å…³è”ç¼–è¾‘</b>: ç‚¹å‡»é¢„è§ˆåŒºæˆ–å·¦ä¾§å›¾å±‚ä¸­çš„ä»»æ„å…ƒç´ ï¼Œå³ä¾§æ£€æŸ¥å™¨å°†è‡ªåŠ¨æ˜¾ç¤ºå…¶ç›¸å…³è®¾ç½®ã€‚</li>
                    <li><b>ã€ä¼˜åŒ–ã€‘</b> <b>è§†è§‰è”åŠ¨é«˜äº®</b>: ç¼–è¾‘å…ƒç´ æ—¶ï¼Œåœ¨é¢„è§ˆåŒºå’Œå›¾å±‚åˆ—è¡¨ä¸­ä¼šåŒæ­¥é«˜äº®æ˜¾ç¤ºã€‚</li>
                    <li><b>ã€ä¼˜åŒ–ã€‘</b> æ›´æ–°äº†æ–°æ‰‹æ•™ç¨‹å’Œå¸®åŠ©æ–‡æ¡£ä¸­çš„æ–‡æœ¬å†…å®¹ã€‚</li>
                    <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†å…¨å±€å¡ç‰‡ä¸é€æ˜åº¦ä¸º0æ—¶ï¼Œè¾¹æ¡†æ ·å¼ä¼šæ¶ˆå¤±çš„BUGã€‚</li>
                    <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†ä¸ºå¤šåˆ—åŒºå—å¯ç”¨ç€‘å¸ƒæµå¸ƒå±€åï¼Œå¯¼å‡ºå›¾ç‰‡æ—¶å¯èƒ½å‘ç”Ÿçš„å¸ƒå±€é”™ä¹±é—®é¢˜ã€‚</li>
                </ul>
                <details>
                    <summary>æŸ¥çœ‹æ›´æ—©çš„ç‰ˆæœ¬æ›´æ–°æ—¥å¿—</summary>
                    <div style="padding-top: 15px;">
                        <h4>v1.4.0ï¼ˆ25.11.08ï¼‰</h4>
                        <ul>
                            <li><b>ã€æ–°å¢ã€‘</b> <b>æ–°æ‰‹æ•™ç¨‹</b>: é¦–æ¬¡è®¿é—®çš„ç”¨æˆ·å°†è‡ªåŠ¨å¼¹å‡ºæ–°æ‰‹æ•™ç¨‹ï¼Œå¸®åŠ©å¿«é€Ÿä¸Šæ‰‹ã€‚åç»­å¯é€šè¿‡â€œå¸®åŠ©â€æŒ‰é’®æŸ¥çœ‹ã€‚</li>
                            <li><b>ã€ä¼˜åŒ–ã€‘</b> <b>ç¼–è¾‘åŒºå¸ƒå±€</b>: è°ƒæ•´äº†å·¦ä¾§ç¼–è¾‘åŒºçš„æ¨¡å—é¡ºåºï¼Œå°†ä¸å¸¸ç”¨çš„â€œæ“ä½œâ€éƒ¨åˆ†ç§»è‡³åº•éƒ¨ï¼Œæ›´ç¬¦åˆæ–°ç”¨æˆ·çš„ä½¿ç”¨ä¹ æƒ¯ã€‚</li>
                            <li><b>ã€ä¼˜åŒ–ã€‘</b> <b>é¢„è§ˆå®šä½å¢å¼º</b>: åœ¨ç”µè„‘ç«¯ï¼Œç‚¹å‡»é¢„è§ˆåŒºçš„ä»»æ„å¡ç‰‡ï¼Œå·¦ä¾§ç¼–è¾‘åŒºç°åœ¨ä¼šç²¾ç¡®æ»šåŠ¨åˆ°è¯¥å¡ç‰‡çš„å…·ä½“è®¾ç½®é¡¹ï¼Œè€Œä¸ä»…ä»…æ˜¯å…¶æ‰€å±çš„åŒºå—ã€‚</li>
                            <li><b>ã€ä¼˜åŒ–ã€‘</b> <b>ç§»åŠ¨ç«¯UI</b>: ä¿®å¤äº†åœ¨æ‰‹æœºä¸Šç¼–è¾‘é¢æ¿å¯èƒ½ä¼šå‡ºç°æ°´å¹³æ»šåŠ¨æ¡çš„é—®é¢˜ï¼›å‡å°äº†å„ç¼–è¾‘æ¨¡å—ä¹‹é—´çš„å‚ç›´é—´è·ï¼›ä¿®å¤äº†â€œé¡µé¢æ ·å¼â€è®¾ç½®ä¸­Tabæ§ä»¶äº’ç›¸å¹²æ‰°çš„BUGã€‚</li>
                            <li><b>ã€ä¿®å¤ã€‘</b> <b>å›¾ç‰‡å¯¼å‡º</b>: ä¿®å¤äº†åœ¨ç‰¹å®šæƒ…å†µä¸‹å¯¼å‡ºå›¾ç‰‡æ—¶å¯èƒ½å› èƒŒæ™¯å®šä½é—®é¢˜å¯¼è‡´æŠ¥é”™çš„BUGã€‚</li>
                        </ul>
                        <hr>
                        <h4>v1.3.2 (25.11.08)</h4>
                        <ul>
                            <li><b>ã€æ–°å¢ã€‘</b> ä¸ºå¤šåˆ—æ–‡æœ¬åŒºå—ï¼ˆåŒæ’/ä¸‰æ’ï¼‰å¢åŠ äº†ç€‘å¸ƒæµï¼ˆMasonryï¼‰å¸ƒå±€é€‰é¡¹ã€‚</li>
                            <li><b>ã€æ–°å¢/é‡æ„ã€‘</b> å›¾ç‰‡åŒºå—å·²å®Œå…¨é‡æ„ï¼Œç°åœ¨ä¸æ–‡æœ¬åŒºå—æ‹¥æœ‰ç»Ÿä¸€çš„å¡ç‰‡å¼ç®¡ç†é€»è¾‘ï¼Œå¹¶æ”¯æŒç€‘å¸ƒæµã€‚</li>
                            <li><b>ã€ä¼˜åŒ–ã€‘</b> ç‚¹å‡»é¢„è§ˆåŒºåŒºå—æ—¶ï¼Œå·¦ä¾§ç¼–è¾‘é¢æ¿ä¼šè‡ªåŠ¨å®šä½å¹¶å±•å¼€ã€‚</li>
                            <li><b>ã€ä¼˜åŒ–ã€‘</b> å¯¼å…¥æ—§ç‰ˆé…ç½®æ–‡ä»¶æ—¶ï¼Œä¼šè‡ªåŠ¨è¿ç§»æ—§çš„å›¾ç‰‡åŒºå—æ•°æ®ç»“æ„ï¼Œä¿è¯å…¼å®¹æ€§ã€‚</li>
                        </ul>
                        <hr>
                        <h4>v1.3.1 (2025.11.07)</h4>
                        <ul>
                            <li><b>ã€æ–°å¢ã€‘</b> å†…ç½®äº†å››æ¬¾å¼€æºå­—ä½“ã€‚</li>
                            <li><b>ã€ä¼˜åŒ–ã€‘</b> ä¼˜åŒ–äº†æ„Ÿè°¢ä¿¡æ¯ï¼Œç°åœ¨ä¼šæ˜¾ç¤ºè®¸å¯è¯åŸæ–‡å’Œå®˜ç½‘é“¾æ¥ã€‚</li>
                        </ul>
                        <hr>
                        <h4>v1.3.0 (2025.11.07)</h4>
                        <ul>
                           <li><b>ã€æ–°å¢ã€‘</b> è‡ªå®šä¹‰å¯¼å‡ºå®½åº¦å’Œå¯¼å‡ºåœ†è§’åŠŸèƒ½å›å½’ã€‚</li>
                           <li><b>ã€æ–°å¢ã€‘</b> èƒŒæ™¯çº¹ç†åŠŸèƒ½ï¼Œå¯ä¸èƒŒæ™¯è‰²ã€èƒŒæ™¯å›¾å åŠ ã€‚</li>
                           <li><b>ã€æ–°å¢ã€‘</b> æ–°å¢â€œä¸‰æ’å¡ç‰‡â€å¸ƒå±€å’Œâ€œç•™ç™½å—â€ã€‚</li>
                           <li><b>ã€ä¼˜åŒ–ã€‘</b> å›¾ç‰‡åŒºå—çš„æ–‡å­—ç°åœ¨æ”¯æŒç‹¬ç«‹çš„é¢œè‰²å’Œå­—å·è®¾ç½®ã€‚</li>
                           <li><b>ã€è°ƒæ•´ã€‘</b> å‡ºäºç½²ååˆè§„åŸåˆ™ï¼Œå›¾æ ‡åº“æœç´¢æºå·²è°ƒæ•´ã€‚</li>
                           <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†åŒå‡»ç¼–è¾‘åªèƒ½è¾“å…¥ä¸€ä¸ªå­—ç¬¦çš„BUGï¼›ä¿®å¤äº†å¯¼å‡ºå›¾ç‰‡æ—¶èƒŒæ™¯å›¾æ— æ³•æ˜¾ç¤ºçš„BUGã€‚</li>
                        </ul>
                        <hr>
                        <h4>v1.2.0 - v1.2.3 (2025.11.06-07)</h4>
                        <ul>
                           <li><b>ã€æ–°å¢ã€‘</b> æ–°å¢é”å®šæŒ‰é’®ã€è‡ªå®šä¹‰å¯¼å‡ºå®½åº¦ã€å…³äºä¸è‡´è°¢é¡µé¢ã€‚</li>
                           <li><b>ã€ä¼˜åŒ–ã€‘</b> ä¼˜åŒ–è§¦å±ä½“éªŒã€é‡åšæ ‡ç­¾ç³»ç»Ÿã€æ›´æ¢ä¸º "Iconify" å›¾æ ‡åº“ã€‚</li>
                           <li><b>ã€è°ƒæ•´ã€‘</b> æ›´åä¸ºâ€œBlokkoâ€ã€‚</li>
                           <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤äº†æ— æ³•å¢åˆ åŒºå—ã€æ‰‹æœºå¯¼å‡ºå¼‚å¸¸ã€èƒŒæ™¯è’™ç‰ˆå¯¼å‡ºã€åœ†è§’è¾¹æ¡†ç©ºéš™ç­‰å¤šä¸ªBUGã€‚</li>
                        </ul>
                        <hr>
                        <h4>v1.1.1 (2025.11.06)</h4>
                        <ul>
                           <li><b>ã€æ–°å¢ã€‘</b> æ–°å¢æ¸å˜è§’åº¦ã€å°å›¾æ ‡ã€å¯¼å‡ºæ¨¡æ¿ã€å¡ç‰‡è¾¹æ¡†åŠŸèƒ½ã€‚</li>
                           <li><b>ã€ä¼˜åŒ–ã€‘</b> ä¼˜åŒ–æ‰‹æœºç«¯ä½“éªŒï¼Œæ”¯æŒæŠ˜å ç¼–è¾‘åŒºã€‚</li>
                           <li><b>ã€ä¿®å¤ã€‘</b> ä¿®å¤åˆ·æ–°ä¸¢å¤±ç¼–è¾‘è®°å½•çš„BUGã€‚</li>
                        </ul>
                    </div>
                </details>
            </div>
            <div id="help-thanks" class="tab-content">
                <p>æœ¬å·¥å…·çš„å®ç°ç¦»ä¸å¼€ä»¥ä¸‹ä¼˜ç§€çš„å¼€æºé¡¹ç›®ï¼Œåœ¨æ­¤è¡¨ç¤ºè¯šæŒšçš„æ„Ÿè°¢ï¼š</p>
                <div class="thanks-item">
                    <h4>æ ¸å¿ƒåŠŸèƒ½åº“</h4>
                    <p>ä»¥ä¸‹é¡¹ç›®å‡åŸºäº <strong>MIT License</strong> åè®®ï¼Œç‰¹æ­¤æ„Ÿè°¢ã€‚</p>
                    <ul>
                        <li><a href="https://github.com/lokesh/color-thief" target="_blank" rel="noopener noreferrer"><strong>Color Thief</strong></a> - æä¾›äº†ä»å›¾ç‰‡æå–ä¸»è‰²è°ƒå’Œè°ƒè‰²æ¿çš„åŠŸèƒ½ã€‚</li>
                        <li><a href="https://html2canvas.hertzen.com/" target="_blank" rel="noopener noreferrer"><strong>html2canvas</strong></a> - å®ç°äº†å°†ç½‘é¡µå†…å®¹å¯¼å‡ºä¸ºå›¾ç‰‡çš„æ ¸å¿ƒåŠŸèƒ½ã€‚</li>
                        <li><a href="https://fengyuanchen.github.io/cropperjs/" target="_blank" rel="noopener noreferrer"><strong>Cropper.js</strong></a> - æä¾›äº†å¼ºå¤§çš„å›¾ç‰‡è£å‰ªåŠŸèƒ½ã€‚</li>
                        <li><a href="https://sortablejs.github.io/Sortable/" target="_blank" rel="noopener noreferrer"><strong>SortableJS</strong></a> - æä¾›äº†æµç•…çš„æ‹–æ‹½æ’åºä½“éªŒã€‚</li>
                        <li><a href="https://masonry.desandro.com/" target="_blank" rel="noopener noreferrer"><strong>Masonry.js</strong></a> - æä¾›äº†å¼ºå¤§çš„ç€‘å¸ƒæµ/ç Œä½“å¸ƒå±€åŠŸèƒ½ã€‚</li>
                    </ul>
                    <details>
                        <summary>æŸ¥çœ‹ MIT è®¸å¯è¯åŸæ–‡</summary>
                        <pre>
Copyright (c) 2024

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
                        </pre>
                    </details>
                </div>
                 <div class="thanks-item">
                    <h4>å¼€æºå­—ä½“</h4>
                    <p>æœ¬é¡¹ç›®é›†æˆçš„æ¨èå­—ä½“å‡åŸºäº <strong>SIL Open Font License 1.1</strong> åè®®ï¼Œå¯å…è´¹å•†ç”¨ã€‚</p>
                    <ul>
                        <li><a href="https://github.com/adobe-fonts/source-han-sans" target="_blank" rel="noopener noreferrer"><strong>æ€æºé»‘ä½“ (Source Han Sans)</strong></a> - ç”± Adobe ä¸ Google è”åˆå¼€å‘ã€‚</li>
                        <li><a href="https://github.com/adobe-fonts/source-han-serif" target="_blank" rel="noopener noreferrer"><strong>æ€æºå®‹ä½“ (Source Han Serif)</strong></a> - ç”± Adobe ä¸ Google è”åˆå¼€å‘ã€‚</li>
                        <li><a href="https://www.zcool.com.cn/work/ZMTg5Njc2NTI=.html" target="_blank" rel="noopener noreferrer"><strong>ç«™é…·å¿«ä¹ä½“ (ZCOOL KuaiLe)</strong></a> - ç”± ç«™é…· (ZCOOL) è®¾è®¡å¸ˆå›¢é˜Ÿåˆ›ä½œã€‚</li>
                        <li><a href="https://www.zcool.com.cn/work/ZMTg5ODY0NDQ=.html" target="_blank" rel="noopener noreferrer"><strong>ç«™é…·å°è–‡ä½“ (ZCOOL XiaoWei)</strong></a> - ç”± ç«™é…· (ZCOOL) è®¾è®¡å¸ˆå›¢é˜Ÿåˆ›ä½œã€‚</li>
                    </ul>
                    <details>
                        <summary>æŸ¥çœ‹ SIL Open Font License 1.1 è®¸å¯è¯åŸæ–‡</summary>
                        <pre>
This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL

-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded,
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting â€” in part or in whole â€” any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining a
copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.
                        </pre>
                    </details>
                </div>
                <div class="thanks-item">
                    <h4>èµ„æºä¸æœåŠ¡</h4>
                    <ul>
                        <li><a href="https://iconify.design/" target="_blank" rel="noopener noreferrer"><strong>Iconify</strong></a>: æä¾›äº†ç»Ÿä¸€çš„å›¾æ ‡æ£€ç´¢å’ŒåŠ è½½åŠŸèƒ½ã€‚æœ¬é¡¹ç›®ä½¿ç”¨çš„å›¾æ ‡åº“ï¼ˆå¦‚MDI, Tabler, Lucideç­‰ï¼‰å‡åŸºäºå¯¹å•†ä¸šå‹å¥½çš„å¼€æºåè®®å‘å¸ƒã€‚</li>
                        <li><a href="https://heropatterns.com/" target="_blank" rel="noopener noreferrer"><strong>Hero Patterns</strong></a>: æä¾›äº†ç²¾ç¾ã€å¯å®šåˆ¶çš„SVGèƒŒæ™¯çº¹ç† (MIT License)ã€‚</li>
                    </ul>
                </div>
            </div>
            <div id="help-about" class="tab-content">
                <h4>å…³äº Blokko</h4>
                <p>Blokkoæ˜¯ä¸€ä¸ªæ–¹ä¾¿å¤§å®¶å¿«é€Ÿåˆ¶ä½œæ‰©åˆ—/è‡ªè/ç½®é¡¶å›¾çš„å°å·¥å…·ï¼</p>
                <p><strong>ä½œè€…ï¼š</strong> å››åä¸ƒ</p>
                <p>å¦‚æœä½ åœ¨ä½¿ç”¨ä¸­é‡åˆ°BUGï¼Œå¯ä»¥é€šè¿‡é“¾æ¥ç§ä¿¡æˆ‘ï¼å¦‚æœè§‰å¾—å¥½ç”¨ï¼Œä¹Ÿå¸Œæœ›èƒ½ç‚¹å‡»é“¾æ¥å»ç½®é¡¶è¯„è®ºåŒºç•™ä¸‹è¯„è®ºæˆ–è½¬å‘ï¼Œæˆ–è€…æ˜¯åœ¨è‡ªå·±çš„åˆ¶ä½œçš„å›¾è¯„è®ºåŒºæˆ–æ­£æ–‡é‡Œè´´ä¸ŠåŸåšé“¾æ¥ï¼ˆå°±æ˜¯ç½®é¡¶é‚£ä¸€æ¡ï¼Œå½“ç„¶è¿™äº›éƒ½ä¸æ˜¯å¼ºåˆ¶è¦æ±‚çš„ï¼Œä½†æ˜¯å¦‚æœå¯ä»¥çš„è¯ä¼šè®©æˆ‘å¾ˆå¼€å¿ƒï¼ï¼‰ï¼Œæœ€åæ„Ÿè°¢æ‚¨ä½¿ç”¨Blokko!</p>
                <p><a href="https://weibo.com/u/5095783616" target="_blank" rel="noopener noreferrer"><strong>æˆ‘çš„å¾®åšä¸»é¡µ</strong></a></p>
            </div>
            <div class="modal-actions" style="justify-content: center; margin-top: 20px;">
                <button id="help-modal-close-btn" class="btn btn-primary">å…³é—­</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="icon-picker-modal">
        <div class="modal-container">
            <h3>é€‰æ‹©å›¾æ ‡</h3>
            <div class="form-group">
                <input type="text" id="icon-search" placeholder="æœç´¢å›¾æ ‡ (ä¾‹å¦‚: bilibili, music, home, user)..." class="form-control">
            </div>
            <div id="icon-grid"></div>
            <div class="modal-actions">
                <button id="upload-icon-btn" class="btn btn-secondary">ä¸Šä¼ å›¾æ ‡ (.svg)</button>
                <input type="file" id="icon-upload-input" accept=".svg" style="display: none;">
                <button id="remove-icon-btn" class="btn btn-danger">ç§»é™¤å›¾æ ‡</button>
                <button id="icon-picker-close-btn" class="btn btn-default">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="texture-picker-modal">
        <div class="modal-container">
            <h3>é€‰æ‹©èƒŒæ™¯çº¹ç†</h3>
            <div id="texture-grid"></div>
            <div class="modal-actions">
                <button id="remove-texture-btn" class="btn btn-danger">ç§»é™¤çº¹ç†</button>
                <button id="texture-picker-close-btn" class="btn btn-default">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <div id="loading-overlay"><div class="spinner"></div><span id="loading-text">æ­£åœ¨å¤„ç†...</span></div>
    <div class="toast-notification-container" id="toast-container"></div>
    
    <div id="color-context-menu">
        <ul>
            <li data-action="apply-page-bg-solid">åº”ç”¨åˆ°é¡µé¢èƒŒæ™¯è‰²</li>
            <li data-action="apply-page-bg-gradient-start">&rarr; é¡µé¢èƒŒæ™¯æ¸å˜ (èµ·å§‹è‰²)</li>
            <li data-action="apply-page-bg-gradient-end">&rarr; é¡µé¢èƒŒæ™¯æ¸å˜ (ç»“æŸè‰²)</li>
            <hr />
            <li data-action="apply-header-bg-solid">åº”ç”¨åˆ°å¤´éƒ¨èƒŒæ™¯è‰²</li>
            <li data-action="apply-header-bg-gradient-start">&rarr; å¤´éƒ¨èƒŒæ™¯æ¸å˜ (èµ·å§‹è‰²)</li>
            <li data-action="apply-header-bg-gradient-end">&rarr; å¤´éƒ¨èƒŒæ™¯æ¸å˜ (ç»“æŸè‰²)</li>
            <li data-action="apply-header-text">åº”ç”¨åˆ°å¤´éƒ¨æ–‡å­—é¢œè‰²</li>
            <hr />
            <li data-action="apply-gcard-bg">åº”ç”¨åˆ°å…¨å±€å¡ç‰‡èƒŒæ™¯è‰²</li>
            <li data-action="apply-gcard-bg-gradient-start">&rarr; å…¨å±€å¡ç‰‡æ¸å˜ (èµ·å§‹è‰²)</li>
            <li data-action="apply-gcard-bg-gradient-end">&rarr; å…¨å±€å¡ç‰‡æ¸å˜ (ç»“æŸè‰²)</li>
            <li data-action="apply-gcard-text">åº”ç”¨åˆ°å…¨å±€å¡ç‰‡æ–‡å­—è‰²</li>
        </ul>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.2/Sortable.min.js" defer></script>
    <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js" defer></script>
    <script src="https://code.iconify.design/3/3.1.1/iconify.min.js" defer></script>
    
    <script>
        // Hero Patterns data. Source: https://heropatterns.com/
        const HeroPatterns = [
            { name: 'Jigsaw', svg: (c, o) => `<svg width="60" height="60" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg"><path d="M41.512 41.512c.976.976 2.256.488 2.256-1.024v-6.728c0-1.512.732-2.256 2.256-2.256h6.728c1.512 0 2.016-.244 1.024-2.256-3.904-7.808-7.808-11.712-11.712-11.712-3.904 0-7.808 3.904-11.712 11.712-.992 2.012-.504 2.256 1.024 2.256h6.728c1.512 0 2.256.732 2.256 2.256v6.728c0 1.512.244 2.016 2.256 1.024zM59 60c.504 0 1-.488 1-1V38.864c0-1.512.732-2.256 2.256-2.256h10.128c1.008 0 1.512.22 1.512 1.248 0 4.88-3.904 9.76-11.712 9.76-7.808 0-11.712-4.88-11.712-9.76 0-1.028.504-1.248 1.512-1.248h10.128c1.512 0 2.256.732 2.256 2.256V59c0 .512.488 1 1 1h16.336c.512 0 1-.488 1-1V38.864c0-1.512.732-2.256 2.256-2.256h10.128c1.008 0 1.512.22 1.512 1.248 0 4.88-3.904 9.76-11.712 9.76-7.808 0-11.712-4.88-11.712-9.76 0-1.028.504-1.248 1.512-1.248h10.128c1.512 0 2.256.732 2.256 2.256V59c0 .512.488 1 1 1H59z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Overlapping Circles', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><circle cx="5" cy="5" r="5"/><circle cx="15" cy="5" r="5"/><circle cx="5" cy="15" r="5"/><circle cx="15" cy="15" r="5"/></g></svg>` },
            { name: 'Plus', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 2h2v2H2V2zm4 0h2v2H6V2zm4 0h2v2h-2V2zm4 0h2v2h-2V2zM2 6h2v2H2V6zm4 0h2v2H6V6zm4 0h2v2h-2V6zm4 0h2v2h-2V6zM2 10h2v2H2v-2zm4 0h2v2H6v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zM2 14h2v2H2v-2zm4 0h2v2H6v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'X-Equals', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 2.5a.5.5 0 01.5-.5h14a.5.5 0 01.5.5v1a.5.5 0 01-.5.5h-14a.5.5 0 01-.5-.5v-1zM17 6H3a1 1 0 000 2h14a1 1 0 000-2zM3 12h14a1 1 0 000-2H3a1 1 0 100 2zm15 3.5a.5.5 0 01-.5.5h-14a.5.5 0 01-.5-.5v-1a.5.5 0 01.5-.5h14a.5.5 0 01.5.5v1z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Brick Wall', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h20v20H0V0zm10 12h10v2H10v-2zM0 2h10v2H0V2zm0 8h10v2H0v-2zm10 0h10v2H10v-2zM0 6h10v2H0V6zm10-4h10v2H10V2zM0 14h10v2H0v-2zm10 4h10v2H10v-2z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Floating Cogs', svg: (c, o) => `<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M9 13.09V5.5c0-.828.672-1.5 1.5-1.5h5c.828 0 1.5.672 1.5 1.5v7.59a4.5 4.5 0 10-8 0zM5.5 13a3.5 3.5 0 000 7h15a3.5 3.5 0 000-7H5.5z"/><path d="M9 13.09V5.5c0-.828.672-1.5 1.5-1.5h5c.828 0 1.5.672 1.5 1.5v7.59a4.5 4.5 0 10-8 0zM5.5 13a3.5 3.5 0 000 7h15a3.5 3.5 0 000-7H5.5z" transform="rotate(180 13 13)"/></g></svg>` },
            { name: 'Polka Dots', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><circle cx="3" cy="3" r="3"/><circle cx="13" cy="13" r="3"/></g></svg>` },
            { name: 'Faceted', svg: (c, o) => `<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M0 40L40 0H20L0 20z" /><path d="M40 40V20L20 40z" /></g></svg>`},
            { name: 'Topography', svg: (c, o) => `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm5 8c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm10 0c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm13-8c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-5 8c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-10 0c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-5-18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Lines In Motion', svg: (c, o) => `<svg width="80" height="80" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><path d="M20 20v40h40V20H20zm20 38c-9.94 0-18-8.06-18-18s8.06-18 18-18 18 8.06 18 18-8.06 18-18 18z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Cicada Stripe', svg: (c, o) => `<svg width="6" height="6" viewBox="0 0 6 6" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>` },
            { name: 'Diamonds', svg: (c, o) => `<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M0 5h5L0 0v5zm10 0h-5l5-5v5zM0 5h5l5 5H5L0 5zm10 0h-5l-5 5h5l5-5z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Texture', svg: (c, o) => `<svg width="52" height="26" viewBox="0 0 52 26" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M10 10c0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6h2c0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4v2c-3.314 0-6-2.686-6-6 0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6zm25.464-1.95l8.486 8.486-1.414 1.414-8.486-8.486 1.414-1.414z" /><path d="M41.464 15.05l8.486-8.486-1.414-1.414-8.486 8.486 1.414 1.414z" /></g></svg>` },
            { name: 'Cross', svg: (c, o) => `<svg width="8" height="8" viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg"><path d="M4 0h1v3h3v1H5v3H4V4H1V3h3z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Rain', svg: (c, o) => `<svg width="4" height="4" viewBox="0 0 4 4" xmlns="http://www.w3.org/2000/svg"><path d="M1 3h1v1H1V3zm2-2h1v1H3V1z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Diagonal Lines', svg: (c, o) => `<svg width="4" height="4" viewBox="0 0 4 4" xmlns="http://www.w3.org/2000/svg"><path d="M-1 3h1v1H-1V3zm2-2h1v1H1V1zm2-2h1v1H3V-1z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Chevrons', svg: (c, o) => `<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M0 0l5 5-5 5h5l5-5-5-5H0z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
        ];

        document.addEventListener('DOMContentLoaded', () => {
            const App = {
                state: {},
                selection: { type: 'global', cardId: null },
                history: [],
                historyIndex: -1,
                isRestoringState: false,
                isEditingText: false,
                cropper: null,
                currentCropTarget: null,
                currentIconTarget: null, 
                sortableLayers: null,
                sortablePreview: null,
                sortableTags: null,
                cardLayerSortables: {},
                cardSortables: {},
                imageCardSortables: {},
                masonryInstances: {},
                debouncedSaveToLocal: null,
                localFonts: [],
                uploadedFonts: [],
                presets: {},
                icons: [], 
                texturePickerInitialized: false,
                iconPickerInitialized: false,
                colorThief: null,
                longPressTimer: null,
                lastPalette: [],

                init() {
                    console.log("Blokko åˆå§‹åŒ– v1.5.2 ...");
                    this.elements = this.queryElements();
                    this.presets = this.getPresets();
                    this.state = this.getDefaultState();
                    this.debouncedSaveToLocal = this.debounce(this.saveToLocal, 500);
                    
                    this.bindCoreEvents();
                    this.bindEditorEvents();
                    this.bindPreviewEvents();
                    this.initResizer();
                    
                    this.loadPreferences();
                    this.loadFromLocal();
                    
                    this.history = [this.deepClone(this.state)];
                    this.historyIndex = 0;
                    
                    this.renderAll(true); 
                    this.syncAllControls();
                    this.populateFontList(); 
                    this.initAllSortables();
                    this.updateExportSizePreview();
                    
                    this.setSelection({ type: 'global' });
                    this.updateUndoRedoButtons();
                    
                    const hasVisited = localStorage.getItem('blokkoFirstVisit_v1_5');
                    if (!hasVisited) {
                        this.elements.helpModal.classList.add('visible');
                        const helpModal = this.elements.helpModal;
                        const tutorialTabBtn = helpModal.querySelector('[data-tab="help-tutorial"]');
                        if (tutorialTabBtn) {
                           tutorialTabBtn.click();
                        }
                        localStorage.setItem('blokkoFirstVisit_v1_5', 'true');
                    }
                    if (window.ColorThief) {
                        this.colorThief = new ColorThief();
                    }
                },

                getDefaultState() {
                    const lightTheme = this.getPresets().light;
                    return {
                        customIcons: [],
                        personalInfo: { 
                            nickname: "ä½ çš„æ˜µç§°", nicknameColor: lightTheme.pNicknameColor,
                            subtitle: "è¿™æ˜¯å‰¯æ ‡é¢˜ï¼ŒåŒå‡»å¯ç¼–è¾‘", subtitleColor: lightTheme.pSubtitleColor,
                            bio: "è¿™æ˜¯ç®€ä»‹ï¼ŒåŒå‡»å¯ç¼–è¾‘", bioColor: lightTheme.pBioColor,
                            avatarDataUrl: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23cccccc'%3E%3Cpath d='M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z'/%3E%3C/svg%3E", 
                            avatarShape: '50%', avatarBorderSize: 4, avatarBorderColor: '#ffffff',
                            headerShadowEnabled: false, // Compatibility
                            tags: [
                                { id: this.generateId('t'), icon: 'mdi:palette', text: 'è®¾è®¡å¸ˆ' },
                                { id: this.generateId('t'), icon: 'mdi:github', text: 'ä»£ç çˆ±å¥½è€…' }
                            ], 
                            tagBgColor: lightTheme.pTagBgColor, tagTextColor: lightTheme.pTagTextColor
                        },
                        pageStyles: {
                            pageBgMode: 'gradient',
                            pageBgSolidColor: lightTheme.pageBgSolidColor, pageBgImageDataUrl: null, 
                            pageBgGradientStart: lightTheme.pageBgGradientStart, pageBgGradientEnd: lightTheme.pageBgGradientEnd,
                            pageBgGradientAngle: 135,
                            pageOverlayColor: "#000000", pageOverlayOpacity: 0.3,
                            pageBgPattern: '', pageBgPatternColor: '#000000', pageBgPatternOpacity: 0.1, pageBgPatternDensity: 30,
                            headerBgMode: 'gradient',
                            headerBgColor: lightTheme.headerBgColor, headerTextColor: lightTheme.headerTextColor, headerOpacity: 1.0, 
                            headerBgGradientStart: lightTheme.headerBgGradientStart, headerBgGradientEnd: lightTheme.headerBgGradientEnd,
                            headerBgGradientAngle: 135,
                        },
                        blocks: [
                            { id: this.generateId('b'), type: 'text', title: "å•æ’å¡ç‰‡åŒºå—", isVisible: true, settings: { layout: 'single', masonryEnabled: false }, cards: [
                                { id: this.generateId('c'), icon: '', title: "è¿™æ˜¯å•æ’å¡ç‰‡", content: "åŒå‡»è¿™é‡Œè¿›è¡Œç¼–è¾‘", opacity: 1.0, followGlobalOpacity: true, textShadowEnabled: false }
                            ]},
                            { id: this.generateId('b'), type: 'text', title: "åŒæ’å¡ç‰‡åŒºå—", isVisible: true, settings: { layout: 'dual', masonryEnabled: false }, cards: [
                                { id: this.generateId('c'), icon: '', title: "è¿™æ˜¯åŒæ’å¡ç‰‡ 1", content: "åŒå‡»è¿™é‡Œè¿›è¡Œç¼–è¾‘", opacity: 1.0, followGlobalOpacity: true, textShadowEnabled: false },
                                { id: this.generateId('c'), icon: '', title: "è¿™æ˜¯åŒæ’å¡ç‰‡ 2", content: "åŒå‡»è¿™é‡Œè¿›è¡Œç¼–è¾‘", opacity: 1.0, followGlobalOpacity: true, textShadowEnabled: false }
                            ]},
                            { id: this.generateId('b'), type: 'separator', title: "åˆ†å‰²çº¿", isVisible: true, settings: { style: 'solid', color: '#dddddd', thickness: 1, margin: 20, text: '', icon: null, textColor: '#555555' }},
                            { id: this.generateId('b'), type: 'image', title: "å›¾ç‰‡åŒºå—", isVisible: true, settings: { layout: 'dual', masonryEnabled: false, textColor: '' }, cards: [] },
                            { id: this.generateId('b'), type: 'spacer', title: "ç•™ç™½å—", isVisible: true, settings: { height: 20 }},
                        ],
                        globalCardStyles: { 
                            bgMode: 'solid', 
                            bgColor: lightTheme.gCardBgColor, textColor: lightTheme.gCardTextColor, opacity: 1.0,
                            bgGradientStart: lightTheme.gCardBgGradientStart, bgGradientEnd: lightTheme.gCardBgGradientEnd,
                            bgGradientAngle: 135,
                            shadowEnabled: false, // Compatibility
                            radius: 12, textAlign: "left", lineHeight: "1.5", 
                            fontFamily: "", fontSize: "1rem",
                            textStrokeWidth: 0, textStrokeColor: "#000000",
                            borderWidth: 0, borderStyle: 'none', borderColor: '#cccccc',
                        }
                    };
                },
                
                getPresets() {
                    return {
                        light: {
                            pageBgSolidColor: "#f0f2f5", pageBgGradientStart: "#f0f2f5", pageBgGradientEnd: "#e6e9ed",
                            headerBgColor: "#ffffff", headerBgGradientStart: "#ffffff", headerBgGradientEnd: "#f7f7f7",
                            headerTextColor: "#1a1a1a",
                            gCardBgColor: "#ffffff", gCardTextColor: "#1a1a1a", gCardOpacity: 1.0,
                            gCardBgGradientStart: "#ffffff", gCardBgGradientEnd: "#f5f5f5",
                            pNicknameColor: "#1a1a1a", pSubtitleColor: "#555555", pBioColor: "#555555",
                            pTagBgColor: "#eef1f5", pTagTextColor: "#3c3c43",
                        },
                        dark: {
                            pageBgSolidColor: "#121417", pageBgGradientStart: "#121417", pageBgGradientEnd: "#1a1d21",
                            headerBgColor: "#1f2229", headerBgGradientStart: "#1f2229", headerBgGradientEnd: "#252930",
                            headerTextColor: "#f0f2f5",
                            gCardBgColor: "#2c303a", gCardTextColor: "#f0f2f5", gCardOpacity: 0.95,
                            gCardBgGradientStart: "#2c303a", gCardBgGradientEnd: "#343946",
                            pNicknameColor: "#f0f2f5", pSubtitleColor: "#a0aec0", pBioColor: "#a0aec0",
                            pTagBgColor: "#3e4451", pTagTextColor: "#e2e8f0",
                        },
                        mint: {
                            pageBgSolidColor: "#ccfbf1", pageBgGradientStart: "#ccfbf1", pageBgGradientEnd: "#a7f3d0",
                            headerBgColor: "#f0fdfa", headerBgGradientStart: "#f0fdfa", headerBgGradientEnd: "#e6fcf5",
                            headerTextColor: "#0f766e",
                            gCardBgColor: "#ffffff", gCardTextColor: "#134e4a", gCardOpacity: 1.0,
                            gCardBgGradientStart: "#ffffff", gCardBgGradientEnd: "#fafffd",
                            pNicknameColor: "#064e3b", pSubtitleColor: "#115e59", pBioColor: "#134e4a",
                            pTagBgColor: "#a7f3d0", pTagTextColor: "#065f46",
                        },
                        coffee: {
                            pageBgSolidColor: "#f3e8e2", pageBgGradientStart: "#f3e8e2", pageBgGradientEnd: "#e9d8cf",
                            headerBgColor: "#fdf8f6", headerBgGradientStart: "#fdf8f6", headerBgGradientEnd: "#faf3ef",
                            headerTextColor: "#432818",
                            gCardBgColor: "#ffffff", gCardTextColor: "#5e4534", gCardOpacity: 1.0,
                            gCardBgGradientStart: "#ffffff", gCardBgGradientEnd: "#fffbf8",
                            pNicknameColor: "#432818", pSubtitleColor: "#6f4e37", pBioColor: "#5e4534",
                            pTagBgColor: "#e3d5ca", pTagTextColor: "#432818",
                        }
                    };
                },

                queryElements() {
                    const q = (selector) => document.querySelector(selector);
                    return {
                        layerPanel: q('#layer-panel'),
                        inspectorPanel: q('#inspector-panel'),
                        layerList: q('#layer-list'),
                        previewPanel: q('#preview-panel'),
                        resizer: q('#resizer'),
                        themeToggleBtn: q('#theme-toggle-btn'), themeLabel: q('#theme-label'),
                        previewWrapper: q('#preview-wrapper'), previewOverlay: q('#preview-overlay'),
                        previewBlocksContainer: q('#preview-blocks-container'),
                        previewHeader: q('#preview-header'), previewAvatar: q('#preview-avatar'),
                        previewNickname: q('#preview-nickname'), previewSubtitle: q('#preview-subtitle'),
                        previewBio: q('#preview-bio'), previewTagsContainer: q('#preview-tags-container'),
                        addTextBlockBtn: q('#add-text-block-btn'), addImageBlockBtn: q('#add-image-block-btn'),
                        addSeparatorBlockBtn: q('#add-separator-block-btn'), addSpacerBlockBtn: q('#add-spacer-block-btn'),
                        cropperModal: q('#cropper-modal'), cropperImage: q('#cropper-image'),
                        cropperCancelBtn: q('#cropper-cancel-btn'), cropperSaveBtn: q('#cropper-save-btn'),
                        downloadModal: q('#download-modal'), downloadModalTitle: q('#download-modal-title'),
                        downloadModalContent: q('#download-modal-content'), downloadModalCloseBtn: q('#download-modal-close-btn'),
                        loadingOverlay: q('#loading-overlay'), loadingText: q('#loading-text'),
                        toastContainer: q('#toast-container'),
                        mobileLayerToggle: q('#mobile-layer-toggle'),
                        mobileInspectorToggle: q('#mobile-inspector-toggle'),
                        body: document.body,
                        showHelpBtn: q('#show-help-btn'),
                        helpModal: q('#help-modal'),
                        helpModalCloseBtn: q('#help-modal-close-btn'),
                        iconPickerModal: q('#icon-picker-modal'),
                        iconGrid: q('#icon-grid'),
                        iconSearch: q('#icon-search'),
                        removeIconBtn: q('#remove-icon-btn'),
                        iconPickerCloseBtn: q('#icon-picker-close-btn'),
                        uploadIconBtn: q('#upload-icon-btn'), iconUploadInput: q('#icon-upload-input'),
                        lockModeToggle: q('#lock-mode-toggle'),
                        texturePickerModal: q('#texture-picker-modal'),
                        textureGrid: q('#texture-grid'),
                        removeTextureBtn: q('#remove-texture-btn'),
                        texturePickerCloseBtn: q('#texture-picker-close-btn'),
                        confirmModal: q('#confirm-modal'),
                        colorContextMenu: q('#color-context-menu'),
                    };
                },

                bindCoreEvents() {
                    this.elements.themeToggleBtn.addEventListener('click', () => this.toggleTheme());
                    this.elements.addTextBlockBtn.addEventListener('click', () => this.addBlock('text'));
                    this.elements.addImageBlockBtn.addEventListener('click', () => this.addBlock('image'));
                    this.elements.addSeparatorBlockBtn.addEventListener('click', () => this.addBlock('separator'));
                    this.elements.addSpacerBlockBtn.addEventListener('click', () => this.addBlock('spacer'));
                    this.elements.downloadModalCloseBtn.addEventListener('click', () => this.hideDownloadModal());
                    this.elements.cropperCancelBtn.addEventListener('click', () => this.hideCropper());
                    this.elements.cropperSaveBtn.addEventListener('click', () => this.saveCrop());
                    this.elements.cropperModal.querySelector('.crop-ratios').addEventListener('change', () => this.updateCropAspectRatio());
                    
                    this.elements.mobileLayerToggle.addEventListener('click', () => this.togglePanelDrawer('layer-panel'));
                    this.elements.mobileInspectorToggle.addEventListener('click', () => this.togglePanelDrawer('inspector-panel'));
                    this.elements.previewPanel.addEventListener('click', (e) => {
                        if (e.target === this.elements.previewPanel && this.elements.body.classList.contains('panels-open')) {
                            this.togglePanelDrawer(false);
                        }
                    });

                    this.elements.showHelpBtn.addEventListener('click', () => this.elements.helpModal.classList.add('visible'));
                    this.elements.helpModalCloseBtn.addEventListener('click', () => this.elements.helpModal.classList.remove('visible'));
                    
                    let aboutClickCount = 0;
                    let aboutClickTimer = null;
                    this.elements.helpModal.querySelector('.tabs').addEventListener('click', (e) => {
                        const tabBtn = e.target.closest('.tab-btn');
                        if (tabBtn) {
                            const parent = tabBtn.closest('.modal-container');
                            parent.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                            tabBtn.classList.add('active');
                            parent.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                            const targetTab = parent.querySelector(`#${tabBtn.dataset.tab}`);
                            if (targetTab) targetTab.classList.add('active');

                            this.elements.helpModalCloseBtn.textContent = (tabBtn.dataset.tab === 'help-tutorial') ? "æˆ‘å·²äº†è§£ï¼Œå¼€å§‹ä½¿ç”¨" : "å…³é—­";

                            if (tabBtn.dataset.tab === 'help-about') {
                                clearTimeout(aboutClickTimer);
                                aboutClickCount++;
                                aboutClickTimer = setTimeout(() => aboutClickCount = 0, 2000);
                                if (aboutClickCount >= 5) {
                                    aboutClickCount = 0;
                                    clearTimeout(aboutClickTimer);
                                    this.activateDebugMode();
                                }
                            }
                        }
                    });
                    
                    this.elements.iconPickerCloseBtn.addEventListener('click', () => this.hideIconPicker());
                    this.elements.removeIconBtn.addEventListener('click', () => this.selectIcon(null));
                    this.elements.iconSearch.addEventListener('input', this.debounce((e) => this.renderIconGrid(e.target.value), 300));
                    this.elements.iconGrid.addEventListener('click', (e) => {
                        const item = e.target.closest('.icon-grid-item');
                        if (item) {
                            if (e.target.closest('.delete-custom-icon-btn')) {
                                this.deleteCustomIcon(item.dataset.iconName);
                            } else {
                                this.selectIcon(item.dataset.icon);
                            }
                        }
                    });
                    
                    this.elements.uploadIconBtn.addEventListener('click', () => this.elements.iconUploadInput.click());
                    this.elements.iconUploadInput.addEventListener('change', e => this.handleIconUpload(e));
                    this.elements.lockModeToggle.addEventListener('click', () => this.toggleLockMode());
                    
                    this.elements.layerList.addEventListener('click', e => {
                        const layerItemContainer = e.target.closest('.layer-item-container');
                        if (!layerItemContainer) return;

                        const layerItem = layerItemContainer.querySelector('.layer-item');
                        const cardItem = e.target.closest('.card-layer-item');
                        
                        // Action buttons on main layer item
                        const actionBtn = e.target.closest('.layer-actions button, .layer-toggle');
                        if (actionBtn) {
                            const blockId = layerItem.dataset.id;
                            if (actionBtn.matches('.toggle-visibility-btn')) {
                                this.toggleBlockVisibility(blockId);
                            } else if (actionBtn.matches('.duplicate-block-btn')) {
                                this.duplicateBlock(blockId);
                            } else if (actionBtn.matches('.layer-toggle')) {
                                layerItemContainer.classList.toggle('is-expanded');
                            }
                            return; // Prevent selection change on button click
                        }

                        // Click on a sub-card item
                        if (cardItem) {
                            const blockId = cardItem.closest('.layer-item-container').dataset.blockId;
                            const cardId = cardItem.dataset.cardId;
                            this.setSelection({ type: 'block', id: blockId, cardId: cardId });
                            const cardEditorEl = this.elements.inspectorPanel.querySelector(`.editor-card[data-card-id="${cardId}"]`);
                            if (cardEditorEl) {
                                cardEditorEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        } 
                        // Click on a main layer item
                        else {
                            const { type, id } = layerItem.dataset;
                            this.setSelection({ type, id });
                        }
                    });

                    this.elements.texturePickerCloseBtn.addEventListener('click', () => this.elements.texturePickerModal.classList.remove('visible'));
                    this.elements.removeTextureBtn.addEventListener('click', () => this.selectTexture(null));
                    this.elements.textureGrid.addEventListener('click', e => {
                        const item = e.target.closest('.texture-grid-item');
                        if (item) this.selectTexture(item.dataset.textureName);
                    });

                    this.elements.layerList.addEventListener('dblclick', e => {
                        const layerNameEl = e.target.closest('.layer-name');
                        const layerItem = e.target.closest('.layer-item');
                        if (!layerNameEl || !layerItem || layerItem.dataset.type === 'personalInfo' || this.isEditingText) return;
                        
                        this.isEditingText = true;
                        layerNameEl.contentEditable = true;
                        layerNameEl.focus();
                        document.execCommand('selectAll', false, null);

                        const handleEditEnd = () => {
                            this.isEditingText = false;
                            layerNameEl.contentEditable = false;
                            layerNameEl.removeEventListener('blur', handleEditEnd);
                            layerNameEl.removeEventListener('keydown', handleKeydown);
                            
                            const blockId = layerItem.dataset.id;
                            this.updateBlockTitle(blockId, layerNameEl.innerText, true);
                            const inspectorTitleInput = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${blockId}"] .editor-block-title-input`);
                            if (inspectorTitleInput) inspectorTitleInput.value = layerNameEl.innerText;
                        };
                        const handleKeydown = (ev) => {
                            if (ev.key === 'Enter') {
                                ev.preventDefault();
                                layerNameEl.blur();
                            } else if (ev.key === 'Escape') {
                                layerNameEl.innerText = this.findBlock(layerItem.dataset.id).title;
                                layerNameEl.blur();
                            }
                        };
                        layerNameEl.addEventListener('blur', handleEditEnd);
                        layerNameEl.addEventListener('keydown', handleKeydown);
                    });
                    
                    this.elements.colorContextMenu.addEventListener('click', e => {
                        const action = e.target.dataset.action;
                        const color = this.elements.colorContextMenu.dataset.color;
                        if(action && color) this.applyQuickColor(action, color);
                        this.hideColorContextMenu();
                    });
                    document.addEventListener('click', (e) => {
                        if (!e.target.closest('#color-context-menu')) {
                            this.hideColorContextMenu();
                        }
                    });
                },
                
                bindEditorEvents() {
                    const panel = this.elements.inspectorPanel;

                    panel.addEventListener('input', e => {
                        if (this.isRestoringState) return;
                        const target = e.target;
                        
                        if (target.matches('#font-search-input')) {
                            this.populateFontList(target.value);
                            return;
                        }

                        const updateSource = target.closest('[data-state-key], [data-setting-key], [data-card-key], [data-color-sync-key]');
                        if (!updateSource) return;

                        let value = target.type === 'checkbox' ? target.checked : (target.type === 'number' || target.type === 'range') ? parseFloat(target.value) : target.value;
                        
                        // ========== BUG FIX #2 START ==========
                        if (target.matches('.color-hex-input')) {
                            // Only return if the value is not empty AND it's an invalid format
                            if (target.value !== '' && !/^#([0-9A-F]{3,8})$/i.test(target.value)) {
                                return;
                            }
                            const colorInput = target.previousElementSibling;
                            if (colorInput) {
                                colorInput.value = value;
                            }
                        } 
                        // ========== BUG FIX #2 END ==========
                        else if (target.type === 'color') {
                            const hexInput = target.nextElementSibling;
                             if(hexInput && hexInput.matches('.color-hex-input')) hexInput.value = value;
                        }

                        const colorInput = target.closest('.input-group')?.querySelector('input[type="color"]');
                        const keySource = colorInput || target;

                        const stateKey = keySource.dataset.stateKey;
                        const blockEl = keySource.closest('.editor-block');
                        const settingKey = keySource.dataset.settingKey;
                        const cardKey = keySource.dataset.cardKey;
                        
                        if (stateKey) {
                            this.updateState(stateKey, value, false);
                        } else if (blockEl && settingKey) {
                             this.updateBlockSettings(blockEl.dataset.blockId, settingKey, value, false);
                        } else if (blockEl && cardKey) {
                            const cardEl = keySource.closest('.editor-card');
                            if (cardEl) this.updateCard(blockEl.dataset.blockId, cardEl.dataset.cardId, cardKey, value, false);
                        } else if (target.matches('.tag-manager-item .tag-text-input')) {
                            const tagItem = target.closest('.tag-manager-item');
                            if (tagItem) this.updateTag(tagItem.dataset.tagId, 'text', target.value, false);
                        }

                        if (target.type === 'range') {
                            const valueDisplay = target.closest('.form-group').querySelector('.angle-value, .spacer-height-value, #gCardRadiusValue');
                            if (valueDisplay) valueDisplay.textContent = value;
                        }
                    });

                    panel.addEventListener('change', e => {
                        if (this.isRestoringState) return;
                        const target = e.target;
                        
                        if (target.matches('.advanced-toggle')) {
                            target.closest('.editor-section, .editor-card-content').classList.toggle('show-advanced');
                            return;
                        }

                        if (target.dataset.stateKey || target.closest('.editor-block') || target.dataset.colorSyncKey || target.matches('.tag-manager-item .tag-text-input')) {
                            this.pushHistory();
                        }

                        const fileInputs = {
                            '#avatar-upload': 'avatar',
                            '#page-bg-upload': 'pageBg',
                            '#color-thief-upload': 'colorThief'
                        };
                        for (const selector in fileInputs) {
                            if (target.matches(selector)) this.handleImageUpload(e, fileInputs[selector]);
                        }
                        if (target.matches('#font-upload-input')) this.handleFontUpload(e);
                        if (target.matches('#config-file-input')) this.handleConfigFile(e);
                        if (target.matches('.card-bg-upload')) {
                           const cardEl = target.closest('.editor-card');
                           const blockEl = target.closest('.editor-block');
                           if (cardEl && blockEl) this.handleCardBgUpload(e, blockEl.dataset.blockId, cardEl.dataset.cardId);
                        }
                        if (target.matches('.image-upload-input')) {
                            const blockEl = target.closest('.editor-block');
                            if (blockEl) {
                                this.handleImageGalleryUpload(blockEl.dataset.blockId, e.target.files);
                                e.target.value = '';
                            }
                        }
                        
                        if (target.matches('#hd-export-toggle, #custom-width-toggle, #custom-width-input, #export-rounded-corners-toggle, #export-corner-radius-input')) {
                            const customWidthToggle = panel.querySelector('#custom-width-toggle');
                            const customWidthInput = panel.querySelector('#custom-width-input');
                            const hdExportToggle = panel.querySelector('#hd-export-toggle');
                            const exportRoundedToggle = panel.querySelector('#export-rounded-corners-toggle');
                            const cornerRadiusInput = panel.querySelector('#export-corner-radius-input');

                            if (target.id === 'custom-width-toggle') {
                                customWidthInput.disabled = !target.checked;
                                if (target.checked) hdExportToggle.checked = false;
                            }
                            
                            if (target.id === 'hd-export-toggle' && target.checked) {
                                customWidthToggle.checked = false;
                                customWidthInput.disabled = true;
                            }
    
                            if (target.id === 'export-rounded-corners-toggle') {
                                cornerRadiusInput.disabled = !target.checked;
                            }
    
                            this.updateExportSizePreview();
                        }

                        if (target.matches('[name^="block-layout"]')) {
                            const blockEl = target.closest('.editor-block');
                            if (blockEl) {
                                const masonryToggle = blockEl.querySelector('.masonry-toggle-container');
                                if (masonryToggle) masonryToggle.style.display = ['dual', 'triple'].includes(target.value) ? 'block' : 'none';
                            }
                            this.renderInspector();
                        }

                        if (target.matches('[data-card-key="followGlobalOpacity"]')) {
                            const opacitySliderGroup = target.closest('.editor-card-content').querySelector('.advanced-setting.opacity-control');
                            if (opacitySliderGroup) opacitySliderGroup.style.display = target.checked ? 'none' : 'block';
                        }
                    });
                    
                    panel.addEventListener('click', e => {
                        const target = e.target;

                        const legend = target.closest('.editor-section > legend');
                        if (legend) {
                            legend.parentElement.classList.toggle('collapsed');
                            return; 
                        }

                        const actionButton = target.closest('button, .back-to-global-btn');
                        if (!actionButton) return;
                        
                        const actions = {
                            '#undo-btn': () => this.undo(),
                            '#redo-btn': () => this.redo(),
                            '#import-btn': () => panel.querySelector('#config-file-input')?.click(),
                            '#export-btn': () => this.exportConfig(false),
                            '#export-template-btn': () => this.exportConfig(true),
                            '#export-png-btn': () => this.exportPNG(),
                            '#load-local-fonts-btn': () => this.loadLocalFonts(),
                            '#upload-font-btn': () => panel.querySelector('#font-upload-input')?.click(),
                            '#add-new-tag-btn': () => this.addNewTag(),
                            '#show-texture-picker-btn': () => this.initTexturePicker(),
                            '#clear-texture-btn': () => this.selectTexture(null),
                            '.back-to-global-btn': () => this.setSelection({type: 'global'}),
                            '#reset-btn': () => this.resetToDefault(),
                            '#clear-page-bg-btn': () => {
                                this.updateState('pageStyles.pageBgImageDataUrl', null, true);
                                this.showToast('èƒŒæ™¯å›¾å·²æ¸…é™¤', 'info');
                            },
                            '#pick-color-btn': () => panel.querySelector('#color-thief-upload')?.click(),
                        };
                        for(const selector in actions) {
                            if (actionButton.matches(selector)) {
                                actions[selector]();
                                return;
                            }
                        }

                        if (actionButton.dataset.preset) this.applyPreset(this.presets[actionButton.dataset.preset]);
                        
                        if (actionButton.dataset.resetKey) {
                            const keyPath = actionButton.dataset.resetKey;
                            const keyMap = { nicknameColor: 'pNicknameColor', subtitleColor: 'pSubtitleColor', bioColor: 'pBioColor', tagBgColor: 'pTagBgColor', tagTextColor: 'pTagTextColor' };
                            const basePreset = this.presets.light;
                            const key = keyPath.split('.')[1];
                            const defaultValue = basePreset[keyMap[key]] || '#ffffff';
                            this.updateState(keyPath, defaultValue, true);
                            this.showToast('é¢œè‰²å·²é‡ç½®', 'info');
                        }
                        
                        const tagItem = target.closest('.tag-manager-item');
                        if (tagItem) {
                            if (target.closest('.tag-icon-btn')) { this.initIconPicker(); this.showIconPicker('tag', tagItem.dataset.tagId); }
                            if (target.closest('.tag-delete-btn')) this.deleteTag(tagItem.dataset.tagId);
                        }
                        
                        const blockEl = target.closest('.editor-block');
                        if (blockEl) {
                            const blockId = blockEl.dataset.blockId;
                            if (target.closest('.block-delete-btn')) { this.deleteBlock(blockId); }
                            else if (target.closest('.add-card-btn')) this.addCard(blockId);
                            else if (target.closest('.add-image-btn')) this.addImageCard(blockId);
                            
                            const cardEl = target.closest('.editor-card');
                            if (cardEl) {
                                const cardId = cardEl.dataset.cardId;
                                if (target.closest('.card-delete-btn')) this.deleteCard(blockId, cardId);
                                else if (target.closest('.card-clear-bg-btn')) {
                                    this.updateCard(blockId, cardId, 'bgImageDataUrl', null, true);
                                    this.showToast('å¡ç‰‡èƒŒæ™¯å›¾å·²æ¸…é™¤', 'info');
                                }
                                else if (target.closest('.crop-image-btn')) this.cropImage(blockId, cardId);
                                else if (target.closest('.select-icon-btn')) { 
                                    this.initIconPicker();
                                    this.showIconPicker('card', blockId, cardId);
                                }
                                else if(target.closest('[data-reset-card-key]')) {
                                    const keyToReset = target.closest('[data-reset-card-key]').dataset.resetCardKey;
                                    this.updateCard(blockId, cardId, keyToReset, null, true);
                                    this.showToast('å·²é‡ç½®ä¸ºå…¨å±€æ ·å¼', 'info');
                                }
                            } else if (target.closest('.select-icon-btn[data-separator-icon-btn]')) {
                                this.initIconPicker();
                                this.showIconPicker('separator', blockId);
                            } else if (target.closest('[data-reset-block-key]')) {
                                const keyToReset = target.closest('[data-reset-block-key]').dataset.resetBlockKey;
                                this.updateBlockSettings(blockId, keyToReset, null, true);
                                this.showToast('å·²é‡ç½®', 'info');
                            }
                        }
                        
                        const tabBtn = target.closest('.tabs .tab-btn');
                        if (tabBtn) {
                            const parent = tabBtn.closest('.tab-group-wrapper, .editor-section > .section-content');
                            if (!parent) return;
                            parent.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                            tabBtn.classList.add('active');
                            parent.querySelectorAll(':scope > .tab-content').forEach(content => content.classList.remove('active'));
                            const targetTab = parent.querySelector(`#${tabBtn.dataset.tab}`);
                            if (targetTab) targetTab.classList.add('active');
                            
                            const newMode = tabBtn.dataset.tab.includes('gradient') ? 'gradient' : 'solid';
                            if (parent.closest('#global-card-styles-section')) {
                                this.updateState('globalCardStyles.bgMode', newMode, true);
                            } else if (parent.closest('#page-styles-section')) {
                                if (tabBtn.dataset.tab.startsWith('page-bg')) {
                                    this.updateState('pageStyles.pageBgMode', newMode, true);
                                } else if (tabBtn.dataset.tab.startsWith('header-bg')) {
                                    this.updateState('pageStyles.headerBgMode', newMode, true);
                                }
                            }
                        }
                    });
                },

                bindPreviewEvents(){
                     this.elements.previewPanel.addEventListener('click', e => {
                        if (this.isEditingText) return;
                        
                        const header = e.target.closest('.preview-header');
                        if (header) {
                            this.setSelection({ type: 'personalInfo' });
                            return;
                        }

                        const blockWrapper = e.target.closest('.preview-block-wrapper');
                        if (blockWrapper && blockWrapper.dataset.blockId) {
                            const cardWrapper = e.target.closest('.preview-card, figure');
                            const cardId = cardWrapper ? cardWrapper.dataset.cardId : null;
                            this.setSelection({ type: 'block', id: blockWrapper.dataset.blockId, cardId: cardId });
                            if (cardId) {
                                const cardEditorEl = this.elements.inspectorPanel.querySelector(`.editor-card[data-card-id="${cardId}"]`);
                                if (cardEditorEl) {
                                    cardEditorEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        } else {
                            if (e.target.closest('.preview-wrapper')) {
                                this.setSelection({ type: 'global' });
                            }
                        }
                     });

                     this.elements.previewWrapper.addEventListener('dblclick', e => {
                        if (this.elements.previewBlocksContainer.classList.contains('locked-mode')) return;
                        const target = e.target.closest('[data-state-key], [data-card-key], [data-tag-id], [data-separator-text-key]');
                        if (target && !this.isEditingText) {
                            this.isEditingText = true;
                            target.contentEditable = true;
                            target.focus();
                            document.execCommand('selectAll', false, null);

                            const handleEditEnd = () => {
                                target.contentEditable = false;
                                this.isEditingText = false;
                                target.removeEventListener('blur', handleEditEnd);
                                target.removeEventListener('keydown', handleKeydown);
                                
                                this.pushHistory();

                                const blockEl = target.closest('.preview-block-wrapper');
                                if (blockEl && this.masonryInstances[blockEl.dataset.blockId]) {
                                    this.masonryInstances[blockEl.dataset.blockId].layout();
                                }
                            };
                            
                            const handleKeydown = (ev) => {
                                if (ev.key === 'Enter' && !ev.shiftKey) {
                                    ev.preventDefault();
                                    target.blur();
                                }
                            };

                            target.addEventListener('blur', handleEditEnd);
                            target.addEventListener('keydown', handleKeydown);
                        }
                    });
                    
                    this.elements.previewWrapper.addEventListener('input', e => {
                        const target = e.target;
                        if (target.contentEditable === 'true') {
                            const stateKey = target.dataset.stateKey;
                            const cardKey = target.dataset.cardKey;
                            const separatorKey = target.dataset.separatorTextKey;
                            const value = target.innerText;

                            const updateStateObject = (path, val) => {
                                let obj = this.state;
                                const keys = path.split('.');
                                for (let i = 0; i < keys.length - 1; i++) { obj = obj?.[keys[i]]; }
                                if(obj) obj[keys[keys.length - 1]] = val;
                            };

                            if (stateKey) {
                                updateStateObject(stateKey, value);
                                this.syncControl(stateKey);
                            } else if (cardKey) {
                                const cardEl = target.closest('.preview-card, figure');
                                const blockEl = target.closest('.preview-block-wrapper');
                                if (cardEl && blockEl) {
                                    const block = this.findBlock(blockEl.dataset.blockId);
                                    const card = block?.cards.find(c => c.id === cardEl.dataset.cardId);
                                    if(card) card[cardKey] = value;
                                    const editorInput = this.elements.inspectorPanel.querySelector(`.editor-card[data-card-id="${cardEl.dataset.cardId}"] [data-card-key="${cardKey}"]`);
                                    if(editorInput) editorInput.value = value;
                                    this.renderLayerPanel(); // Update card title in layer panel
                                }
                            } else if (separatorKey) {
                                const block = this.findBlock(separatorKey);
                                if(block) block.settings.text = value;
                                const editorInput = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${separatorKey}"] [data-setting-key="text"]`);
                                if(editorInput) editorInput.value = value;
                            }
                        }
                    });
                },

                initResizer() {
                     const resizer = this.elements.resizer;
                        const inspectorPanel = this.elements.inspectorPanel;
                        let isResizing = false;
                    
                        resizer.addEventListener('mousedown', (e) => {
                            isResizing = true;
                            document.body.style.cursor = 'col-resize';
                            document.body.style.userSelect = 'none';
                    
                            document.addEventListener('mousemove', handleMouseMove);
                            document.addEventListener('mouseup', stopResize);
                        });
                    
                        const handleMouseMove = (e) => {
                            if (!isResizing) return;
                            const newWidth = window.innerWidth - e.clientX;
                            if (newWidth > 350 && newWidth < window.innerWidth * 0.6) {
                                inspectorPanel.style.width = `${newWidth}px`;
                                this.relayoutAllMasonry();
                            }
                        };
                    
                        const stopResize = () => {
                            isResizing = false;
                            document.body.style.cursor = 'default';
                            document.body.style.userSelect = 'auto';
                            document.removeEventListener('mousemove', handleMouseMove);
                            document.removeEventListener('mouseup', stopResize);
                            this.updateExportSizePreview();
                        };
                },

                relayoutAllMasonry() {
                    Object.values(this.masonryInstances).forEach(m => m && m.layout());
                    this.updateExportSizePreview();
                },

                renderAll(isInitial = false) {
                    this.updateGlobalCardStyleVars();
                    this.renderPersonalInfo();
                    this.renderPageStyles();
                    this.renderLayerPanel();
                    this.renderInspector();
                    this.renderPreviewBlocks();
                },
                
                renderPersonalInfo() {
                    const info = this.state.personalInfo;
                    this.elements.previewAvatar.src = info.avatarDataUrl;
                    this.elements.previewNickname.textContent = info.nickname;
                    this.elements.previewSubtitle.textContent = info.subtitle;
                    this.elements.previewBio.textContent = info.bio;
                    
                    this.elements.previewNickname.style.color = info.nicknameColor;
                    this.elements.previewSubtitle.style.color = info.subtitleColor;
                    this.elements.previewBio.style.color = info.bioColor;

                    this.elements.previewAvatar.style.borderRadius = info.avatarShape;
                    this.elements.previewAvatar.style.borderWidth = `${info.avatarBorderSize}px`;
                    this.elements.previewAvatar.style.borderColor = info.avatarBorderColor;
                    
                    this.elements.previewHeader.style.boxShadow = 'none';

                    this.elements.previewTagsContainer.innerHTML = (info.tags || [])
                        .map(tag => {
                            const iconHTML = tag.icon ? `<span class="iconify" data-icon="${tag.icon}"></span>` : '';
                            return `<span class="tag-pill" data-tag-id="${tag.id}" style="background-color:${info.tagBgColor}; color:${info.tagTextColor};">${iconHTML}<span>${this.escapeHTML(tag.text)}</span></span>`;
                        }).join('');
                },
                
                renderPageStyles() {
                    const styles = this.state.pageStyles;
                    const wrapper = this.elements.previewWrapper;
                    
                    let bgLayers = [];
                    let bgSizes = [];
                    let bgPositions = [];
                    let bgColor = 'transparent';

                    if (styles.pageBgPattern) {
                        const pattern = HeroPatterns.find(p => p.name === styles.pageBgPattern);
                        if(pattern) {
                            const coloredSvg = pattern.svg(styles.pageBgPatternColor, styles.pageBgPatternOpacity);
                            const base64Svg = btoa(unescape(encodeURIComponent(coloredSvg)));
                            bgLayers.push(`url("data:image/svg+xml;base64,${base64Svg}")`);
                            bgSizes.push(`${styles.pageBgPatternDensity}px`);
                            bgPositions.push('center');
                        }
                    }

                    if (styles.pageBgImageDataUrl) {
                        const overlayOpacity = parseFloat(styles.pageOverlayOpacity);
                        if (overlayOpacity > 0) {
                            const finalOverlayColor = this.hexToRgba(styles.pageOverlayColor, overlayOpacity);
                            bgLayers.push(`linear-gradient(${finalOverlayColor}, ${finalOverlayColor})`);
                            bgSizes.push('cover');
                            bgPositions.push('center');
                        }
                    }
                    
                    if (styles.pageBgImageDataUrl) {
                        bgLayers.push(`url(${styles.pageBgImageDataUrl})`);
                        bgSizes.push('cover');
                        bgPositions.push('center');
                    }
                    
                    if (styles.pageBgMode === 'gradient') {
                        bgLayers.push(`linear-gradient(${styles.pageBgGradientAngle}deg, ${styles.pageBgGradientStart}, ${styles.pageBgGradientEnd})`);
                        bgSizes.push('cover');
                        bgPositions.push('center');
                    } else {
                        bgColor = styles.pageBgSolidColor;
                    }

                    wrapper.style.backgroundColor = bgColor;
                    wrapper.style.backgroundImage = bgLayers.join(', ');
                    wrapper.style.backgroundSize = bgSizes.join(', ');
                    wrapper.style.backgroundPosition = bgPositions.join(', ');

                    if (styles.headerBgMode === 'gradient') {
                        const gradient = `linear-gradient(${styles.headerBgGradientAngle}deg, ${this.hexToRgba(styles.headerBgGradientStart, styles.headerOpacity)}, ${this.hexToRgba(styles.headerBgGradientEnd, styles.headerOpacity)})`;
                        this.elements.previewHeader.style.background = gradient;
                    } else {
                        this.elements.previewHeader.style.background = this.hexToRgba(styles.headerBgColor, styles.headerOpacity);
                    }
                    this.elements.previewHeader.style.color = styles.headerTextColor;

                    this.elements.previewNickname.style.color = this.state.personalInfo.nicknameColor;
                    this.elements.previewSubtitle.style.color = this.state.personalInfo.subtitleColor;
                    this.elements.previewBio.style.color = this.state.personalInfo.bioColor;
                    
                    const pageImageControls = document.getElementById('page-image-controls');
                    const pageTextureControls = document.getElementById('page-texture-controls');
                    if (pageImageControls) pageImageControls.style.display = styles.pageBgImageDataUrl ? 'block' : 'none';
                    if (pageTextureControls) pageTextureControls.style.display = styles.pageBgPattern ? 'block' : 'none';
                },

                renderLayerPanel() {
                    const list = this.elements.layerList;
                    const {type, id, cardId} = this.selection;
                    
                    let html = `<div class="layer-item-container">
                                    <div class="layer-item ${type === 'personalInfo' ? 'selected' : ''}" data-type="personalInfo">
                                        <button class="layer-toggle"></button>
                                        <span class="layer-icon iconify" data-icon="mdi:account-circle-outline"></span>
                                        <span class="layer-name">ä¸ªäººä¿¡æ¯</span>
                                    </div>
                               </div><hr>`;

                    html += this.state.blocks.map(b => {
                        const iconMap = { text: 'mdi:format-text-variant-outline', image: 'mdi:image-multiple-outline', separator: 'mdi:minus', spacer: 'mdi:arrow-expand-vertical' };
                        const isHidden = b.isVisible === false;
                        const isExpandable = (b.type === 'text' || b.type === 'image') && b.cards && b.cards.length > 0;
                        
                        const cardsListHTML = isExpandable ? `<ul class="card-layer-list" data-block-id="${b.id}">
                            ${b.cards.map(c => `<li class="card-layer-item ${cardId === c.id ? 'selected' : ''}" data-card-id="${c.id}">${this.escapeHTML(c.title) || 'æ— æ ‡é¢˜å¡ç‰‡'}</li>`).join('')}
                        </ul>` : '';

                        return `<div class="layer-item-container ${isExpandable ? 'is-expandable' : ''}" data-block-id="${b.id}">
                                    <div class="layer-item ${type === 'block' && id === b.id ? 'selected' : ''} ${isHidden ? 'is-hidden': ''}" data-type="block" data-id="${b.id}">
                                        <button class="layer-toggle"><span class="iconify" data-icon="mdi:chevron-right"></span></button>
                                        <span class="layer-icon iconify" data-icon="${iconMap[b.type]}"></span>
                                        <span class="layer-name">${this.escapeHTML(b.title)}</span>
                                        <div class="layer-actions">
                                            <button class="btn-icon toggle-visibility-btn" title="åˆ‡æ¢æ˜¾ç¤º/éšè—"><span class="iconify" data-icon="${isHidden ? 'mdi:eye-off' : 'mdi:eye'}"></span></button>
                                            <button class="btn-icon duplicate-block-btn" title="å¤åˆ¶æ ·å¼"><span class="iconify" data-icon="mdi:content-copy"></span></button>
                                        </div>
                                    </div>
                                    ${cardsListHTML}
                                </div>`;
                    }).join('');
                    
                    list.innerHTML = html;
                    this.initNestedSortables();
                },

                renderInspector() {
                    const panel = this.elements.inspectorPanel;
                    const { type, id } = this.selection;
                    let html = '';

                    switch(type) {
                        case 'personalInfo':
                            html = this.createPersonalInfoInspectorHTML();
                            break;
                        case 'block':
                            const block = this.findBlock(id);
                            if (block) html = this.createEditorBlockHTML(block);
                            break;
                        default:
                            html = this.createGlobalInspectorHTML();
                    }

                    panel.innerHTML = html;
                    
                    if (this.selection.type === 'global') {
                        this.populateFontList();
                        this.bindColorThiefEvents();
                        if (this.lastPalette && this.lastPalette.length > 0) {
                            this.renderPalette(this.lastPalette);
                        }
                    }
                    
                    this.syncAllControls();
                    this.updateUndoRedoButtons();

                    if (type === 'block') {
                        const block = this.findBlock(id);
                        if (block.type === 'text') {
                            this.initSortableCards(id);
                        } else if (block.type === 'image') {
                            this.initSortableImageCards(id);
                        }
                    } else if (type === 'personalInfo') {
                        this.renderTagManager();
                        this.initSortableTags();
                    }
                },

                createGlobalInspectorHTML() {
                    const backBtn = this.selection.type !== 'global' ? `<button class="back-to-global-btn">â† è¿”å›å…¨å±€</button>` : '';
                    return `
                        <h3 class="panel-header">å…¨å±€æ ·å¼ä¸å¯¼å‡º ${backBtn}</h3>
                        <div class="inspector-state active">
                             <fieldset class="editor-section">
                                <legend>é¡µé¢ä¸å¤´éƒ¨æ ·å¼</legend>
                                <div class="section-content">
                                    <div class="tab-group-wrapper">
                                        <div class="section-header">
                                            <h4>é¡µé¢èƒŒæ™¯</h4>
                                            <label class="checkbox-group advanced-toggle-label"><input type="checkbox" class="advanced-toggle"> é«˜çº§</label>
                                        </div>
                                        <div class="tabs"><button class="tab-btn" data-tab="page-bg-solid">çº¯è‰²/å›¾ç‰‡</button><button class="tab-btn" data-tab="page-bg-gradient">æ¸å˜</button></div>
                                        <div id="page-bg-solid" class="tab-content"><div class="form-group"><label>é¡µé¢èƒŒæ™¯é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgSolidColor"><input type="text" class="color-hex-input" data-state-key="pageStyles.pageBgSolidColor"></div></div><div class="form-group"><label>èƒŒæ™¯å›¾ (å¯é€‰):</label><div class="input-group simple"><input type="file" id="page-bg-upload" accept="image/*" style="width:100%"><button id="clear-page-bg-btn" class="btn btn-default btn-small">æ¸…é™¤</button></div></div>
                                        <div id="page-image-controls" class="advanced-setting" style="display:none;"><div class="form-group"><label>å›¾ç‰‡é®ç½©é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageOverlayColor"><input type="text" class="color-hex-input" data-state-key="pageStyles.pageOverlayColor"></div></div><div class="form-group"><label>å›¾ç‰‡é®ç½©ä¸é€æ˜åº¦:</label><input type="range" data-state-key="pageStyles.pageOverlayOpacity" min="0" max="1" step="0.05"></div></div></div>
                                        <div id="page-bg-gradient" class="tab-content"><div class="gradient-controls"><div class="form-group"><label>èµ·å§‹é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgGradientStart"><input type="text" class="color-hex-input" data-state-key="pageStyles.pageBgGradientStart"></div></div><div class="form-group"><label>ç»“æŸé¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgGradientEnd"><input type="text" class="color-hex-input" data-state-key="pageStyles.pageBgGradientEnd"></div></div><div class="gradient-angle-control form-group advanced-setting"><label>è§’åº¦ (<span class="angle-value">135</span>Â°):</label><input type="range" data-state-key="pageStyles.pageBgGradientAngle" min="0" max="360" step="1"></div></div></div>
                                        <div class="form-group advanced-setting" style="margin-top: 10px;"><button id="show-texture-picker-btn" class="btn btn-default">ğŸ¨ æ·»åŠ çº¹ç†</button></div>
                                        <div id="page-texture-controls" class="inset-controls advanced-setting" style="display:none;"><div class="form-group"><label>å½“å‰çº¹ç†: <span id="current-texture-name">æ— </span></label><button id="clear-texture-btn" class="btn btn-default btn-small">æ¸…é™¤çº¹ç†</button></div><div class="color-control-row"><div class="color-control-group"><label>çº¹ç†é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgPatternColor"><input type="text" class="color-hex-input" data-state-key="pageStyles.pageBgPatternColor"></div></div><div class="color-control-group"><label>çº¹ç†ä¸é€æ˜åº¦:</label><input type="range" data-state-key="pageStyles.pageBgPatternOpacity" min="0" max="1" step="0.05"></div></div><div class="form-group"><label>çº¹ç†å¯†åº¦:</label><input type="range" data-state-key="pageStyles.pageBgPatternDensity" min="10" max="100" step="2"></div></div>
                                    </div>
                                    <hr class="separator">
                                    <div class="tab-group-wrapper">
                                        <h4>å¤´éƒ¨èƒŒæ™¯</h4>
                                        <div class="tabs"><button class="tab-btn" data-tab="header-bg-solid">çº¯è‰²</button><button class="tab-btn" data-tab="header-bg-gradient">æ¸å˜</button></div>
                                        <div id="header-bg-solid" class="tab-content"><div class="form-group"><label>å¤´éƒ¨èƒŒæ™¯é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerBgColor"><input type="text" class="color-hex-input" data-state-key="pageStyles.headerBgColor"></div></div></div>
                                        <div id="header-bg-gradient" class="tab-content"><div class="gradient-controls"><div class="form-group"><label>èµ·å§‹é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerBgGradientStart"><input type="text" class="color-hex-input" data-state-key="pageStyles.headerBgGradientStart"></div></div><div class="form-group"><label>ç»“æŸé¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerBgGradientEnd"><input type="text" class="color-hex-input" data-state-key="pageStyles.headerBgGradientEnd"></div></div><div class="gradient-angle-control form-group advanced-setting"><label>è§’åº¦ (<span class="angle-value">135</span>Â°):</label><input type="range" data-state-key="pageStyles.headerBgGradientAngle" min="0" max="360" step="1"></div></div></div>
                                        <div class="form-group"><label>å¤´éƒ¨æ–‡å­—é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerTextColor"><input type="text" class="color-hex-input" data-state-key="pageStyles.headerTextColor"></div></div>
                                        <div class="form-group advanced-setting"><label>å¤´éƒ¨ä¸é€æ˜åº¦:</label><input type="range" data-state-key="pageStyles.headerOpacity" min="0" max="1" step="0.05"></div>
                                    </div>
                                </div>
                            </fieldset>
                            <fieldset class="editor-section" id="color-thief-section">
                                <legend>ğŸ¨ æ™ºèƒ½å–è‰²</legend>
                                <div class="section-content">
                                    <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: -10px; margin-bottom: 15px;">ä¸Šä¼ å›¾ç‰‡ï¼Œè‡ªåŠ¨æå–è°ƒè‰²æ¿ã€‚å³é”® (PC) æˆ–é•¿æŒ‰ (æ‰‹æœº) è‰²å—å¯å¿«æ·åº”ç”¨ã€‚</p>
                                    <button id="pick-color-btn" class="btn btn-default">ä¸Šä¼ å›¾ç‰‡åˆ†æé¢œè‰²</button>
                                    <input type="file" id="color-thief-upload" accept="image/*" style="display: none;">
                                    <div class="palette-container" id="color-thief-palette"></div>
                                </div>
                            </fieldset>
                            <fieldset class="editor-section" id="global-card-styles-section"> 
                                <legend>å…¨å±€å¡ç‰‡æ ·å¼</legend>
                                <div class="section-content">
                                    <div class="section-header">
                                        <h4></h4>
                                        <label class="checkbox-group advanced-toggle-label"><input type="checkbox" class="advanced-toggle"> é«˜çº§</label>
                                    </div>
                                    <div class="tabs"><button class="tab-btn" data-tab="card-bg-solid">çº¯è‰²</button><button class="tab-btn" data-tab="card-bg-gradient">æ¸å˜</button></div>
                                    <div id="card-bg-solid" class="tab-content"><div class="color-control-row"><div class="color-control-group"><label>èƒŒæ™¯è‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.bgColor"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.bgColor"></div></div><div class="color-control-group"><label>æ–‡å­—é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.textColor"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.textColor"></div></div></div></div>
                                    <div id="card-bg-gradient" class="tab-content"><div class="gradient-controls"><div class="form-group"><label>èµ·å§‹é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.bgGradientStart"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.bgGradientStart"></div></div><div class="form-group"><label>ç»“æŸé¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.bgGradientEnd"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.bgGradientEnd"></div></div><div class="gradient-angle-control form-group advanced-setting"><label>è§’åº¦ (<span class="angle-value">135</span>Â°):</label><input type="range" data-state-key="globalCardStyles.bgGradientAngle" min="0" max="360" step="1"></div></div></div>
                                    <div class="form-group"><label>ä¸é€æ˜åº¦:</label><input type="range" data-state-key="globalCardStyles.opacity" min="0" max="1" step="0.05"></div>
                                    <div class="form-group"><label>åœ†è§’ (px): <span id="gCardRadiusValue">12</span></label><input type="range" data-state-key="globalCardStyles.radius" min="0" max="40" step="1"></div>
                                    <div class="advanced-setting"><hr class="separator"><label>å¡ç‰‡è¾¹æ¡†:</label><div class="form-group inset-controls"><div class="form-group"><label>æ ·å¼:</label><select data-state-key="globalCardStyles.borderStyle"><option value="none">æ— </option><option value="solid">å®çº¿</option><option value="dashed">è™šçº¿</option><option value="dotted">ç‚¹çŠ¶</option></select></div><div class="color-control-row"><div class="color-control-group"><label>ç²—ç»†(px):</label><div class="input-group simple"><input type="range" data-state-key="globalCardStyles.borderWidth" min="0" max="10" step="1"></div></div><div class="color-control-group"><label>é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.borderColor"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.borderColor"></div></div></div></div></div>
                                    <hr class="separator"><div class="form-group"><label>å¯¹é½:</label><div class="radio-group"><label><input type="radio" name="gCardAlign" value="left" data-state-key="globalCardStyles.textAlign">å±…å·¦</label><label><input type="radio" name="gCardAlign" value="center" data-state-key="globalCardStyles.textAlign">å±…ä¸­</label><label><input type="radio" name="gCardAlign" value="right" data-state-key="globalCardStyles.textAlign">å±…å³</label></div></div>
                                    <div class="form-group"><label>è¡Œé«˜:</label><div class="radio-group"><label><input type="radio" name="gCardLineHeight" value="1.4" data-state-key="globalCardStyles.lineHeight">ç´§å‡‘</label><label><input type="radio" name="gCardLineHeight" value="1.5" data-state-key="globalCardStyles.lineHeight">ä¸­ç­‰</label><label><input type="radio" name="gCardLineHeight" value="1.6" data-state-key="globalCardStyles.lineHeight">å®½æ¾</label></div></div>
                                    <hr class="separator"><div class="form-group"><label>å­—ä½“:</label><div class="font-controls"><input type="text" id="font-search-input" placeholder="æœç´¢æœ¬åœ°å­—ä½“..." style="margin-bottom: 5px;"><select id="font-family-select" data-state-key="globalCardStyles.fontFamily"></select><div class="buttons"><button id="load-local-fonts-btn" class="btn btn-default">åŠ è½½æœ¬åœ°</button><button id="upload-font-btn" class="btn btn-default">ä¸Šä¼ å­—ä½“</button></div><input type="file" id="font-upload-input" accept=".ttf,.woff,.woff2,.otf" style="display: none;"></div></div>
                                    <div class="form-group"> <label>å­—å·:</label> <select data-state-key="globalCardStyles.fontSize"> <option value="0.9rem">å°</option> <option value="1rem" selected>ä¸­ (é»˜è®¤)</option> <option value="1.1rem">å¤§</option> </select> </div>
                                    <div class="advanced-setting"><div class="color-control-row"><div class="color-control-group"><label>æ–‡å­—æè¾¹(px):</label><div class="input-group simple"><input type="range" data-state-key="globalCardStyles.textStrokeWidth" min="0" max="5" step="0.5"></div></div><div class="color-control-group"><label>æè¾¹é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.textStrokeColor"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.textStrokeColor"></div></div></div></div>
                                </div>
                            </fieldset>
                            <fieldset class="editor-section">
                                <legend>æ“ä½œ</legend>
                                <div class="section-content">
                                    <div class="form-group" style="display: flex; gap: 10px;"> <button id="undo-btn" class="btn btn-default" disabled>æ’¤å›</button> <button id="redo-btn" class="btn btn-default" disabled>é‡åš</button> </div>
                                    <div class="form-group" style="display: flex; gap: 10px;"> <button id="import-btn" class="btn btn-secondary">å¯¼å…¥é…ç½®</button> <button id="export-btn" class="btn btn-secondary">å¯¼å‡ºé…ç½®</button> <button id="export-template-btn" class="btn btn-secondary">å­˜ä¸ºæ¨¡æ¿</button></div>
                                    <div class="form-group"><div class="checkbox-group" style="margin-bottom: 10px;"><label><input type="checkbox" id="hd-export-toggle"> è¶…æ¸…å¯¼å‡º (1800px)</label></div><div class="checkbox-group" style="margin-bottom: 10px;"><label><input type="checkbox" id="custom-width-toggle"> è‡ªå®šä¹‰å®½åº¦</label><input type="number" id="custom-width-input" value="1200" style="width: 80px; padding: 4px 8px;" disabled></div><div class="checkbox-group" style="margin-bottom: 10px;"><label><input type="checkbox" id="export-rounded-corners-toggle"> å¯¼å‡ºä¸ºåœ†è§’å›¾ç‰‡</label><input type="number" id="export-corner-radius-input" value="20" style="width: 60px; padding: 4px 8px;" disabled></div><div id="export-size-preview" style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 5px;"></div><button id="export-png-btn" class="btn btn-primary" style="margin-top:10px;">å¯¼å‡ºä¸ºå›¾ç‰‡ (1200px)</button></div>
                                    <hr class="separator"><div class="form-group"><label>é¢„è®¾ä¸»é¢˜:</label><div class="input-group simple"> <button data-preset="light" class="btn btn-default btn-small">æ˜äº®</button> <button data-preset="dark" class="btn btn-default btn-small">æš—é»‘</button> <button data-preset="mint" class="btn btn-default btn-small">è–„è·</button> <button data-preset="coffee" class="btn btn-default btn-small">å’–å•¡</button> </div></div>
                                    <div class="form-group"><button id="reset-btn" class="btn btn-danger">æ¢å¤é»˜è®¤æ¨¡æ¿</button></div>
                                    <input type="file" id="config-file-input" accept=".json" style="display: none;">
                                </div>
                            </fieldset>
                        </div>
                    `;
                },

                createPersonalInfoInspectorHTML() {
                    const backBtn = this.selection.type !== 'global' ? `<button class="back-to-global-btn">â† è¿”å›å…¨å±€</button>` : '';
                    return `
                        <h3 class="panel-header">ä¸ªäººä¿¡æ¯è®¾ç½® ${backBtn}</h3>
                        <div class="inspector-state active">
                             <fieldset class="editor-section">
                                <legend>ä¸ªäººä¿¡æ¯</legend>
                                <div class="section-content">
                                    <div class="form-group"><label>æ˜µç§°:</label><input type="text" data-state-key="personalInfo.nickname" data-preview-target="#preview-nickname"></div>
                                    <div class="form-group"><label>æ˜µç§°é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="personalInfo.nicknameColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.nicknameColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.nicknameColor">é‡ç½®</button></div></div>
                                    <div class="form-group"><label>å‰¯æ ‡é¢˜ (å¯é€‰):</label><input type="text" data-state-key="personalInfo.subtitle" data-preview-target="#preview-subtitle"></div>
                                    <div class="form-group"><label>å‰¯æ ‡é¢˜é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="personalInfo.subtitleColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.subtitleColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.subtitleColor">é‡ç½®</button></div></div>
                                    <div class="form-group"><label>ç®€ä»‹ (å¯é€‰):</label><textarea data-state-key="personalInfo.bio" rows="3" data-preview-target="#preview-bio"></textarea></div>
                                    <div class="form-group"><label>ç®€ä»‹é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="personalInfo.bioColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.bioColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.bioColor">é‡ç½®</button></div></div>
                                    <hr class="separator">
                                    <div class="form-group"><label>æ ‡ç­¾ç®¡ç†å™¨ (å¯æ‹–æ‹½æ’åº):</label><div id="tag-manager-list"></div><div class="input-group simple" style="margin-top: 10px;"><input type="text" id="new-tag-text-input" placeholder="è¾“å…¥æ–°æ ‡ç­¾æ–‡å­—..."><button id="add-new-tag-btn" class="btn btn-default btn-small">æ·»åŠ æ ‡ç­¾</button></div></div>
                                    <div class="form-group"><label>æ ‡ç­¾æ ·å¼:</label><div class="color-control-row"><div class="color-control-group"><label>èƒŒæ™¯</label><div class="input-group"><input type="color" data-state-key="personalInfo.tagBgColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.tagBgColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.tagBgColor">é‡ç½®</button></div></div><div class="color-control-group"><label>æ–‡å­—</label><div class="input-group"><input type="color" data-state-key="personalInfo.tagTextColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.tagTextColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.tagTextColor">é‡ç½®</button></div></div></div></div>
                                    <hr class="separator">
                                    <div class="form-group"><label>å¤´åƒä¸Šä¼ :</label><input type="file" id="avatar-upload" accept="image/*"></div>
                                    <div class="form-group"><label>å¤´åƒå½¢çŠ¶:</label><div class="radio-group"><label><input type="radio" name="avatarShape" value="50%" data-state-key="personalInfo.avatarShape">åœ†å½¢</label><label><input type="radio" name="avatarShape" value="16px" data-state-key="personalInfo.avatarShape">åœ†è§’</label><label><input type="radio" name="avatarShape" value="0px" data-state-key="personalInfo.avatarShape">æ–¹å½¢</label></div></div>
                                    <div class="form-group"><label>å¤´åƒè¾¹æ¡†:</label><div class="color-control-row"><div class="color-control-group"><label>ç²—ç»†(px):</label><div class="input-group simple"><input type="range" data-state-key="personalInfo.avatarBorderSize" min="0" max="10" step="1"></div></div><div class="color-control-group"><label>é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="personalInfo.avatarBorderColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.avatarBorderColor"></div></div></div></div>
                                </div>
                            </fieldset>
                        </div>
                    `;
                },

                renderPreviewBlocks() {
                    this.elements.previewBlocksContainer.innerHTML = this.state.blocks.length ? this.state.blocks.map(b => `<div class="preview-block-wrapper ${b.isVisible === false ? 'is-hidden' : ''}" data-block-id="${b.id}">${this.createPreviewBlockHTML(b)}</div>`).join('') : '<div class="empty-placeholder">(é¢„è§ˆåŒº) æ— åŒºå—</div>';
                    this.state.blocks.forEach(b => this.initMasonryForBlock(b.id));
                    this.updateHighlights();
                },

                createEditorBlockHTML(block) {
                    let content = '';
                    const backBtn = this.selection.type !== 'global' ? `<button class="back-to-global-btn">â† è¿”å›å…¨å±€</button>` : '';
                    const masonryCheckboxHTML = `
                        <div class="masonry-toggle-container" style="${['dual', 'triple'].includes(block.settings.layout) ? 'display: block;' : 'display: none;'}">
                            <div class="checkbox-group advanced-setting" style="margin-top: 10px;">
                                <label><input type="checkbox" data-setting-key="masonryEnabled" ${block.settings.masonryEnabled ? 'checked' : ''}> å¯ç”¨ç€‘å¸ƒæµ</label>
                            </div>
                        </div>`;
                    const layoutRadiosHTML = `
                        <div class="radio-group">
                            <label><input type="radio" data-setting-key="layout" name="block-layout-${block.id}" value="single" ${block.settings.layout === 'single' ? 'checked' : ''}> å•æ’</label>
                            <label><input type="radio" data-setting-key="layout" name="block-layout-${block.id}" value="dual" ${block.settings.layout === 'dual' ? 'checked' : ''}> åŒæ’</label>
                            <label><input type="radio" data-setting-key="layout" name="block-layout-${block.id}" value="triple" ${block.settings.layout === 'triple' ? 'checked' : ''}> ä¸‰æ’</label>
                        </div>`;

                    if (block.type === 'text') {
                        let cardsHTML = !block.cards?.length ? '<div class="empty-placeholder">æš‚æ— å¡ç‰‡</div>' : block.cards.map(c => `<div class="editor-card ${this.selection.cardId === c.id ? 'is-active' : ''}" data-card-id="${c.id}">${this.createEditorCardHTML(c)}</div>`).join('');
                        content = `<div class="form-group"><div class="section-header"><label>å¸ƒå±€:</label><label class="checkbox-group advanced-toggle-label"><input type="checkbox" class="advanced-toggle"> é«˜çº§</label></div>${layoutRadiosHTML}${masonryCheckboxHTML}</div>
                                   <hr class="separator"><div class="card-editors-list">${cardsHTML}</div><button class="btn btn-default add-card-btn" style="margin-top: 15px;">â• æ·»åŠ å¡ç‰‡</button>`;
                    } else if (block.type === 'image') {
                        let imageCardsHTML = !block.cards?.length ? '<div class="empty-placeholder">æš‚æ— å›¾ç‰‡</div>' : block.cards.map(c => `<div class="editor-card ${this.selection.cardId === c.id ? 'is-active' : ''}" data-card-id="${c.id}">${this.createEditorImageCardHTML(c)}</div>`).join('');
                        content = `<div class="form-group"><div class="section-header"><label>å¸ƒå±€:</label><label class="checkbox-group advanced-toggle-label"><input type="checkbox" class="advanced-toggle"> é«˜çº§</label></div>${layoutRadiosHTML}${masonryCheckboxHTML}</div>
                                   <div class="form-group"><label>æ–‡å­—é¢œè‰²:</label><div class="input-group"><input type="color" data-setting-key="textColor" value="${block.settings.textColor || ''}"><input type="text" class="color-hex-input" data-setting-key="textColor" value="${block.settings.textColor || ''}" placeholder="å…¨å±€é»˜è®¤"><button class="btn btn-default btn-small" data-reset-block-key="textColor">é‡ç½®</button></div></div>
                                   <hr class="separator"><div class="image-card-editors-list">${imageCardsHTML}</div><button class="btn btn-default add-image-btn" style="margin-top: 15px;">â• æ·»åŠ å›¾ç‰‡</button>
                                   <input type="file" class="image-upload-input" multiple accept="image/*" style="display: none;">`;
                    } else if (block.type === 'separator') {
                        const s = block.settings;
                        const iconHTML = s.icon ? `<span class="iconify" data-icon="${s.icon}"></span>` : 'é€‰æ‹©å›¾æ ‡';
                        // ========== BUG FIX #1 START ==========
                        content = `<div class="form-group"><label>æ ·å¼:</label><div class="radio-group"><label><input type="radio" name="sep-style-${block.id}" data-setting-key="style" value="solid" ${s.style==='solid'?'checked':''}>å®çº¿</label><label><input type="radio" name="sep-style-${block.id}" data-setting-key="style" value="dashed" ${s.style==='dashed'?'checked':''}>è™šçº¿</label><label><input type="radio" name="sep-style-${block.id}" data-setting-key="style" value="dotted" ${s.style==='dotted'?'checked':''}>ç‚¹çŠ¶</label></div></div><div class="color-control-row"><div class="color-control-group"><label>çº¿æ¡é¢œè‰²:</label><div class="input-group"><input type="color" data-setting-key="color" value="${s.color}"><input type="text" class="color-hex-input" data-setting-key="color" value="${s.color}"><button class="btn btn-default btn-small" data-reset-block-key="color">é‡ç½®</button></div></div><div class="color-control-group"><label>ç²—ç»†(px):</label><div class="input-group simple"><input type="range" data-setting-key="thickness" min="1" max="10" value="${s.thickness}"></div></div></div><div class="form-group"><label>å‚ç›´é—´è·(px):</label><div class="input-group simple"><input type="range" data-setting-key="margin" min="0" max="50" value="${s.margin}"></div></div><hr class="separator"><div class="form-group"><label>åµŒå…¥æ–‡æœ¬ (å¯é€‰):</label><div class="input-group"><input type="text" data-setting-key="text" value="${this.escapeHTML(s.text || '')}" style="border-right: none;"><button class="btn btn-default select-icon-btn" data-separator-icon-btn="true" style="width: auto; flex-shrink: 0; border-radius: 0 6px 6px 0;">${iconHTML}</button></div></div><div class="form-group"><label>æ–‡æœ¬é¢œè‰²:</label><div class="input-group"><input type="color" data-setting-key="textColor" value="${s.textColor}"><input type="text" class="color-hex-input" data-setting-key="textColor" value="${s.textColor}"><button class="btn btn-default btn-small" data-reset-block-key="textColor">é‡ç½®</button></div></div>`;
                        // ========== BUG FIX #1 END ==========
                    } else if (block.type === 'spacer') {
                        const s = block.settings;
                        content = `<div class="form-group"><label>é«˜åº¦ (px): <span class="spacer-height-value">${s.height}</span></label><div class="input-group simple"><input type="range" data-setting-key="height" min="1" max="200" value="${s.height}"></div></div>`;
                    }

                    return `<h3 class="panel-header">åŒºå—è®¾ç½® ${backBtn}</h3><div class="editor-block" data-block-id="${block.id}"><div class="editor-block-header"><input type="text" class="editor-block-title-input" value="${this.escapeHTML(block.title || '')}" placeholder="åŒºå—æ ‡é¢˜ (å¯ç¼–è¾‘)"><div class="block-actions"><button class="btn btn-danger btn-small block-delete-btn">åˆ é™¤</button></div></div><div class="editor-block-content">${content}</div></div>`;
                },

                createPreviewBlockHTML(block) {
                    let layoutClass = 'preview-cards-single';
                    if (block.settings.layout === 'dual') layoutClass = 'preview-cards-dual';
                    if (block.settings.layout === 'triple') layoutClass = 'preview-cards-triple';
                    
                    let cardsHTML = '';
                    if (block.type === 'text') {
                        cardsHTML = (block.cards || []).map(card => this.createPreviewCardHTML(card)).join('');
                    } else if (block.type === 'image') {
                        cardsHTML = (block.cards || []).map(card => this.createPreviewImageCardHTML(card, block.settings)).join('');
                    }

                    if (block.type === 'text' || block.type === 'image') {
                        return `<div class="preview-cards-container ${layoutClass}">${cardsHTML}</div>`;
                    } else if (block.type === 'separator') {
                         const s = block.settings;
                         const hasTextOrIcon = s.text || s.icon;
                         const iconHTML = s.icon ? `<span class="iconify" data-icon="${s.icon}" style="margin-right: 8px; vertical-align: -0.15em;"></span>` : '';
                         const textHTML = `<span data-separator-text-key="${block.id}" style="color: ${s.textColor}; padding: 0 12px; flex-shrink: 0;">${iconHTML}${this.escapeHTML(s.text || '')}</span>`;
                         const lineHTML = `<div class="separator-preview-line" style="flex-grow: 1; border-top: ${s.thickness}px ${s.style} ${s.color};"></div>`;
                         return `<div class="separator-preview" style="margin: ${s.margin}px 0;">${lineHTML}${hasTextOrIcon ? textHTML + lineHTML : ''}</div>`;
                    } else if (block.type === 'spacer') {
                        return `<div class="spacer-preview" style="height: ${block.settings.height}px;"></div>`;
                    }
                    return '';
                },

                createPreviewCardHTML(card) {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'preview-card';
                    cardEl.dataset.cardId = card.id;
                    cardEl.style.setProperty('--card-transition-name', `card-${card.id}`);
                    const iconHTML = card.icon ? `<span class="iconify" data-icon="${card.icon}"></span>` : '';
                    
                    const finalAlign = (card.textAlign === undefined || card.textAlign === '' || card.textAlign === null) ? this.state.globalCardStyles.textAlign : card.textAlign;
                    const justifyContent = { left: 'flex-start', center: 'center', right: 'flex-end' }[finalAlign] || 'flex-start';
                    
                    cardEl.innerHTML = `<div class="preview-card-inner">
                            <h3 class="preview-card-title" data-card-key="title" style="justify-content: ${justifyContent};">${iconHTML}${this.escapeHTML(card.title || '')}</h3>
                            <p class="preview-card-content" data-card-key="content">${this.escapeHTML(card.content || '')}</p>
                        </div>`;
                    this.applyCardStyles(cardEl, card);
                    return cardEl.outerHTML;
                },

                createPreviewImageCardHTML(card, blockSettings = {}) {
                    const textColorStyle = blockSettings.textColor ? `style="color: ${blockSettings.textColor};"` : '';
                    const figcaptionContent = (card.title || card.description) ? 
                        `<figcaption ${textColorStyle}>
                            ${card.title ? `<strong data-card-key="title">${this.escapeHTML(card.title)}</strong>` : ''}
                            <span data-card-key="description">${this.escapeHTML(card.description || '')}</span>
                        </figcaption>` 
                        : '';
                   return `<figure data-card-id="${card.id}"><img src="${card.url}" alt="${this.escapeHTML(card.title || '')}" loading="lazy">${figcaptionContent}</figure>`;
                },

                createEditorCardHTML(card) {
                    const s = (val, def) => val ?? def;
                    const followGlobalOpacity = card.followGlobalOpacity !== false;
                    const iconHTML = card.icon ? `<span class="iconify" data-icon="${card.icon}" style="font-size: 1.2em; vertical-align: middle; margin-right: 5px;"></span>` : 'é€‰æ‹©å›¾æ ‡';
                    const g = this.state.globalCardStyles;

                    return `<span class="card-drag-handle">â˜°</span><div class="editor-card-header"><button class="btn btn-danger btn-small card-delete-btn">åˆ </button></div>
                        <div class="editor-card-content">
                            <h4>åŸºç¡€è®¾ç½®</h4>
                            <div class="form-group"><label>æ ‡é¢˜:</label><div class="input-group"><input type="text" data-card-key="title" value="${this.escapeHTML(s(card.title, ''))}" style="border-right: none;"><button class="btn btn-default select-icon-btn" style="width: auto; flex-shrink: 0; border-radius: 0 6px 6px 0; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${iconHTML}</button></div></div>
                            <div class="form-group"><label>å†…å®¹:</label><textarea data-card-key="content" rows="4">${this.escapeHTML(s(card.content, ''))}</textarea></div>
                            <div class="form-group"><label>å¯¹é½:</label><div class="radio-group"><label><input type="radio" name="card-${card.id}-align" value="" data-card-key="textAlign" ${s(card.textAlign, '') === '' ? 'checked':''}>é»˜è®¤</label><label><input type="radio" name="card-${card.id}-align" value="left" data-card-key="textAlign" ${card.textAlign === 'left' ?'checked':''}>å·¦</label><label><input type="radio" name="card-${card.id}-align" value="center" data-card-key="textAlign" ${card.textAlign === 'center' ?'checked':''}>ä¸­</label><label><input type="radio" name="card-${card.id}-align" value="right" data-card-key="textAlign" ${card.textAlign === 'right' ?'checked':''}>å³</label></div></div>
                            <hr class="separator">
                            <div class="color-control-row">
                                <div class="color-control-group"><label>èƒŒæ™¯è‰²:</label><div class="input-group"><input type="color" data-card-key="bgColor" value="${s(card.bgColor, '')}"><input class="color-hex-input" type="text" data-card-key="bgColor" value="${s(card.bgColor, '')}" placeholder="${g.bgColor} (å…¨å±€)"><button class="btn btn-default btn-small" data-reset-card-key="bgColor">é‡ç½®</button></div></div>
                                <div class="color-control-group"><label>æ–‡å­—é¢œè‰²:</label><div class="input-group"><input type="color" data-card-key="textColor" value="${s(card.textColor, '')}"><input class="color-hex-input" type="text" data-card-key="textColor" value="${s(card.textColor, '')}" placeholder="${g.textColor} (å…¨å±€)"><button class="btn btn-default btn-small" data-reset-card-key="textColor">é‡ç½®</button></div></div>
                            </div>
                            <hr class="separator">
                            <div class="form-group"><label>èƒŒæ™¯å›¾:</label><div class="input-group simple"><input type="file" class="card-bg-upload" accept="image/*"><button class="btn btn-default btn-small card-clear-bg-btn">æ¸…é™¤</button></div></div>
                            <div class="card-overlay-controls" style="${card.bgImageDataUrl?'':'display:none;'}"><label>å›¾ç‰‡è’™ç‰ˆ:</label><div class="color-control-row"><div class="color-control-group"><label>é¢œè‰²:</label><div class="input-group"><input type="color" data-card-key="overlayColor" value="${s(card.overlayColor, '#ffffff')}"><input class="color-hex-input" type="text" data-card-key="overlayColor" value="${s(card.overlayColor, '#ffffff')}"></div></div><div class="color-control-group"><label>ä¸é€æ˜åº¦:</label><input type="range" data-card-key="overlayOpacity" min="0" max="1" step="0.05" value="${s(card.overlayOpacity,0.5)}"></div></div></div>
                        </div>`;
                },

                createEditorImageCardHTML(card) {
                    return `<span class="card-drag-handle">â˜°</span>
                        <div class="editor-card-header"><button class="btn btn-danger btn-small card-delete-btn">åˆ </button></div>
                        <div class="editor-card-content">
                            <div class="image-card-editor-content">
                                <div class="image-card-editor-thumb">
                                    <div class="thumbnail-wrapper">
                                        <img src="${card.url}" loading="lazy">
                                        <div class="thumbnail-actions">
                                            <button class="btn btn-icon crop-image-btn" title="è£å‰ª"><span class="iconify" data-icon="mdi:crop"></span></button>
                                        </div>
                                    </div>
                                </div>
                                <div class="image-card-editor-fields">
                                    <div class="form-group"><label>æ ‡é¢˜:</label><input type="text" data-card-key="title" value="${this.escapeHTML(card.title || '')}"></div>
                                    <div class="form-group"><label>æè¿°:</label><textarea data-card-key="description" rows="2">${this.escapeHTML(card.description || '')}</textarea></div>
                                </div>
                            </div>
                        </div>`;
                },
                
                applyCardStyles(cardEl, cardData) {
                    const g = this.state.globalCardStyles;
                    const use = (key, val) => (val === undefined || val === null || val === '') ? g[key] : val;
                    
                    const followGlobalOpacity = cardData.followGlobalOpacity !== false;
                    const finalOpacity = followGlobalOpacity ? g.opacity : (cardData.opacity ?? 1.0);
                    
                    const innerEl = cardEl.querySelector('.preview-card-inner');
                    if (!innerEl) return;
                    
                    if (parseFloat(finalOpacity) < 0.01) {
                        innerEl.style.setProperty('--card-bg-final', 'transparent');
                        innerEl.style.boxShadow = 'none';
                        innerEl.style.border = 'var(--active-card-border)'; 
                    } else {
                        const finalTextColor = use('textColor', cardData.textColor);
                        let finalBg;
                        if (cardData.bgImageDataUrl) {
                            finalBg = `url(${cardData.bgImageDataUrl})`;
                        } else if (cardData.bgColor) {
                            finalBg = this.hexToRgba(cardData.bgColor, finalOpacity);
                        } else {
                            if (g.bgMode === 'gradient') {
                                finalBg = `linear-gradient(${g.bgGradientAngle}deg, ${this.hexToRgba(g.bgGradientStart, finalOpacity)}, ${this.hexToRgba(g.bgGradientEnd, finalOpacity)})`;
                            } else {
                                finalBg = this.hexToRgba(g.bgColor, finalOpacity);
                            }
                        }
                        
                        innerEl.style.setProperty('--card-bg-final', finalBg);
                        innerEl.style.setProperty('--card-text-color', finalTextColor);
                        innerEl.style.textAlign = use('textAlign', cardData.textAlign);
                        innerEl.style.fontSize = cardData.fontSize || 'inherit'; 
                        innerEl.style.setProperty('--card-font-weight', cardData.fontWeight || 'normal');
                        innerEl.style.setProperty('--active-card-text-shadow', 'none');
                        
                        innerEl.style.setProperty('--card-overlay-color', cardData.overlayColor || '#FFF');
                        const overlayOpacity = cardData.bgImageDataUrl ? (cardData.overlayOpacity ?? 0.5) : 0;
                        innerEl.style.setProperty('--card-overlay-opacity', parseFloat(overlayOpacity) > 0 ? overlayOpacity : 0);
                        
                        innerEl.style.boxShadow = 'var(--active-card-shadow)';
                        innerEl.style.border = 'var(--active-card-border)';
                    }
                },

                updateState(keyPath, value, pushHistory = true) {
                    if (pushHistory && !this.isRestoringState) this.pushHistory();
                    let obj = this.state;
                    const keys = keyPath.split('.');
                    for (let i = 0; i < keys.length - 1; i++) { obj = obj?.[keys[i]]; }
                    if(obj) obj[keys[keys.length - 1]] = value;
                    this.debouncedSaveToLocal();
                    this.triggerRender(keyPath);
                    this.syncControl(keyPath);
                },

                triggerRender(keyPath) {
                    const mainKey = keyPath.split('.')[0];
                    if (mainKey === 'personalInfo') {
                        this.renderPersonalInfo();
                        if (keyPath.includes('tags')) this.renderTagManager();
                    } else if (mainKey === 'pageStyles' || mainKey === 'globalCardStyles') {
                        if (mainKey === 'globalCardStyles') this.updateGlobalCardStyleVars();
                        this.renderPageStyles();
                        this.renderPreviewBlocks();
                    } else if (mainKey === 'blocks') {
                        const blockIndex = parseInt(keyPath.split('.')[1], 10);
                        const blockId = this.state.blocks[blockIndex]?.id;
                        if(blockId) {
                            if (keyPath.includes('isVisible')) {
                                this.renderLayerPanel();
                                this.renderPreviewBlocks();
                            } else if (keyPath.includes('cards')) {
                                // Re-render layer panel if a card property (like title) changes
                                this.renderLayerPanel();
                                this.renderPreviewBlockById(blockId);
                            }
                            else {
                                this.renderPreviewBlockById(blockId);
                            }
                        }
                    }
                },

                addCard(blockId) {
                    const block = this.findBlock(blockId);
                    if (!block || block.type !== 'text') return;
                    
                    const newCard = { id: this.generateId('c'), icon: '', title: `æ–°å¡ç‰‡`, content: 'åŒå‡»é¢„è§ˆåŒºå¯ç›´æ¥ç¼–è¾‘å†…å®¹', opacity: 1.0, followGlobalOpacity: true, textShadowEnabled: false };
                    
                    this.pushHistory();
                    block.cards.push(newCard);
                    this.debouncedSaveToLocal();
                    
                    this.renderInspector();
                    this.renderLayerPanel();
                    
                    const container = this.elements.previewBlocksContainer.querySelector(`[data-block-id="${blockId}"] > div`);
                    if (!container) {
                        this.renderPreviewBlockById(blockId);
                        return;
                    };

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = this.createPreviewCardHTML(newCard);
                    const newCardEl = tempDiv.firstChild;
                    container.appendChild(newCardEl);

                    const masonry = this.masonryInstances[blockId];
                    if (masonry) {
                        masonry.appended(newCardEl);
                        masonry.layout();
                    }

                    newCardEl.classList.add('adding');
                    newCardEl.addEventListener('animationend', () => newCardEl.classList.remove('adding'), { once: true });
                    
                    const newCardEditorEl = this.elements.inspectorPanel.querySelector(`.editor-card[data-card-id="${newCard.id}"]`);
                    if (newCardEditorEl) {
                        newCardEditorEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                },

                addImageCard(blockId) {
                    const blockEl = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${blockId}"]`);
                    if (blockEl) {
                        blockEl.querySelector('.image-upload-input').click();
                    }
                },

                deleteCard(blockId, cardId) {
                    const block = this.findBlock(blockId);
                    if (!block) return;
                    
                    const cardEl = this.elements.previewBlocksContainer.querySelector(`[data-card-id="${cardId}"]`);
                    
                    const doDelete = () => {
                        this.pushHistory();
                        block.cards = block.cards.filter(c => c.id !== cardId);
                        this.debouncedSaveToLocal();
                        this.renderInspector();
                        this.renderLayerPanel();
                        
                        const masonry = this.masonryInstances[blockId];
                        if (!masonry) {
                            this.renderPreviewBlockById(blockId);
                        } else {
                            masonry.layout();
                        }

                        this.showToast('å¡ç‰‡å·²åˆ é™¤', 'info');
                    };

                    if (cardEl) {
                        const masonry = this.masonryInstances[blockId];
                        if (masonry) {
                            masonry.remove(cardEl);
                        }

                        cardEl.classList.add('removing');
                        cardEl.addEventListener('animationend', () => {
                            if (!masonry) cardEl.remove();
                            doDelete();
                        }, { once: true });

                    } else {
                        doDelete();
                    }
                },

                loadFromLocal() { 
                    const json = localStorage.getItem('blokkoState'); 
                    if (!json) {
                        this.showToast('æ¬¢è¿ä½¿ç”¨ Blokkoï¼å·²ä¸ºæ‚¨åŠ è½½é»˜è®¤æ¨¡æ¿ã€‚', 'info');
                        return;
                    };
                    try { 
                        let saved = JSON.parse(json);
                        if (saved && saved.personalInfo) {
                            if (typeof saved.personalInfo.tags === 'string') {
                                saved.personalInfo.tags = saved.personalInfo.tags.split(/[,ï¼Œã€]/).map(t => t.trim()).filter(Boolean)
                                    .map(text => ({ id: this.generateId('t'), icon: null, text }));
                                this.showToast('æ—§ç‰ˆé…ç½®å·²åŠ è½½ï¼Œæ ‡ç­¾æ•°æ®å·²è‡ªåŠ¨è½¬æ¢ã€‚', 'info');
                            }
                            
                            let migrated = false;
                            saved.blocks.forEach(block => {
                                if (block.type === 'image' && block.images && !block.cards) {
                                    block.cards = block.images.map(img => ({ ...img, id: this.generateId('ic') }));
                                    delete block.images;
                                    migrated = true;
                                }
                                if (block.isVisible === undefined) {
                                    block.isVisible = true;
                                }
                            });
                            if (migrated) {
                                this.showToast('æ—§ç‰ˆå›¾ç‰‡åŒºå—å·²è‡ªåŠ¨å‡çº§', 'info');
                            }

                            const defaultState = this.getDefaultState();
                            this.state = this.mergeDeep(defaultState, saved);

                            if (saved.uploadedFonts) {
                                this.uploadedFonts = saved.uploadedFonts;
                                this.uploadedFonts.forEach(font => {
                                    if (font.data) {
                                        try {
                                           const fontFace = new FontFace(font.family, this.base64ToArrayBuffer(font.data));
                                           fontFace.load().then(f => document.fonts.add(f)).catch(console.error);
                                        } catch(e) { console.error("Error loading font:", e)}
                                    }
                                });
                            }
                        }
                    } catch (e) { 
                        localStorage.removeItem('blokkoState'); 
                        this.showErrorModal('åŠ è½½å­˜æ¡£å¤±è´¥', 'æ‚¨çš„æœ¬åœ°å­˜æ¡£å¯èƒ½å·²æŸåï¼Œå·²ä¸ºæ‚¨åŠ è½½é»˜è®¤æ¨¡æ¿ã€‚é”™è¯¯ä¿¡æ¯: ' + e.message);
                        console.error("Failed to load state from localStorage:", e);
                    } 
                },
                
                mergeDeep(target, source) {
                    const isObject = (obj) => obj && typeof obj === 'object';
                    let output = { ...target };
                    if (isObject(target) && isObject(source)) {
                        Object.keys(source).forEach(key => {
                            if (isObject(source[key])) {
                                if (!(key in target)) {
                                    Object.assign(output, { [key]: source[key] });
                                } else if (Array.isArray(source[key])) {
                                    output[key] = source[key];
                                } else {
                                    output[key] = this.mergeDeep(target[key], source[key]);
                                }
                            } else {
                                Object.assign(output, { [key]: source[key] });
                            }
                        });
                    }
                    return output;
                },
                
                syncControl(keyPath) {
                    this.isRestoringState = true;
                    try {
                        const inputs = this.elements.inspectorPanel.querySelectorAll(`[data-state-key="${keyPath}"], [data-setting-key="${keyPath.split('.').slice(2).join('.')}"]`);
                        if (inputs.length === 0) return;

                        const value = keyPath.split('.').reduce((o, k) => o && o[k], this.state);

                        inputs.forEach(input => {
                            if (input.type === 'radio') {
                                input.checked = (input.value == value);
                            } else if (input.type === 'checkbox') {
                                input.checked = !!value;
                            } else {
                                input.value = value ?? '';
                            }

                            if (input.type === 'range') {
                                const valueDisplay = input.closest('.form-group').querySelector('.angle-value, .spacer-height-value, #gCardRadiusValue');
                                if (valueDisplay) valueDisplay.textContent = value;
                            }
                        });
                    } catch (e) {
                         console.error(`Error syncing control for ${keyPath}:`, e);
                    } finally {
                        this.isRestoringState = false;
                    }
                },


                syncAllControls() {
                    this.isRestoringState = true;
                    this.elements.inspectorPanel.querySelectorAll('[data-state-key], [data-setting-key]').forEach(input => {
                        try {
                            const stateKey = input.dataset.stateKey;
                            const settingKey = input.dataset.settingKey;
                            let value;

                            if (stateKey) {
                                if (stateKey === 'personalInfo.tags') return;
                                value = stateKey.split('.').reduce((o, k) => o && o[k], this.state);
                            } else if (settingKey && this.selection.type === 'block') {
                                const block = this.findBlock(this.selection.id);
                                if (block) value = block.settings[settingKey];
                            }
                            
                            if (value !== undefined) {
                                if (input.type === 'radio') {
                                    input.checked = (input.value == value);
                                } else if (input.type === 'checkbox') {
                                    input.checked = !!value;
                                } else {
                                    input.value = value ?? '';
                                }

                                if (input.type === 'color') {
                                    const hexInput = input.nextElementSibling;
                                    if(hexInput && hexInput.matches('.color-hex-input')) {
                                        hexInput.value = value || (input.placeholder || '');
                                    }
                                }
                                if (input.type === 'range') {
                                     const valueDisplay = input.closest('.form-group').querySelector('.angle-value, .spacer-height-value, #gCardRadiusValue');
                                     if(valueDisplay) valueDisplay.textContent = value;
                                }
                            }
                        } catch (e) {}
                    });
                     
                    const gCardSection = document.getElementById('global-card-styles-section');
                    if (gCardSection) {
                        const gCardActiveTab = this.state.globalCardStyles.bgMode === 'gradient' ? 'card-bg-gradient' : 'card-bg-solid';
                        gCardSection.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === gCardActiveTab));
                        gCardSection.querySelectorAll(':scope > .section-content > .tab-content').forEach(c => c.classList.toggle('active', c.id === gCardActiveTab));
                    }

                    const pageSection = document.getElementById('page-styles-section');
                    if (pageSection) {
                        const pageActiveTab = this.state.pageStyles.pageBgMode === 'gradient' ? 'page-bg-gradient' : 'page-bg-solid';
                        const headerActiveTab = this.state.pageStyles.headerBgMode === 'gradient' ? 'header-bg-gradient' : 'header-bg-solid';
                        pageSection.querySelectorAll('[data-tab^="page-bg-"]').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === pageActiveTab));
                        pageSection.querySelectorAll('#page-bg-solid, #page-bg-gradient').forEach(c => c.classList.toggle('active', c.id === pageActiveTab));
                        pageSection.querySelectorAll('[data-tab^="header-bg-"]').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === headerActiveTab));
                        pageSection.querySelectorAll('#header-bg-solid, #header-bg-gradient').forEach(c => c.classList.toggle('active', c.id === headerActiveTab));
                    }
                    
                    this.isRestoringState = false;
                },
                
                findBlock(blockId) { return this.state.blocks.find(b => b.id === blockId); },
                findBlockIndex(blockId) { return this.state.blocks.findIndex(b => b.id === blockId); },
                updateBlockTitle(blockId, title, pushHistory) { 
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) this.updateState(`blocks.${blockIndex}.title`, title, pushHistory);
                },
                updateBlockSettings(blockId, key, value, pushHistory) {
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) this.updateState(`blocks.${blockIndex}.settings.${key}`, value, pushHistory);
                },
                updateCard(blockId, cardId, key, value, pushHistory) {
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) {
                        const cardIndex = this.state.blocks[blockIndex].cards.findIndex(c => c.id === cardId);
                        if (cardIndex > -1) this.updateState(`blocks.${blockIndex}.cards.${cardIndex}.${key}`, value, pushHistory);
                    }
                },

                renderPreviewBlockById(blockId) {
                    const wrapper = this.elements.previewBlocksContainer.querySelector(`.preview-block-wrapper[data-block-id="${blockId}"]`);
                    const block = this.findBlock(blockId);
                    if (block && wrapper) {
                        wrapper.innerHTML = this.createPreviewBlockHTML(block);
                        this.initMasonryForBlock(blockId);
                    }
                },
                
                pushHistory() {
                     if (this.isRestoringState) return; 
                        if (this.historyIndex < this.history.length - 1) { 
                            this.history = this.history.slice(0, this.historyIndex + 1); 
                        } 
                        this.history.push(this.deepClone(this.state)); 
                        if (this.history.length > 50) this.history.shift(); 
                        this.historyIndex = this.history.length - 1;
                        this.updateUndoRedoButtons(); 
                },
                undo(){
                    if (this.historyIndex <= 0) return; 
                        this.isRestoringState = true; 
                        this.historyIndex--; 
                        this.state = this.deepClone(this.history[this.historyIndex]); 
                        this.renderAll(); 
                        this.syncAllControls(); 
                        this.updateUndoRedoButtons(); 
                        this.isRestoringState = false; 
                        this.showToast('å·²æ’¤é”€', 'info');
                },
                redo(){
                     if (this.historyIndex >= this.history.length - 1) return; 
                        this.isRestoringState = true; 
                        this.historyIndex++; 
                        this.state = this.deepClone(this.history[this.historyIndex]); 
                        this.renderAll(); 
                        this.syncAllControls(); 
                        this.updateUndoRedoButtons(); 
                        this.isRestoringState = false; 
                        this.showToast('å·²é‡åš', 'info');
                },
                updateUndoRedoButtons(){
                    const undoBtn = this.elements.inspectorPanel.querySelector('#undo-btn');
                    const redoBtn = this.elements.inspectorPanel.querySelector('#redo-btn');
                    if (undoBtn) undoBtn.disabled = this.historyIndex <= 0; 
                    if (redoBtn) redoBtn.disabled = this.historyIndex >= this.history.length - 1; 
                },
                
                async handleImageUpload(event, target, cardInfo = null){
                     const file = event.target.files[0]; 
                        if (!file) return; 
                        this.showLoading('æ­£åœ¨å¤„ç†å›¾ç‰‡...');
                        try {
                            const reader = new FileReader(); 
                            reader.onload = async e => {
                                const dataUrl = e.target.result;
                                if(target === 'colorThief') {
                                    this.analyzeColorsFromImage(dataUrl);
                                    this.hideLoading();
                                    return;
                                }
                                const compressedUrl = await this.compressImage(dataUrl, 0.85, 1200);
                                if (['avatar', 'pageBg', 'cardBg', 'imageCard'].includes(target)) {
                                    this.showCropper(compressedUrl, { type: target, ...cardInfo }); 
                                }
                                this.hideLoading();
                            }; 
                            reader.onerror = (err) => {
                                this.showErrorModal('å›¾ç‰‡è¯»å–å¤±è´¥', err.message);
                                this.hideLoading();
                            };
                            reader.readAsDataURL(file); 
                        } catch(err) {
                            this.showErrorModal('å›¾ç‰‡å¤„ç†å¤±è´¥', err.message);
                            this.hideLoading();
                        }
                        event.target.value = ''; 
                },
                handleCardBgUpload(event, blockId, cardId){
                    this.handleImageUpload(event, 'cardBg', { blockId, cardId });
                },
                async handleImageGalleryUpload(blockId, files){
                     const block = this.findBlock(blockId); 
                        if (!block || !files.length) return; 
                        this.showLoading(`æ­£åœ¨ä¸Šä¼  ${files.length} å¼ å›¾ç‰‡...`);
                        try {
                            this.pushHistory(); 
                            const newImages = await Promise.all(Array.from(files).map(f => this.readFileAsDataURL(f).then(this.compressImage)));
                            const newCards = newImages.map(url => ({ id: this.generateId('ic'), url, title: '', description: '' }));
                            block.cards.push(...newCards);
                            this.debouncedSaveToLocal();
                            this.renderInspector(); 
                            this.renderLayerPanel();
                            this.renderPreviewBlockById(blockId); 
                        } catch (err) {
                            this.showErrorModal('å›¾ç‰‡ä¸Šä¼ å¤±è´¥', err.message);
                        } finally {
                            this.hideLoading();
                        }
                },
                cropImage(blockId, cardId){
                    const block = this.findBlock(blockId);
                    const card = block?.cards.find(c => c.id === cardId);
                    if (card && card.url) {
                        this.showCropper(card.url, { type: 'imageCard', blockId, cardId });
                    }
                },
                
                showCropper(imageSrc, target){
                     this.currentCropTarget = target; 
                        this.elements.cropperModal.classList.add('visible'); 
                        this.elements.cropperImage.src = imageSrc; 
                        if (this.cropper) this.cropper.destroy(); 
                        this.cropper = new Cropper(this.elements.cropperImage, { aspectRatio: NaN, viewMode: 1, background: false }); 
                },
                hideCropper(){
                     this.elements.cropperModal.classList.remove('visible'); 
                        if (this.cropper) { 
                            this.cropper.destroy(); 
                            this.cropper = null; 
                        } 
                },
                async saveCrop(){
                     if (!this.cropper || !this.currentCropTarget) return;
                        this.showLoading('æ­£åœ¨å‹ç¼©è£å‰ªåçš„å›¾ç‰‡...');
                        try {
                            const dataUrl = this.cropper.getCroppedCanvas()?.toDataURL();
                            if (!dataUrl) {
                                this.showErrorModal('è£å‰ªå¤±è´¥', 'æ— æ³•è·å–è£å‰ªåçš„å›¾ç‰‡æ•°æ®ã€‚');
                                return;
                            }

                            const { type, blockId, cardId } = this.currentCropTarget;
                            let maxWidth = 1024;
                            if (type === 'pageBg') maxWidth = 1920;
                            if (type === 'avatar' || type === 'cardBg') maxWidth = 400;
                            
                            const finalDataUrl = await this.compressImage(dataUrl, 0.85, maxWidth);

                            this.pushHistory();
                            if (type === 'avatar') {
                                this.updateState('personalInfo.avatarDataUrl', finalDataUrl, false);
                            } else if (type === 'pageBg') {
                                this.updateState('pageStyles.pageBgImageDataUrl', finalDataUrl, false);
                            } else if (type === 'imageCard') {
                                this.updateCard(blockId, cardId, 'url', finalDataUrl, false);
                            } else if (type === 'cardBg') {
                                this.updateCard(blockId, cardId, 'bgImageDataUrl', finalDataUrl, false);
                            }
                            this.hideCropper();
                        } catch (err) {
                            console.error('Save crop failed:', err);
                            this.showErrorModal('ä¿å­˜è£å‰ªå¤±è´¥', 'å¤„ç†å›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯ã€‚');
                        } finally {
                            this.hideLoading();
                        }
                },
                updateCropAspectRatio(){
                     if(this.cropper) this.cropper.setAspectRatio(parseFloat(document.querySelector('input[name="crop-ratio"]:checked').value)); 
                },
                
                async loadLocalFonts(){
                     if (!window.queryLocalFonts) {
                            this.showErrorModal('åŠŸèƒ½ä¸æ”¯æŒ', 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè®¿é—®æœ¬åœ°å­—ä½“ã€‚è¯·å°è¯•ä½¿ç”¨â€œä¸Šä¼ å­—ä½“â€åŠŸèƒ½ã€‚');
                            return;
                        }
                        try {
                            this.showLoading('æ­£åœ¨åŠ è½½æœ¬åœ°å­—ä½“...');
                            const fonts = await window.queryLocalFonts();
                            this.localFonts = fonts.map(font => ({ family: font.family, fullName: font.fullName, type: 'local' }));
                            this.populateFontList();
                            this.showToast(`åŠ è½½äº† ${this.localFonts.length} ä¸ªæœ¬åœ°å­—ä½“`, 'success');
                        } catch (err) {
                            console.error('æ— æ³•è®¿é—®æœ¬åœ°å­—ä½“:', err);
                            this.showErrorModal('åŠ è½½æœ¬åœ°å­—ä½“å¤±è´¥', 'è¿™æ˜¯ä¸€ä¸ªå®éªŒæ€§çš„æµè§ˆå™¨åŠŸèƒ½ï¼Œå¯èƒ½å› å®‰å…¨è®¾ç½®æˆ–æµè§ˆå™¨ç‰ˆæœ¬è€Œä¸ç¨³å®šã€‚å¦‚æœæŒç»­å¤±è´¥ï¼Œå»ºè®®ä½¿ç”¨â€œä¸Šä¼ å­—ä½“â€åŠŸèƒ½ã€‚');
                        } finally {
                            this.hideLoading();
                        }
                },
                async handleFontUpload(event){
                     const file = event.target.files[0];
                        if (!file) return;
                        this.showLoading('æ­£åœ¨ä¸Šä¼ å¹¶åŠ è½½å­—ä½“...');
                        try {
                            const fontData = await this.readFileAsArrayBuffer(file);
                            const fontName = file.name.replace(/\.[^/.]+$/, "");
                            if (this.uploadedFonts.some(f => f.family === fontName) || this.localFonts.some(f => f.family === fontName)) {
                                this.showErrorModal('å­—ä½“å·²å­˜åœ¨', `å­—ä½“ "${fontName}" å·²å­˜åœ¨!`);
                                return;
                            }
                            const fontFace = new FontFace(fontName, fontData.slice(0));
                            await fontFace.load();
                            document.fonts.add(fontFace);
                            
                            const fontDataBase64 = await this.arrayBufferToBase64(fontData);
                            this.uploadedFonts.push({ family: fontName, fullName: `${fontName} (ä¸Šä¼ )`, data: fontDataBase64, type: 'uploaded' });
                            this.populateFontList();
                            this.updateState('globalCardStyles.fontFamily', fontName, true);
                            this.showToast(`å­—ä½“ "${fontName}" ä¸Šä¼ æˆåŠŸ`, 'success');
                        } catch (error) {
                            console.error('å­—ä½“ä¸Šä¼ å¤±è´¥:', error);
                            this.showErrorModal('å­—ä½“ä¸Šä¼ å¤±è´¥', 'å­—ä½“æ–‡ä»¶æ— æ•ˆæˆ–åŠ è½½å¤±è´¥ã€‚');
                        } finally {
                            event.target.value = '';
                            this.hideLoading();
                        }
                },
                
                populateFontList(searchTerm = ''){
                     const select = this.elements.inspectorPanel.querySelector('#font-family-select');
                     if (!select) return;
                        const currentFont = this.state.globalCardStyles.fontFamily;
                        select.innerHTML = '';
                        
                        const recommendedFonts = [
                            { family: 'Noto Sans SC', fullName: 'æ€æºé»‘ä½“' },
                            { family: 'Noto Serif SC', fullName: 'æ€æºå®‹ä½“' },
                            { family: 'ZCOOL KuaiLe', fullName: 'ç«™é…·å¿«ä¹ä½“' },
                            { family: 'ZCOOL XiaoWei', fullName: 'ç«™é…·å°è–‡ä½“' },
                        ];

                        const allFonts = [...this.uploadedFonts, ...this.localFonts];
                        const categories = { cjk: [], sans: [], serif: [], uploaded: [], other: [] };
                        
                        const filteredFonts = searchTerm
                            ? allFonts.filter(font => 
                                font.family.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                font.fullName.toLowerCase().includes(searchTerm.toLowerCase()))
                            : allFonts;

                        filteredFonts.forEach(font => {
                            if (recommendedFonts.some(rf => rf.family === font.family)) return;
                            const category = this.getFontCategory(font);
                            if (!categories[category].some(f => f.family === font.family)) {
                                 categories[category].push(font);
                            }
                        });

                        const requiredFonts = this.getAllRequiredFonts();
                        requiredFonts.forEach(reqFont => {
                            if (!allFonts.some(f => f.family === reqFont) && !recommendedFonts.some(rf => rf.family === reqFont)) {
                               const placeholderFont = { family: reqFont, fullName: `${reqFont} (éœ€è¦é‡æ–°ä¸Šä¼ )`, type: 'uploaded', missing: true };
                               if (!categories.uploaded.some(f => f.family === reqFont)) {
                                   categories.uploaded.push(placeholderFont);
                               }
                            }
                        });

                        const createOptgroup = (label, fonts) => {
                            if (fonts.length === 0) return '';
                            const options = fonts
                                .sort((a, b) => a.fullName.localeCompare(b.fullName))
                                .map(f => `<option value="${this.escapeHTML(f.family)}" style="font-family: '${this.escapeHTML(f.family)}', sans-serif;" ${f.missing?'disabled':''}>${this.escapeHTML(f.fullName)}</option>`)
                                .join('');
                            return `<optgroup label="${label}">${options}</optgroup>`;
                        };

                        let html = '<option value="">ç³»ç»Ÿé»˜è®¤</option>';
                        html += createOptgroup('æ¨èå­—ä½“', recommendedFonts);
                        html += createOptgroup('å·²ä¸Šä¼ å­—ä½“', categories.uploaded);
                        html += createOptgroup('ä¸­æ–‡ / CJK', categories.cjk);
                        html += createOptgroup('æ— è¡¬çº¿ (Sans-serif)', categories.sans);
                        html += createOptgroup('è¡¬çº¿ (Serif)', categories.serif);
                        html += createOptgroup('å…¶ä»–', categories.other);

                        select.innerHTML = html;
                        select.value = currentFont;
                },
                
                getFontCategory(font){
                     if (font.type === 'uploaded') return 'uploaded';
                        const name = (font.family + font.fullName).toLowerCase();
                        if (/(hei|song|ming|gothic|kai|fang|yuan|deng|é»‘|å®‹|æ˜|ã‚´ã‚·ãƒƒã‚¯|æ¥·|åœ“)/.test(name) || /[\u4e00-\u9fa5]/.test(name)) {
                            return 'cjk';
                        }
                        if (name.includes('serif')) return 'serif';
                        if (name.includes('sans')) return 'sans';
                        return 'other';
                },
                getAllRequiredFonts(){
                     const fonts = new Set();
                        if (this.state.globalCardStyles.fontFamily) {
                            fonts.add(this.state.globalCardStyles.fontFamily);
                        }
                        return Array.from(fonts);
                },
                
                applyPreset(preset){
                     this.pushHistory(); 
                        
                        this.state.pageStyles.pageBgSolidColor = preset.pageBgSolidColor; 
                        this.state.pageStyles.pageBgGradientStart = preset.pageBgGradientStart;
                        this.state.pageStyles.pageBgGradientEnd = preset.pageBgGradientEnd;

                        this.state.pageStyles.headerBgColor = preset.headerBgColor;
                        this.state.pageStyles.headerBgGradientStart = preset.headerBgGradientStart;
                        this.state.pageStyles.headerBgGradientEnd = preset.headerBgGradientEnd;
                        this.state.pageStyles.headerTextColor = preset.headerTextColor; 
                        
                        this.state.globalCardStyles.bgColor = preset.gCardBgColor; 
                        this.state.globalCardStyles.bgGradientStart = preset.gCardBgGradientStart;
                        this.state.globalCardStyles.bgGradientEnd = preset.gCardBgGradientEnd;
                        this.state.globalCardStyles.textColor = preset.gCardTextColor; 
                        this.state.globalCardStyles.opacity = preset.gCardOpacity; 
                        
                        this.state.personalInfo.nicknameColor = preset.pNicknameColor;
                        this.state.personalInfo.subtitleColor = preset.pSubtitleColor;
                        this.state.personalInfo.bioColor = preset.pBioColor;
                        this.state.personalInfo.tagBgColor = preset.pTagBgColor;
                        this.state.personalInfo.tagTextColor = preset.pTagTextColor;
                        
                        this.state.pageStyles.pageBgMode = 'gradient';
                        this.state.pageStyles.headerBgMode = 'gradient';
                        this.state.globalCardStyles.bgMode = 'solid';

                        this.debouncedSaveToLocal();
                        this.renderAll(); 
                        this.syncAllControls();
                        this.showToast('é¢„è®¾å·²åº”ç”¨', 'success');
                },
                
                readFileAsDataURL(file){return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    })},
                readFileAsArrayBuffer(file){return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(file);
                    })},
                compressImage(dataUrl, quality = 0.8, maxWidth = 1024){return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            let { width, height } = img;
                            if (width > maxWidth) {
                                height = (maxWidth / width) * height;
                                width = maxWidth;
                            }
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            resolve(canvas.toDataURL('image/jpeg', quality));
                        };
                        img.onerror = (err) => reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æŸåã€‚'));
                        img.src = dataUrl;
                    })},
                
                toggleTheme(){
                    const isDark = document.documentElement.classList.toggle('dark-mode'); 
                    localStorage.setItem('blokkoTheme', isDark ? 'dark' : 'light'); 
                    this.elements.themeLabel.textContent = isDark ? 'æš—é»‘æ¨¡å¼' : 'æ˜äº®æ¨¡å¼'; 
                },
                loadPreferences(){
                    if (localStorage.getItem('blokkoTheme') === 'dark') { 
                        this.elements.themeLabel.textContent = 'æš—é»‘æ¨¡å¼'; 
                    } 
                },
                saveToLocal(){
                     try { 
                            const stateToSave = this.deepClone(this.state);
                            stateToSave.uploadedFonts = this.uploadedFonts;
                            localStorage.setItem('blokkoState', JSON.stringify(stateToSave)); 
                        } catch (e) {
                            console.error("Save to localStorage failed:", e);
                            if (e.name === 'QuotaExceededError') {
                                this.showErrorModal('è‡ªåŠ¨ä¿å­˜å¤±è´¥', 'æµè§ˆå™¨å­˜å‚¨ç©ºé—´å·²æ»¡ï¼æ‚¨æ·»åŠ çš„å›¾ç‰‡æˆ–å­—ä½“æ–‡ä»¶è¿‡å¤§ã€‚è¯·ç«‹å³â€œå¯¼å‡ºé…ç½®â€æ¥å¤‡ä»½æ‚¨çš„å·¥ä½œï¼Œç„¶åå°è¯•ç§»é™¤ä¸€äº›å›¾ç‰‡æˆ–å­—ä½“ä»¥æ¢å¤è‡ªåŠ¨ä¿å­˜åŠŸèƒ½ã€‚');
                            }
                        } 
                },
                
                generateFilename(type){
                    const nickname = (this.state.personalInfo.nickname || '').replace(/[^a-z0-9\u4e00-\u9fa5]/gi, '_').substring(0, 15) || 'Blokko';
                    const date = new Date();
                    const dateString = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
                    const randomString = Math.random().toString(36).substring(2, 8);
                    return `${nickname}-${dateString}-${type}-${randomString}`;
                },
                
                async exportConfig(isTemplate = false){
                     let stateToSave = this.deepClone(this.state);
                        
                        if (isTemplate) {
                            stateToSave.personalInfo.nickname = "ä½ çš„æ˜µç§°";
                            stateToSave.personalInfo.subtitle = "è¿™æ˜¯å‰¯æ ‡é¢˜";
                            stateToSave.personalInfo.bio = "è¿™æ˜¯ç®€ä»‹";
                            stateToSave.personalInfo.tags = this.getDefaultState().personalInfo.tags;
                            stateToSave.personalInfo.avatarDataUrl = this.getDefaultState().personalInfo.avatarDataUrl;
                            stateToSave.pageStyles.pageBgImageDataUrl = null;
                            stateToSave.pageStyles.pageBgPattern = '';
                            stateToSave.customIcons = [];

                            stateToSave.blocks.forEach(block => {
                                if (block.type === 'text' || block.type === 'image') {
                                    block.title = block.type === 'text' ? "æ–‡æœ¬åŒºå—" : "å›¾ç‰‡åŒºå—";
                                    block.cards.forEach(card => {
                                        if (block.type === 'text') {
                                            card.title = "å¡ç‰‡æ ‡é¢˜";
                                            card.content = "å¡ç‰‡å†…å®¹";
                                            card.bgImageDataUrl = null;
                                        }
                                    });
                                    if(block.type === 'image') block.cards = [];
                                }
                            });
                            this.showToast('æ¨¡æ¿å·²å¯¼å‡º', 'success');
                        } else {
                            stateToSave.uploadedFonts = this.uploadedFonts;
                            this.showToast('é…ç½®å·²å¯¼å‡º', 'success');
                        }
                        
                        const blob = new Blob([JSON.stringify(stateToSave, null, 2)], { type: 'application/json' }); 
                        const filename = this.generateFilename(isTemplate ? 'Template' : 'Config') + '.json';
                        this.showDownloadModal(URL.createObjectURL(blob), filename, isTemplate ? 'æ¨¡æ¿å·²ç”Ÿæˆ' : 'é…ç½®å·²ç”Ÿæˆ');
                },
                
                async handleConfigFile(e){
                    const file = e.target.files[0]; 
                        if (!file) return;

                        const confirmed = await this.showConfirm('å¯¼å…¥é…ç½®', 'æ­¤æ“ä½œå°†è¦†ç›–å½“å‰æ‰€æœ‰å†…å®¹ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ');
                        if (!confirmed) {
                            e.target.value = '';
                            return;
                        }

                        this.showLoading('æ­£åœ¨å¯¼å…¥é…ç½®...');
                        await this.sleep(100); 
                        
                        const reader = new FileReader(); 
                        reader.onload = async (re) => { 
                            try { 
                                let importedState = JSON.parse(re.target.result); 
                                if (!importedState || !importedState.personalInfo || !importedState.blocks) throw new Error('Invalid file format'); 
                                
                                if (typeof importedState.personalInfo.tags === 'string') {
                                    importedState.personalInfo.tags = importedState.personalInfo.tags.split(/[,ï¼Œã€]/).map(t => t.trim()).filter(Boolean)
                                        .map(text => ({ id: this.generateId('t'), icon: null, text }));
                                    this.showToast('æ—§ç‰ˆé…ç½®å·²å¯¼å…¥å¹¶è‡ªåŠ¨å‡çº§ã€‚', 'info');
                                }

                                let migrated = false;
                                importedState.blocks.forEach(block => {
                                    if (block.type === 'image' && block.images && !block.cards) {
                                        block.cards = block.images.map(img => ({ ...img, id: this.generateId('ic') }));
                                        delete block.images;
                                        migrated = true;
                                    }
                                });
                                if (migrated) {
                                    this.showToast('æ—§ç‰ˆå›¾ç‰‡åŒºå—å·²è‡ªåŠ¨å‡çº§', 'info');
                                }

                                this.state = this.mergeDeep(this.getDefaultState(), importedState);
                                
                                this.uploadedFonts = [];
                                
                                if (importedState.uploadedFonts) {
                                    this.uploadedFonts = importedState.uploadedFonts;
                                    const fontLoadPromises = this.uploadedFonts.map(font => {
                                        if (font.data) {
                                            try {
                                               const fontFace = new FontFace(font.family, this.base64ToArrayBuffer(font.data));
                                               return fontFace.load().then(f => document.fonts.add(f));
                                            } catch (fontError) {
                                                console.error(`Failed to load font ${font.family} from config:`, fontError);
                                                return Promise.resolve();
                                            }
                                        }
                                        return Promise.resolve();
                                    });
                                    await Promise.all(fontLoadPromises);
                                }

                                this.history = [this.deepClone(this.state)];
                                this.historyIndex = 0;
                                this.setSelection({type: 'global'});
                                this.renderAll(true); 
                                this.syncAllControls(); 
                                this.populateFontList();
                                this.initAllSortables();
                                this.updateExportSizePreview();
                                this.showToast('é…ç½®å¯¼å…¥æˆåŠŸ', 'success');
                            } catch(err) { 
                                this.showErrorModal('å¯¼å…¥å¤±è´¥', 'é…ç½®æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®æˆ–å·²æŸåã€‚è¯·ç¡®ä¿æ‚¨å¯¼å…¥çš„æ˜¯ç”±æœ¬å·¥å…·ç”Ÿæˆçš„ .json æ–‡ä»¶ã€‚');
                                console.error(err);
                            } finally {
                                this.hideLoading();
                            }
                        }; 
                        reader.readAsText(file); 
                        e.target.value = ''; 
                },
                
                async bakeOverlaysForExport(clone) {
                    const style = document.createElement('style');
                    clone.appendChild(style);
                    
                    const pageWrapper = clone;
                    const styles = this.state.pageStyles;
                    let pageBgLayers = [];
                    let pageBgSizes = [];
                    let pageBgPositions = [];
                    let pageBgColor = 'transparent';

                    if (styles.pageBgPattern) {
                        const pattern = HeroPatterns.find(p => p.name === styles.pageBgPattern);
                        if (pattern) {
                            const coloredSvg = pattern.svg(styles.pageBgPatternColor, styles.pageBgPatternOpacity);
                            const base64Svg = btoa(unescape(encodeURIComponent(coloredSvg)));
                            pageBgLayers.push(`url("data:image/svg+xml;base64,${base64Svg}")`);
                            pageBgSizes.push(`${styles.pageBgPatternDensity}px`);
                            pageBgPositions.push('center');
                        }
                    }
                    if (styles.pageBgImageDataUrl) {
                        const overlayOpacity = parseFloat(styles.pageOverlayOpacity);
                        if (overlayOpacity > 0) {
                            const finalOverlayColor = this.hexToRgba(styles.pageOverlayColor, overlayOpacity);
                            pageBgLayers.push(`linear-gradient(${finalOverlayColor}, ${finalOverlayColor})`);
                            pageBgSizes.push('cover');
                            pageBgPositions.push('center');
                        }
                        pageBgLayers.push(`url(${styles.pageBgImageDataUrl})`);
                        pageBgSizes.push('cover');
                        pageBgPositions.push('center');
                    }
                    if (styles.pageBgMode === 'gradient') {
                        pageBgLayers.push(`linear-gradient(${styles.pageBgGradientAngle}deg, ${styles.pageBgGradientStart}, ${styles.pageBgGradientEnd})`);
                        pageBgSizes.push('auto');
                        pageBgPositions.push('initial');
                    } else {
                        pageBgColor = styles.pageBgSolidColor;
                    }

                    pageWrapper.style.backgroundColor = pageBgColor;
                    pageWrapper.style.backgroundImage = pageBgLayers.join(', ');
                    pageWrapper.style.backgroundSize = pageBgSizes.join(', ');
                    pageWrapper.style.backgroundPosition = pageBgPositions.join(', ');
                    
                    clone.querySelectorAll('.preview-card-inner').forEach(cardInner => {
                        const computed = getComputedStyle(cardInner);
                        const beforeComputed = getComputedStyle(cardInner, '::before');
                        const afterComputed = getComputedStyle(cardInner, '::after');
                        
                        let backgroundStyle = beforeComputed.getPropertyValue('background');
                        const overlayOpacity = parseFloat(afterComputed.getPropertyValue('opacity'));
                        const bgImage = beforeComputed.getPropertyValue('background-image');

                        if (overlayOpacity > 0 && bgImage !== 'none') {
                            const overlayColor = afterComputed.getPropertyValue('background-color');
                             if(overlayColor !== 'rgba(0, 0, 0, 0)') {
                                const overlayGradient = `linear-gradient(${overlayColor}, ${overlayColor})`;
                                backgroundStyle = `${overlayGradient}, ${backgroundStyle}`;
                            }
                        }
                        cardInner.style.background = backgroundStyle;
                        cardInner.style.border = computed.border;
                    });
                    
                    style.innerHTML += `#${clone.id} .preview-card-inner::before, #${clone.id} .preview-card-inner::after { content: none !important; background: none !important; display: none !important; }`;
                },
                
                async exportPNG(){
                    this.showLoading('æ­£åœ¨å‡†å¤‡å¯¼å‡º...');
                    
                    const isCustomWidth = document.getElementById('custom-width-toggle').checked;
                    const isHD = document.getElementById('hd-export-toggle').checked;
                    let targetWidth = 1200;
                    if (isCustomWidth) {
                        targetWidth = parseInt(document.getElementById('custom-width-input').value, 10) || 1200;
                    } else if (isHD) {
                        targetWidth = 1800;
                    }
                    const sourceWidth = 600;
                    const scale = targetWidth / sourceWidth;

                    const exportRounded = document.getElementById('export-rounded-corners-toggle').checked;
                    const cornerRadius = parseInt(document.getElementById('export-corner-radius-input').value, 10) || 20;

                    const originalElement = this.elements.previewWrapper;
                    let clone = null;
                    
                    const wasLayerOpen = this.elements.layerPanel.classList.contains('is-open');
                    const wasInspectorOpen = this.elements.inspectorPanel.classList.contains('is-open');
                    if (wasLayerOpen || wasInspectorOpen) {
                        this.togglePanelDrawer(false);
                        await this.sleep(100);
                    }
                    
                    document.body.classList.add('export-mode');

                    try {
                        clone = originalElement.cloneNode(true);
                        clone.id = `export-clone-${Date.now()}`;
                        
                        const style = document.createElement('style');
                        style.innerHTML = `#${clone.id}, #${clone.id} * { transition: none !important; animation: none !important; } #${clone.id} .preview-card:hover .preview-card-inner { transform: none !important; box-shadow: var(--active-card-shadow, none) !important; }`;
                        clone.appendChild(style);

                        clone.style.position = 'absolute';
                        clone.style.left = '-9999px';
                        clone.style.top = '0px';
                        clone.style.borderRadius = '0';
                        clone.style.width = `${sourceWidth}px`;
                        
                        document.body.appendChild(clone);
                        await this.sleep(100);

                        this.showLoading('æ­£åœ¨è®¡ç®—ç€‘å¸ƒæµå¸ƒå±€...');
                        const masonryBlocks = this.state.blocks.filter(b => b.settings.masonryEnabled);
                        if (masonryBlocks.length > 0) {
                            for (const block of masonryBlocks) {
                                const containerInClone = clone.querySelector(`.preview-block-wrapper[data-block-id="${block.id}"] .preview-cards-container`);
                                if (containerInClone) {
                                    containerInClone.classList.add('masonry-active');
                                    const itemSelector = block.type === 'text' ? '.preview-card' : 'figure';
                                    const msnry = new Masonry(containerInClone, { itemSelector: itemSelector, gutter: 15 });
                                    msnry.layout();
                                }
                            }
                            await this.sleep(200);
                        }
                        
                        this.showLoading('æ­£åœ¨å¤„ç†æ ·å¼ (çƒ˜ç„™)...');
                        await this.bakeOverlaysForExport(clone);
                        await this.sleep(100);

                        this.showLoading('æ­£åœ¨æ¸²æŸ“å›¾ç‰‡...');
                        const canvas = await html2canvas(clone, { scale: scale, useCORS: true, backgroundColor: null, logging: false });

                        let finalCanvas = canvas;
                        if (exportRounded && cornerRadius > 0) {
                            this.showLoading('æ­£åœ¨åº”ç”¨åœ†è§’...');
                            finalCanvas = document.createElement('canvas');
                            finalCanvas.width = canvas.width;
                            finalCanvas.height = canvas.height;
                            const ctx = finalCanvas.getContext('2d');
                            const scaledRadius = cornerRadius * scale;
                            
                            ctx.beginPath();
                            ctx.moveTo(scaledRadius, 0);
                            ctx.lineTo(finalCanvas.width - scaledRadius, 0);
                            ctx.arcTo(finalCanvas.width, 0, finalCanvas.width, scaledRadius, scaledRadius);
                            ctx.lineTo(finalCanvas.width, finalCanvas.height - scaledRadius);
                            ctx.arcTo(finalCanvas.width, finalCanvas.height, finalCanvas.width - scaledRadius, finalCanvas.height, scaledRadius);
                            ctx.lineTo(scaledRadius, finalCanvas.height);
                            ctx.arcTo(0, finalCanvas.height, 0, finalCanvas.height - scaledRadius, scaledRadius);
                            ctx.lineTo(0, scaledRadius);
                            ctx.arcTo(0, 0, scaledRadius, 0, scaledRadius);
                            ctx.closePath();
                            ctx.clip();
                            ctx.drawImage(canvas, 0, 0);
                        }

                        const dataUrl = finalCanvas.toDataURL('image/png');
                        const filename = this.generateFilename('Image') + '.png';
                        this.showDownloadModal(dataUrl, filename, 'å›¾ç‰‡å·²ç”Ÿæˆ');

                    } catch (err) {
                        console.error("PNG export failed:", err);
                        this.showErrorModal('å¯¼å‡ºå¤±è´¥', `ç”Ÿæˆå›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯: ${err.message}.`);
                    } finally {
                        if (clone && clone.parentNode) {
                            clone.parentNode.removeChild(clone);
                        }
                        if (wasLayerOpen) this.togglePanelDrawer('layer-panel');
                        if (wasInspectorOpen) this.togglePanelDrawer('inspector-panel');
                        document.body.classList.remove('export-mode');
                        this.hideLoading();
                    }
                },
                
                updateExportSizePreview(){
                    const el = this.elements.previewWrapper;
                    if (!el || el.clientWidth === 0) return;
                    
                    const customWidthToggle = document.getElementById('custom-width-toggle');
                    const hdExportToggle = document.getElementById('hd-export-toggle');
                    if(!customWidthToggle || !hdExportToggle) return;

                    const isCustomWidth = customWidthToggle.checked;
                    const isHD = hdExportToggle.checked;
                    let targetWidth = 1200;

                    if (isCustomWidth) {
                        targetWidth = parseInt(document.getElementById('custom-width-input').value, 10) || 1200;
                    } else if (isHD) {
                        targetWidth = 1800;
                    }
                    
                    const aspectRatio = el.clientHeight / el.clientWidth;
                    const finalHeight = Math.round(targetWidth * aspectRatio);

                    const previewEl = document.getElementById('export-size-preview');
                    if (previewEl) previewEl.textContent = `å¯¼å‡ºå°ºå¯¸: ${targetWidth}x${finalHeight}px`;
                    
                    let buttonText = 'å¯¼å‡ºä¸ºå›¾ç‰‡';
                    if (isCustomWidth) {
                        buttonText += ` (${targetWidth}px)`;
                    } else {
                        buttonText += isHD ? ' (1800px)' : ' (1200px)';
                    }
                    const exportBtn = document.getElementById('export-png-btn');
                    if (exportBtn) exportBtn.textContent = buttonText;
                },
                
                arrayBufferToBase64(buffer){
                    return new Promise((resolve, reject) => {
                            const blob = new Blob([buffer], {type: 'application/octet-stream'});
                            const reader = new FileReader();
                            reader.onload = e => resolve(e.target.result);
                            reader.onerror = e => reject(e);
                            reader.readAsDataURL(blob);
                        });
                },
                base64ToArrayBuffer(base64){
                    const binaryString = atob(base64.split(',')[1]);
                        const len = binaryString.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        return bytes.buffer;
                },
                
                showDownloadModal(url, filename, title){
                    this.elements.downloadModalTitle.textContent = title; 
                        const content = this.elements.downloadModalContent; 
                        content.innerHTML = `<a href="${url}" download="${filename}">ç‚¹å‡»ä¸‹è½½: ${filename}</a>`; 
                        if (url.startsWith('data:image')) content.insertAdjacentHTML('afterbegin', `<img src="${url}">`); 
                        this.elements.downloadModal.classList.add('visible'); 
                },
                hideDownloadModal(){ this.elements.downloadModal.classList.remove('visible'); },
                showErrorModal(title, message){
                    const existingModal = document.querySelector('.error-modal');
                        if (existingModal) existingModal.remove();
                        const modal = document.createElement('div');
                        modal.className = 'error-modal';
                        modal.innerHTML = `<h3>${title}</h3><p>${message}</p><button class="btn btn-primary" onclick="this.closest('.error-modal').remove()">ç¡®å®š</button>`;
                        document.body.appendChild(modal);
                },
                showConfirm(title, message) {
                    return new Promise(resolve => {
                        const modal = this.elements.confirmModal;
                        modal.querySelector('#confirm-modal-title').textContent = title;
                        modal.querySelector('#confirm-modal-message').textContent = message;

                        const okBtn = modal.querySelector('#confirm-modal-ok-btn');
                        const cancelBtn = modal.querySelector('#confirm-modal-cancel-btn');

                        const cleanup = () => {
                            modal.classList.remove('visible');
                            okBtn.replaceWith(okBtn.cloneNode(true));
                            cancelBtn.replaceWith(cancelBtn.cloneNode(true));
                        };

                        okBtn.addEventListener('click', () => {
                            cleanup();
                            resolve(true);
                        }, { once: true });

                        cancelBtn.addEventListener('click', () => {
                            cleanup();
                            resolve(false);
                        }, { once: true });
                        
                        modal.classList.add('visible');
                    });
                },

                showLoading(text = 'æ­£åœ¨å¤„ç†...'){
                    this.elements.loadingText.textContent = text;
                        this.elements.loadingOverlay.classList.add('visible');
                },
                hideLoading(){
                    this.elements.loadingOverlay.classList.remove('visible');
                },
                showToast(message, type = 'info'){
                     const toast = document.createElement('div');
                        toast.className = `toast-notification ${type}`;
                        toast.textContent = message;
                        this.elements.toastContainer.appendChild(toast);
                        setTimeout(() => {
                            toast.remove();
                        }, 5000);
                },
                
                updateGlobalCardStyleVars(){
                     const g = this.state.globalCardStyles;
                        const r = document.documentElement.style; 
                        
                        r.setProperty('--g-card-bg-color', g.bgColor);
                        r.setProperty('--g-card-text-color',g.textColor); 
                        r.setProperty('--g-card-opacity',g.opacity); 
                        r.setProperty('--g-card-border-radius',`${g.radius}px`); 
                        r.setProperty('--g-card-text-align',g.textAlign); 
                        r.setProperty('--g-card-line-height',g.lineHeight); 
                        r.setProperty('--active-card-font-family',g.fontFamily?`'${g.fontFamily}', sans-serif`:''); 
                        r.setProperty('--active-card-font-size',g.fontSize);
                        r.setProperty('--g-card-text-stroke', g.textStrokeWidth > 0 ? `${g.textStrokeWidth}px ${g.textStrokeColor}` : '0px transparent');
                        
                        const regularShadow = 'none';
                        if (g.borderStyle === 'solid' && g.borderWidth > 0) {
                            const borderShadow = `0 0 0 ${g.borderWidth}px ${g.borderColor}`;
                            r.setProperty('--active-card-shadow', `${borderShadow}, ${regularShadow}`);
                            r.setProperty('--active-card-border', 'none');
                        } else {
                            r.setProperty('--active-card-border', g.borderWidth > 0 ? `${g.borderWidth}px ${g.borderStyle} ${g.borderColor}` : 'none');
                            r.setProperty('--active-card-shadow', regularShadow);
                        }
                },
                
                initAllSortables(){
                    this.initLayerSortables();
                    this.initSortablePreviewBlocks();
                },
                
                initLayerSortables() {
                    if(this.sortableLayers) this.sortableLayers.destroy(); 
                    this.sortableLayers = new Sortable(this.elements.layerList, {
                        group: 'layers',
                        animation: 150,
                        handle: '.layer-item',
                        ghostClass: 'sortable-ghost',
                        filter: 'hr, .layer-item[data-type="personalInfo"], .layer-actions, .layer-toggle, .card-layer-list',
                        onEnd: e => {
                            const oldIndex = e.oldIndex - 2;
                            const newIndex = e.newIndex - 2;
                            if (oldIndex === newIndex) return;
                            this.pushHistory();
                            const [moved] = this.state.blocks.splice(oldIndex, 1);
                            this.state.blocks.splice(newIndex, 0, moved);
                            this.debouncedSaveToLocal();
                            this.renderLayerPanel();
                            this.renderPreviewBlocks();
                        }
                    });
                },
                
                initNestedSortables() {
                    Object.values(this.cardLayerSortables).forEach(s => s.destroy());
                    this.cardLayerSortables = {};
                    this.elements.layerList.querySelectorAll('.card-layer-list').forEach(list => {
                        const blockId = list.dataset.blockId;
                        this.cardLayerSortables[blockId] = new Sortable(list, {
                            group: `cards-${blockId}`,
                            animation: 150,
                            ghostClass: 'sortable-ghost',
                            onEnd: e => {
                                const block = this.findBlock(blockId);
                                if (!block) return;
                                this.pushHistory();
                                const [movedCard] = block.cards.splice(e.oldIndex, 1);
                                block.cards.splice(e.newIndex, 0, movedCard);
                                this.debouncedSaveToLocal();
                                this.renderPreviewBlockById(blockId);
                            }
                        });
                    });
                },
                
                initSortablePreviewBlocks() {
                    if (this.sortablePreview) this.sortablePreview.destroy();
                    this.sortablePreview = new Sortable(this.elements.previewBlocksContainer, {
                        animation: 150,
                        ghostClass: 'sortable-ghost',
                        onEnd: e => {
                            if (e.oldIndex === e.newIndex) return;
                            this.pushHistory();
                            const [movedBlock] = this.state.blocks.splice(e.oldIndex, 1);
                            this.state.blocks.splice(e.newIndex, 0, movedBlock);
                            this.debouncedSaveToLocal();
                            this.renderLayerPanel();
                        }
                    });
                },
                
                initSortableTags() {
                    const list = this.elements.inspectorPanel.querySelector('#tag-manager-list');
                    if (list) {
                        if (this.sortableTags) this.sortableTags.destroy();
                        this.sortableTags = new Sortable(list, {
                            animation: 150,
                            ghostClass: 'sortable-ghost',
                            onEnd: e => {
                                if (e.oldIndex === e.newIndex) return;
                                this.pushHistory();
                                const [movedTag] = this.state.personalInfo.tags.splice(e.oldIndex, 1);
                                this.state.personalInfo.tags.splice(e.newIndex, 0, movedTag);
                                this.debouncedSaveToLocal();
                                this.renderPersonalInfo();
                            }
                        });
                    }
                },

                initSortableCards(blockId){
                    const list = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${blockId}"] .card-editors-list`); 
                    if (list) { if(this.cardSortables[blockId]) this.cardSortables[blockId].destroy(); this.cardSortables[blockId] = new Sortable(list, { handle: '.card-drag-handle', animation: 150, ghostClass: 'sortable-ghost', onEnd: e => { const b = this.findBlock(blockId); if (b) { this.pushHistory(); const [m] = b.cards.splice(e.oldIndex, 1); b.cards.splice(e.newIndex, 0, m); this.debouncedSaveToLocal(); this.renderPreviewBlockById(blockId); this.renderLayerPanel(); } } }); } 
                },
                initSortableImageCards(blockId){
                    const container = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${blockId}"] .image-card-editors-list`);
                    if (container) { if (this.imageCardSortables[blockId]) this.imageCardSortables[blockId].destroy(); this.imageCardSortables[blockId] = new Sortable(container, { handle: '.card-drag-handle', animation: 150, ghostClass: 'sortable-ghost', onEnd: e => { const block = this.findBlock(blockId); if (block) { this.pushHistory(); const [moved] = block.cards.splice(e.oldIndex, 1); block.cards.splice(e.newIndex, 0, moved); this.debouncedSaveToLocal(); this.renderPreviewBlockById(blockId); this.renderLayerPanel(); } } }); }
                },

                initMasonryForBlock(blockId) {
                    this.destroyMasonryForBlock(blockId); 
                    const block = this.findBlock(blockId);
                    if (block && (block.type === 'text' || block.type === 'image') && ['dual', 'triple'].includes(block.settings.layout) && block.settings.masonryEnabled) {
                        const previewEl = this.elements.previewBlocksContainer.querySelector(`[data-block-id="${blockId}"] .preview-cards-container`);
                        if (previewEl) {
                            previewEl.classList.add('masonry-active');
                            const itemSelector = block.type === 'text' ? '.preview-card' : 'figure';
                            this.masonryInstances[blockId] = new Masonry(previewEl, {
                                itemSelector: itemSelector,
                                gutter: 15
                            });
                        }
                    }
                },
                destroyMasonryForBlock(blockId) {
                    if (this.masonryInstances[blockId]) {
                        this.masonryInstances[blockId].destroy();
                        delete this.masonryInstances[blockId];
                        const previewEl = this.elements.previewBlocksContainer.querySelector(`[data-block-id="${blockId}"] .preview-cards-container`);
                        if (previewEl) {
                            previewEl.classList.remove('masonry-active');
                        }
                    }
                },
                
                togglePanelDrawer(panelId){
                    if (panelId === false) {
                        this.elements.layerPanel.classList.remove('is-open');
                        this.elements.inspectorPanel.classList.remove('is-open');
                        this.elements.body.classList.remove('panels-open');
                        return;
                    }
                    const panel = document.getElementById(panelId);
                    const isOpen = panel.classList.toggle('is-open');
                    this.elements.body.classList.toggle('panels-open', isOpen || this.elements.layerPanel.classList.contains('is-open') || this.elements.inspectorPanel.classList.contains('is-open'));
                    
                    if(isOpen) {
                        if (panelId === 'layer-panel') this.elements.inspectorPanel.classList.remove('is-open');
                        if (panelId === 'inspector-panel') this.elements.layerPanel.classList.remove('is-open');
                    }
                },
                async resetToDefault() {
                    if (await this.showConfirm('æ¢å¤é»˜è®¤æ¨¡æ¿', 'è­¦å‘Šï¼šæ­¤æ“ä½œå°†æ¸…ç©ºæ‚¨æ‰€æœ‰çš„å†…å®¹å’Œæ ·å¼è®¾ç½®ï¼Œå¹¶æ¢å¤åˆ°åˆå§‹æ¨¡æ¿ã€‚æ­¤è¿‡ç¨‹ä¸å¯æ’¤é”€ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
                        localStorage.removeItem('blokkoState');
                        this.state = this.getDefaultState();
                        this.history = [this.deepClone(this.state)];
                        this.historyIndex = 0;
                        this.updateUndoRedoButtons();
                        this.renderAll(true);
                        this.syncAllControls();
                        this.setSelection({type: 'global'});
                        this.showToast('å·²æ¢å¤ä¸ºé»˜è®¤æ¨¡æ¿', 'success');
                    }
                },

                toggleLockMode() {
                    const isLocked = this.elements.previewBlocksContainer.classList.toggle('locked-mode');
                    const button = this.elements.lockModeToggle;
                    
                    button.textContent = isLocked ? 'é¢„è§ˆä¸­' : 'ç¼–è¾‘ä¸­';
                    button.title = isLocked ? 'é¢„è§ˆæ¨¡å¼ (ç‚¹å‡»åˆ‡æ¢ä¸ºç¼–è¾‘æ¨¡å¼)' : 'ç¼–è¾‘æ¨¡å¼ (ç‚¹å‡»åˆ‡æ¢ä¸ºé¢„è§ˆæ¨¡å¼)';
                    
                    const shouldDisable = isLocked;
                    
                    if (this.sortableLayers) this.sortableLayers.option('disabled', shouldDisable);
                    if (this.sortablePreview) this.sortablePreview.option('disabled', shouldDisable);
                    if (this.sortableTags) this.sortableTags.option('disabled', shouldDisable);
                    Object.values(this.cardLayerSortables).forEach(s => { if (s) s.option('disabled', shouldDisable); });
                    Object.values(this.cardSortables).forEach(s => { if (s) s.option('disabled', shouldDisable); });
                    Object.values(this.imageCardSortables).forEach(s => { if (s) s.option('disabled', shouldDisable); });
                },
                
                renderTagManager() {
                    const container = this.elements.inspectorPanel.querySelector('#tag-manager-list');
                    if (!container) return;
                    const tags = this.state.personalInfo.tags || [];
                    if (!tags.length) {
                        container.innerHTML = `<div class="empty-tag-list">æš‚æ— æ ‡ç­¾</div>`;
                        return;
                    }
                    container.innerHTML = tags.map(tag => {
                        const iconHTML = tag.icon ? `<span class="iconify" data-icon="${tag.icon}"></span>` : 'æ— ';
                        return `<div class="tag-manager-item" data-tag-id="${tag.id}">
                            <button class="btn btn-default btn-icon tag-icon-btn">${iconHTML}</button>
                            <input type="text" class="tag-text-input" value="${this.escapeHTML(tag.text)}">
                            <button class="btn btn-danger btn-icon tag-delete-btn"><span class="iconify" data-icon="mdi:delete"></span></button>
                        </div>`;
                    }).join('');
                },
                addNewTag() {
                    const textInput = this.elements.inspectorPanel.querySelector('#new-tag-text-input');
                    if(!textInput) return;
                    const text = textInput.value.trim();
                    if (!text) return;
                    this.pushHistory();
                    if(!this.state.personalInfo.tags) this.state.personalInfo.tags = [];
                    this.state.personalInfo.tags.push({ id: this.generateId('t'), icon: null, text });
                    this.debouncedSaveToLocal();
                    this.renderPersonalInfo();
                    this.renderTagManager();
                    textInput.value = '';
                    textInput.focus();
                },
                deleteTag(tagId) {
                    this.pushHistory();
                    this.state.personalInfo.tags = this.state.personalInfo.tags.filter(t => t.id !== tagId);
                    this.debouncedSaveToLocal();
                    this.renderPersonalInfo();
                    this.renderTagManager();
                },
                updateTag(tagId, key, value, pushHistory) {
                    const tagIndex = this.state.personalInfo.tags.findIndex(t => t.id === tagId);
                    if (tagIndex > -1) this.updateState(`personalInfo.tags.${tagIndex}.${key}`, value, pushHistory);
                },

                initIconPicker() {
                    if (this.iconPickerInitialized) return;
                    this.loadIcons();
                    this.iconPickerInitialized = true;
                },
                initTexturePicker() {
                    if (this.texturePickerInitialized) return;
                    this.renderTexturePicker();
                    this.elements.texturePickerModal.classList.add('visible');
                    this.texturePickerInitialized = true;
                },
                async loadIcons(){
                     this.showLoading('æ­£åœ¨åŠ è½½å›¾æ ‡åº“...');
                     try {
                         await this.sleep(100);
                         this.showToast('å›¾æ ‡åº“åŠ è½½å®Œæˆ', 'info');
                     } catch(e) {
                         this.showErrorModal('å›¾æ ‡åº“åŠ è½½å¤±è´¥', 'æ— æ³•è¿æ¥åˆ° Iconify APIï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚');
                     } finally {
                        this.hideLoading();
                     }
                },
                async renderIconGrid(searchTerm = ''){
                     this.elements.iconGrid.innerHTML = `<div class="spinner" style="margin: 40px auto;"></div>`;
                     let customIconsHTML = '';
                     if (this.state.customIcons && this.state.customIcons.length > 0) {
                         customIconsHTML = this.state.customIcons.map(icon => 
                            `<div class="icon-grid-item" data-icon="${icon.dataUrl}" data-icon-name="${icon.name}" title="${this.escapeHTML(icon.name)}">
                                <img src="${icon.dataUrl}" style="width: 24px; height: 24px;">
                                <button class="btn btn-icon btn-danger btn-small delete-custom-icon-btn" title="åˆ é™¤æ­¤å›¾æ ‡">
                                    <span class="iconify" data-icon="mdi:delete"></span>
                                </button>
                            </div>`
                        ).join('');
                        customIconsHTML = `<h4>è‡ªå®šä¹‰å›¾æ ‡</h4><div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 10px;">${customIconsHTML}</div><hr class="separator"><h4>åœ¨çº¿å›¾æ ‡</h4>`;
                     }

                     if (!searchTerm) {
                         this.elements.iconGrid.innerHTML = customIconsHTML + '<p style="text-align: center; color: var(--text-placeholder);">è¯·è¾“å…¥å…³é”®è¯æœç´¢åœ¨çº¿å›¾æ ‡</p>';
                         return;
                     }
                     try {
                        const prefixes = 'lucide,tabler,mdi,ph,fa6-solid,fa6-brands';
                        const response = await fetch(`https://api.iconify.design/search?query=${encodeURIComponent(searchTerm)}&limit=99&prefixes=${prefixes}`);
                        const data = await response.json();

                        let onlineIconsHTML;
                        if (data.icons.length === 0) {
                            onlineIconsHTML = '<p style="text-align: center; color: var(--text-placeholder);">æœªæ‰¾åˆ°åŒ¹é…çš„åœ¨çº¿å›¾æ ‡</p>';
                        } else {
                            onlineIconsHTML = data.icons.map(name => 
                                `<div class="icon-grid-item" data-icon="${name}" title="${name}"><span class="iconify" data-icon="${name}"></span></div>`
                            ).join('');
                        }
                        this.elements.iconGrid.innerHTML = customIconsHTML + onlineIconsHTML;
                     } catch(e) {
                        this.elements.iconGrid.innerHTML = customIconsHTML + '<p style="text-align: center; color: var(--color-danger);">æœç´¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œã€‚</p>';
                     }
                },
                showIconPicker(type, id, cardId = null){
                     this.currentIconTarget = { type, id, cardId };
                     this.elements.iconPickerModal.classList.add('visible');
                     this.renderIconGrid(this.elements.iconSearch.value);
                     this.elements.iconSearch.focus();
                },
                hideIconPicker(){
                     this.elements.iconPickerModal.classList.remove('visible');
                     this.currentIconTarget = null;
                     this.elements.iconSearch.value = '';
                     this.elements.iconGrid.innerHTML = '';
                },
                selectIcon(iconClass){
                    if (this.currentIconTarget) {
                        const { type, id, cardId } = this.currentIconTarget;
                        if (type === 'card') {
                            this.updateCard(id, cardId, 'icon', iconClass, true);
                        } else if (type === 'tag') {
                            this.updateTag(id, 'icon', iconClass, true);
                        } else if (type === 'separator') {
                            this.updateBlockSettings(id, 'icon', iconClass, true);
                        }
                    }
                    this.hideIconPicker();
                },
                async handleIconUpload(event) {
                    const file = event.target.files[0];
                    if (!file || file.type !== 'image/svg+xml') {
                        this.showToast('è¯·ä¸Šä¼ ä¸€ä¸ª.svgæ ¼å¼çš„å›¾æ ‡æ–‡ä»¶', 'error');
                        return;
                    }
                    if (this.state.customIcons.some(icon => icon.name === file.name)) {
                        this.showToast(`å·²å­˜åœ¨åä¸º "${file.name}" çš„å›¾æ ‡`, 'error');
                        return;
                    }
                    try {
                        const dataUrl = await this.readFileAsDataURL(file);
                        this.pushHistory();
                        this.state.customIcons.push({ name: file.name, dataUrl: dataUrl });
                        this.debouncedSaveToLocal();
                        this.renderIconGrid(this.elements.iconSearch.value);
                        this.showToast(`å›¾æ ‡ "${file.name}" ä¸Šä¼ æˆåŠŸ`, 'success');
                    } catch (error) {
                        this.showErrorModal('å›¾æ ‡ä¸Šä¼ å¤±è´¥', error.message);
                    } finally {
                        event.target.value = '';
                    }
                },
                deleteCustomIcon(iconName) {
                    if (window.confirm(`ç¡®å®šè¦åˆ é™¤è‡ªå®šä¹‰å›¾æ ‡ "${iconName}" å—ï¼Ÿ`)) {
                        this.pushHistory();
                        this.state.customIcons = this.state.customIcons.filter(icon => icon.name !== iconName);
                        this.debouncedSaveToLocal();
                        this.renderIconGrid(this.elements.iconSearch.value);
                        this.showToast(`å›¾æ ‡ "${iconName}" å·²åˆ é™¤`, 'info');
                    }
                },

                renderTexturePicker() {
                    this.elements.textureGrid.innerHTML = HeroPatterns.map(p => {
                        const svg = p.svg('var(--text-primary)', 0.5);
                        const base64Svg = btoa(unescape(encodeURIComponent(svg)));
                        return `<div class="texture-grid-item" data-texture-name="${p.name}">
                                    <div class="texture-preview" style="background-image: url(data:image/svg+xml;base64,${base64Svg});"></div>
                                    <span class="texture-name">${p.name}</span>
                                </div>`;
                    }).join('');
                },
                selectTexture(textureName) {
                    this.updateState('pageStyles.pageBgPattern', textureName, true);
                    const currentTextureName = this.elements.inspectorPanel.querySelector('#current-texture-name');
                    if (currentTextureName) currentTextureName.textContent = textureName || 'æ— ';
                    this.elements.texturePickerModal.classList.remove('visible');
                },

                setSelection(newSelection) {
                    this.selection = newSelection;
                    this.updateHighlights();
                    this.renderInspector();
                },
                updateHighlights() {
                    document.querySelectorAll('.layer-item.selected, .card-layer-item.selected, .preview-block-wrapper.selected, .preview-header.selected, .editor-card.is-active').forEach(el => el.classList.remove('selected', 'is-active'));
                    
                    const { type, id, cardId } = this.selection;

                    if (type === 'personalInfo') {
                        document.querySelector('.layer-item[data-type="personalInfo"]')?.classList.add('selected');
                        this.elements.previewHeader.classList.add('selected');
                    } else if (type === 'block' && id) {
                        document.querySelector(`.layer-item[data-id="${id}"]`)?.classList.add('selected');
                        document.querySelector(`.preview-block-wrapper[data-block-id="${id}"]`)?.classList.add('selected');
                        if (cardId) {
                            document.querySelector(`.card-layer-item[data-card-id="${cardId}"]`)?.classList.add('selected');
                            document.querySelector(`.editor-card[data-card-id="${cardId}"]`)?.classList.add('is-active');
                        }
                    }
                },
                
                analyzeColorsFromImage(dataUrl) {
                    const img = new Image();
                    img.onload = () => {
                        try {
                            const palette = this.colorThief.getPalette(img, 8);
                            this.lastPalette = palette;
                            this.renderPalette(palette);
                            this.showToast('é¢œè‰²æå–æˆåŠŸï¼', 'success');
                        } catch(e) {
                            this.showErrorModal('é¢œè‰²æå–å¤±è´¥', e.message);
                        }
                    };
                    img.onerror = () => this.showErrorModal('å›¾ç‰‡åŠ è½½å¤±è´¥', 'æ— æ³•ä»è¯¥å›¾ç‰‡æå–é¢œè‰²ã€‚');
                    img.src = dataUrl;
                },
                renderPalette(palette) {
                    const container = document.getElementById('color-thief-palette');
                    if (!container) return;
                    container.innerHTML = palette.map(rgb => {
                        const hex = `#${rgb[0].toString(16).padStart(2,'0')}${rgb[1].toString(16).padStart(2,'0')}${rgb[2].toString(16).padStart(2,'0')}`;
                        return `<div class="palette-color" data-color="${hex}" style="background-color: ${hex};"><div class="color-tooltip">${hex}</div></div>`;
                    }).join('');
                },
                bindColorThiefEvents() {
                    const paletteContainer = document.getElementById('color-thief-palette');
                    if (!paletteContainer) return;
                    
                    const handleInteraction = (e) => {
                        const colorEl = e.target.closest('.palette-color');
                        if (!colorEl) return;
                        e.preventDefault();
                        this.showColorContextMenu(e.clientX, e.clientY, colorEl.dataset.color);
                    };

                    paletteContainer.addEventListener('contextmenu', handleInteraction);
                    paletteContainer.addEventListener('touchstart', e => {
                        const colorEl = e.target.closest('.palette-color');
                        if (!colorEl) return;
                        this.longPressTimer = setTimeout(() => {
                            const touch = e.touches[0];
                            this.showColorContextMenu(touch.clientX, touch.clientY, colorEl.dataset.color);
                        }, 500);
                    });
                    paletteContainer.addEventListener('touchend', () => clearTimeout(this.longPressTimer));
                    paletteContainer.addEventListener('touchmove', () => clearTimeout(this.longPressTimer));
                },
                showColorContextMenu(x, y, color) {
                    const menu = this.elements.colorContextMenu;
                    menu.style.display = 'block';
                    menu.style.left = `${x}px`;
                    menu.style.top = `${y}px`;
                    menu.dataset.color = color;
                },
                hideColorContextMenu() {
                    this.elements.colorContextMenu.style.display = 'none';
                },
                
                switchTab(sectionSelector, desiredTabId) {
                    const section = this.elements.inspectorPanel.querySelector(sectionSelector);
                    if (!section) return;

                    const tabButton = section.querySelector(`.tab-btn[data-tab="${desiredTabId}"]`);
                    if (!tabButton) return;

                    section.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                    tabButton.classList.add('active');

                    section.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    const tabContent = section.querySelector(`#${desiredTabId}`);
                    if (tabContent) {
                        tabContent.classList.add('active');
                    }
                },

                applyQuickColor(action, color) {
                    const actionMap = {
                        'apply-page-bg-solid': 'pageStyles.pageBgSolidColor',
                        'apply-page-bg-gradient-start': 'pageStyles.pageBgGradientStart',
                        'apply-page-bg-gradient-end': 'pageStyles.pageBgGradientEnd',
                        'apply-header-bg-solid': 'pageStyles.headerBgColor',
                        'apply-header-bg-gradient-start': 'pageStyles.headerBgGradientStart',
                        'apply-header-bg-gradient-end': 'pageStyles.headerBgGradientEnd',
                        'apply-header-text': 'pageStyles.headerTextColor',
                        'apply-gcard-bg': 'globalCardStyles.bgColor',
                        'apply-gcard-bg-gradient-start': 'globalCardStyles.bgGradientStart',
                        'apply-gcard-bg-gradient-end': 'globalCardStyles.bgGradientEnd',
                        'apply-gcard-text': 'globalCardStyles.textColor',
                    };

                    if (actionMap[action]) {
                        this.updateState(actionMap[action], color, true);
                        this.showToast('é¢œè‰²å·²åº”ç”¨', 'info');

                        if (action.includes('gradient')) {
                            if (action.startsWith('apply-page-bg')) {
                                this.updateState('pageStyles.pageBgMode', 'gradient', false);
                                this.switchTab('#page-styles-section .tab-group-wrapper:first-child', 'page-bg-gradient');
                            } else if (action.startsWith('apply-header-bg')) {
                                this.updateState('pageStyles.headerBgMode', 'gradient', false);
                                this.switchTab('#page-styles-section .tab-group-wrapper:last-child', 'header-bg-gradient');
                            } else if (action.startsWith('apply-gcard-bg')) {
                                this.updateState('globalCardStyles.bgMode', 'gradient', false);
                                this.switchTab('#global-card-styles-section', 'card-bg-gradient');
                            }
                        } else if (action.includes('solid')) {
                             if (action.startsWith('apply-page-bg')) {
                                this.updateState('pageStyles.pageBgMode', 'solid', false);
                                this.switchTab('#page-styles-section .tab-group-wrapper:first-child', 'page-bg-solid');
                            } else if (action.startsWith('apply-header-bg')) {
                                this.updateState('pageStyles.headerBgMode', 'solid', false);
                                this.switchTab('#page-styles-section .tab-group-wrapper:last-child', 'header-bg-solid');
                            } else if (action.startsWith('apply-gcard-bg')) {
                                this.updateState('globalCardStyles.bgMode', 'solid', false);
                                this.switchTab('#global-card-styles-section', 'card-bg-solid');
                            }
                        }
                    }
                },

                hexToRgba(hex, alpha=1){
                    if(!hex || parseFloat(alpha) === 0) return 'transparent';
                    if (hex.startsWith('rgba')) {
                        return hex.replace(/, ?\d?\.?\d+\)$/, `, ${alpha})`);
                    }
                    const match = hex.match(/\w\w/g);
                    if (!match) return `rgba(0,0,0,${alpha})`;
                    const [r, g, b] = match.map(x => parseInt(x, 16)); 
                    return `rgba(${r},${g},${b},${alpha})`;
                },
                
                debounce(func, wait){
                     let timeout; 
                     return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), wait); }; 
                },
                generateId(p){ return `${p}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}` },
                deepClone(obj){ return JSON.parse(JSON.stringify(obj)) },
                escapeHTML(str){ return (str || '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'})[m]) },
                sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)) },

                async addBlock(type, sourceBlock = null) {
                    this.pushHistory();
                    let newBlock;
                    
                    if (sourceBlock) {
                        newBlock = this.deepClone(sourceBlock);
                        newBlock.title = `${sourceBlock.title} (å‰¯æœ¬)`;
                        if (newBlock.cards) {
                            newBlock.cards.forEach(card => {
                                card.title = "";
                                card.content = "";
                                card.description = "";
                            });
                        }
                    } else {
                        const defaultState = this.getDefaultState();
                        const blockTemplate = defaultState.blocks.find(b => b.type === type);
                        newBlock = this.deepClone(blockTemplate);
                    }

                    newBlock.id = this.generateId('b');
                    if (newBlock.cards) {
                        newBlock.cards.forEach(c => c.id = this.generateId('c'));
                    }

                    const insertIndex = sourceBlock ? this.findBlockIndex(sourceBlock.id) + 1 : this.state.blocks.length;
                    this.state.blocks.splice(insertIndex, 0, newBlock);
                    
                    this.debouncedSaveToLocal();
                    this.renderLayerPanel();
                    this.renderPreviewBlocks();
                    await this.sleep(10);
                    this.setSelection({ type: 'block', id: newBlock.id });
                    
                    if (sourceBlock) this.showToast('æ ·å¼å·²å¤åˆ¶', 'success');
                },
                async deleteBlock(blockId) {
                    if (await this.showConfirm('åˆ é™¤åŒºå—', 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåŒºå—å—ï¼Ÿ')) {
                        this.pushHistory();
                        this.destroyMasonryForBlock(blockId);
                        this.state.blocks = this.state.blocks.filter(b => b.id !== blockId);
                        this.debouncedSaveToLocal();
                        
                        if (this.selection.type === 'block' && this.selection.id === blockId) {
                            this.setSelection({type: 'global'});
                        } 
                        
                        this.renderLayerPanel();
                        this.renderPreviewBlocks();
                        this.showToast('åŒºå—å·²åˆ é™¤', 'info');
                    }
                },
                
                toggleBlockVisibility(blockId) {
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) {
                        const currentVisibility = this.state.blocks[blockIndex].isVisible;
                        this.updateState(`blocks.${blockIndex}.isVisible`, currentVisibility === false ? true : false, true);
                    }
                },
                
                duplicateBlock(blockId) {
                    const block = this.findBlock(blockId);
                    if (block) {
                        this.addBlock(block.type, block);
                    }
                },
                
                async activateDebugMode() {
                    if (await this.showConfirm('æ¿€æ´»è°ƒè¯•æ¨¡å¼', 'æ­¤æ“ä½œå°†éšæœºåŒ–å½“å‰æ‰€æœ‰è®¾ç½®å¹¶æ›¿æ¢å†…å®¹ï¼Œæ­¤è¿‡ç¨‹ä¸å¯æ’¤é”€ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ')) {
                        this.showLoading('æ­£åœ¨ç”Ÿæˆéšæœºæ•°æ®...');
                        this.state = this.generateRandomState();
                        this.history = [this.deepClone(this.state)];
                        this.historyIndex = 0;
                        this.setSelection({type: 'global'});
                        this.renderAll(true);
                        this.syncAllControls();
                        this.updateUndoRedoButtons();
                        this.hideLoading();
                        this.showToast('è°ƒè¯•æ¨¡å¼å·²æ¿€æ´»ï¼Œæ‰€æœ‰è®¾ç½®å·²éšæœºåŒ–ï¼', 'success');
                    }
                },
                generateRandomState() {
                    const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
                    const randFloat = (min, max) => Math.random() * (max - min) + min;
                    const randBool = () => Math.random() > 0.5;
                    const randChoice = (arr) => arr[rand(0, arr.length - 1)];
                    const safeColors = ['#e63946', '#f1faee', '#a8dadc', '#457b9d', '#1d3557', '#000000', '#ffffff'];
                    const randColor = () => randChoice(safeColors);

                    let randomState = this.deepClone(this.getDefaultState());

                    randomState.personalInfo.nickname = "è°ƒè¯•æ˜µç§°";
                    randomState.personalInfo.subtitle = `Debug Subtitle ${rand(100, 999)}`;
                    randomState.personalInfo.bio = `è¿™æ˜¯éšæœºç”Ÿæˆçš„ç®€ä»‹æ–‡æœ¬ã€‚ The quick brown fox jumps over the lazy dog.`;
                    randomState.personalInfo.nicknameColor = randColor();
                    randomState.personalInfo.subtitleColor = randColor();
                    randomState.personalInfo.bioColor = randColor();
                    randomState.personalInfo.avatarShape = randChoice(['50%', '16px', '0px']);
                    randomState.personalInfo.avatarBorderSize = rand(0, 10);
                    randomState.personalInfo.avatarBorderColor = randColor();
                    randomState.personalInfo.tags = Array.from({length: rand(3, 5)}, (_, i) => ({ id: this.generateId('t'), icon: null, text: `æ ‡ç­¾${i+1}`}));
                    randomState.personalInfo.tagBgColor = randColor();
                    randomState.personalInfo.tagTextColor = randColor();
                    randomState.pageStyles.pageBgMode = randChoice(['solid', 'gradient']);
                    randomState.pageStyles.pageBgSolidColor = randColor();
                    randomState.globalCardStyles.bgColor = randColor();
                    randomState.globalCardStyles.textColor = randColor();
                    randomState.globalCardStyles.shadowEnabled = false;

                    randomState.blocks = [];
                    const blockTypes = ['text', 'image', 'separator', 'spacer'];
                    for (let i = 0; i < rand(5, 8); i++) {
                        const type = randChoice(blockTypes);
                        let newBlock;
                        switch(type) {
                            case 'text':
                                newBlock = { id: this.generateId('b'), isVisible: true, type: 'text', title: `éšæœºæ–‡æœ¬åŒºå— ${i+1}`, settings: { layout: randChoice(['single', 'dual', 'triple']), masonryEnabled: randBool() }, cards: Array.from({length: rand(2, 5)}, (_, j) => ({ id: this.generateId('c'), icon: '', title: `éšæœºå¡ç‰‡ ${j+1}`, content: `éšæœºå†…å®¹ - ${Math.random().toString(36).substring(2)}`, opacity: 1.0, followGlobalOpacity: true })) };
                                break;
                            case 'image':
                                newBlock = { id: this.generateId('b'), isVisible: true, type: 'image', title: `éšæœºå›¾ç‰‡åŒºå— ${i+1}`, settings: { layout: randChoice(['single', 'dual', 'triple']), masonryEnabled: randBool(), textColor: randColor() }, cards: [] };
                                break;
                            case 'separator':
                                newBlock = { id: this.generateId('b'), isVisible: true, type: 'separator', title: `éšæœºåˆ†å‰²çº¿ ${i+1}`, settings: { style: randChoice(['solid', 'dashed', 'dotted']), color: randColor(), thickness: rand(1, 5), margin: rand(10, 40), text: 'Random Text', icon: null, textColor: randColor() }};
                                break;
                            case 'spacer':
                                newBlock = { id: this.generateId('b'), isVisible: true, type: 'spacer', title: `éšæœºç•™ç™½ ${i+1}`, settings: { height: rand(20, 100) }};
                                break;
                        }
                        randomState.blocks.push(newBlock);
                    }
                    return randomState;
                }
            };
            App.init();
        });
    </script>
</body>
</html>
