<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Blokko v1.6.0 (Internal): -->
    <title>Blokko-ä¸ªäººç®€ä»‹ç”Ÿæˆå™¨ï¼ (v1.6.0)-æ¥ç©ã€Šèµ›åšæœ‹å…‹ï¼š2077ã€‹å§ï¼</title>
    
    <script>
        // Anti-FOUC (Flash of Unstyled Content) è„šæœ¬ï¼Œé˜²æ­¢åŠ è½½æ—¶æ ·å¼é—ªçƒ
        try {
            if (localStorage.getItem('blokkoTheme') === 'dark') {
                document.documentElement.classList.add('dark-mode');
            }
        } catch (e) {
            console.error('ä» localStorage åº”ç”¨ä¸»é¢˜å¤±è´¥', e);
        }
    </script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" />
    <!-- FEATURE: Rich Text Editor - Quill.js CSS -->
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">


    <!-- æ¨èå­—ä½“ CDN -->
    <link rel="stylesheet" href="https://fontsapi.zeoseven.com/69/main/result.css">
    <link rel="stylesheet" href="https://fontsapi.zeoseven.com/285/main/result.css">
    <link rel="stylesheet" href="https://fontsapi.zeoseven.com/47/main/result.css">
    <link rel="stylesheet" href="https://fontsapi.zeoseven.com/265/main/result.css">
	<link rel="stylesheet" href="https://fontsapi.zeoseven.com/292/main/result.css">

    <style>
        /* CSS å˜é‡ */
        :root {
            --bg-editor: #ffffff; --bg-preview-pane: #f0f2f5; --bg-preview-page: #ffffff;
            --bg-card: #ffffff; --bg-input: #f9f9f9; --bg-section: #fdfdfd;
            --bg-modal-overlay: rgba(0, 0, 0, 0.6); --bg-inset: #f0f2f5;
            --bg-image-thumb: #eeeeee; --bg-image-upload-hover: #eef5ff;
            --text-primary: #1a1a1a; --text-secondary: #555555; --text-label: #333333;
            --text-placeholder: #999; --text-on-primary: #ffffff; --text-action: #007AFF;
            --border-color: #e8e8e8; --border-input: #d1d5db; --border-dashed: #cccccc;
            --shadow-light: rgba(0, 0, 0, 0); --shadow-medium: rgba(0, 0, 0, 0);
            --preset-text-shadow: none;
            --color-primary: #007AFF; --color-primary-hover: #0056CC; --color-danger: #ff4757;
            --color-danger-hover: #e03c48; --color-secondary: #8e8e93; --color-secondary-hover: #636366;
            --header-height: 55px; --transition-speed: 0.3s; --transition-short: 0.2s;
            --layer-panel-width: 280px; --inspector-panel-width: 380px;
            /* å…¨å±€å¡ç‰‡æ ·å¼å˜é‡ */
            --g-card-bg-color: var(--bg-card); --g-card-text-color: var(--text-primary); --g-card-opacity: 1;
            --g-card-shadow: none;
            --g-card-border-radius: 12px; --g-card-text-align: left;
            --g-card-line-height: 1.5; --g-card-font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --g-card-font-size: 1rem;
            --g-card-text-stroke: 0px transparent;
            --g-card-border: 1px solid transparent;
            /* æ´»åŠ¨å¡ç‰‡æ ·å¼å˜é‡ (ç”¨äºé¢„è§ˆ) */
            --active-card-shadow: var(--g-card-shadow); --active-card-border: var(--g-card-border);
            --active-card-text-shadow: none; --active-card-font-family: var(--g-card-font-family);
            --active-card-font-size: var(--g-card-font-size); 
        }
        html.dark-mode {
            --bg-editor: #1f2229; --bg-preview-pane: #121417; --bg-preview-page: #1f2229;
            --bg-card: #2c303a; --bg-input: #2c303a; --bg-section: #252830;
            --bg-modal-overlay: rgba(0, 0, 0, 0.7); --bg-inset: #2c2c2e;
            --bg-image-thumb: #3e4451; --bg-image-upload-hover: #2c3e50;
            --text-primary: #f0f2f5; --text-secondary: #a0aec0; --text-label: #e2e8f0;
            --text-placeholder: #777; --text-on-primary: #ffffff; --text-action: #3498db;
            --border-color: #3e4451; --border-input: #4a5160; --border-dashed: #555;
            --shadow-light: rgba(0, 0, 0, 0); --shadow-medium: rgba(0, 0, 0, 0);
            --preset-text-shadow: none;
            --g-card-bg-color: var(--bg-card); --g-card-text-color: var(--text-primary);
            --g-card-shadow: none;
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { font-family: var(--g-card-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif); background-color: var(--bg-preview-pane); color: var(--text-primary); transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        
        #storage-warning-banner {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: var(--color-danger);
            color: white;
            padding: 8px 20px;
            text-align: center;
            font-size: 0.9rem;
            z-index: 9999;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #storage-warning-banner a {
            color: white;
            font-weight: bold;
            text-decoration: underline;
            cursor: pointer;
        }
        body.storage-warning .app-header, body.storage-warning .app-container {
            top: 35px; /* ä¸ºè­¦å‘Šæ¡è…¾å‡ºç©ºé—´ */
        }
        body.storage-warning .app-container {
             height: calc(100vh - 35px);
        }
        body.storage-warning .layer-panel, body.storage-warning .inspector-panel, body.storage-warning .resizer {
            top: calc(var(--header-height) + 35px);
            height: calc(100vh - var(--header-height) - 35px);
        }

        .app-header { width: 100%; height: var(--header-height); background: var(--bg-editor); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; position: fixed; top: 0; left: 0; z-index: 100; box-shadow: 0 2px 8px var(--shadow-light); transition: all var(--transition-speed) ease; }
        .header-actions-wrapper { display: flex; align-items: center; gap: 15px; }
        .app-header-title { font-size: 1.25rem; font-weight: 700; cursor: default; }
        .theme-switch-wrapper { display: flex; align-items: center; gap: 10px; }
        .app-container { display: flex; height: 100vh; padding-top: var(--header-height); position: relative; top: 0; transition: top 0.3s ease; }

        .layer-panel, .inspector-panel {
            background: var(--bg-editor);
            height: calc(100vh - var(--header-height));
            overflow-y: auto;
            flex-shrink: 0;
            transition: all var(--transition-speed) ease;
            position: relative;
        }
        .layer-panel {
            width: var(--layer-panel-width);
            border-right: 1px solid var(--border-color);
            padding: 15px;
        }
        .inspector-panel {
            width: var(--inspector-panel-width);
            min-width: 350px;
            max-width: 60vw;
            border-left: 1px solid var(--border-color);
            padding: 25px;
        }
        .resizer {
            width: 5px;
            height: calc(100vh - var(--header-height));
            background: var(--border-color);
            cursor: col-resize;
            z-index: 50;
            flex-shrink: 0;
            position: relative;
            transition: all var(--transition-speed) ease;
        }
        .resizer:hover { background: var(--color-primary); }
        .preview-panel {
            flex-grow: 1;
            height: calc(100vh - var(--header-height));
            overflow-y: auto;
            display: flex;
            justify-content: center;
            padding: 40px 20px;
            background: var(--bg-preview-pane);
            transition: background-color var(--transition-speed) ease;
        }
        
        .panel-header {
            font-size: 1.1rem;
            font-weight: 700;
            padding-bottom: 10px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .back-to-global-btn {
            font-size: 0.9rem;
            font-weight: normal;
            color: var(--text-action);
            cursor: pointer;
            background: none;
            border: none;
            padding: 4px 8px;
        }
        .back-to-global-btn:hover { text-decoration: underline; }

        .layer-item-container { margin-bottom: 5px; }
        .layer-list .layer-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: background-color var(--transition-short), border-color var(--transition-short);
        }
        .layer-list .layer-item:hover { background-color: var(--bg-input); }
        .layer-list .layer-item.selected {
            background-color: var(--bg-image-upload-hover);
            border-color: var(--color-primary);
            font-weight: 600;
        }
        .layer-toggle {
            background: none; border: none; cursor: pointer; color: var(--text-secondary);
            width: 20px; height: 20px; padding: 0; font-size: 1.2rem;
            flex-shrink: 0; display: flex; align-items: center; justify-content: center;
            transition: transform var(--transition-short);
        }
        .layer-item-container:not(.is-expandable) .layer-toggle { visibility: hidden; }
        .layer-item-container.is-expanded .layer-toggle { transform: rotate(90deg); }
        .layer-list .layer-item .layer-icon {
            font-size: 1.1em;
            color: var(--text-secondary);
        }
        .layer-list .layer-item .layer-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-left: 4px;
        }
        .layer-actions { display: flex; align-items: center; gap: 4px; }
        .layer-actions .btn-icon {
            width: 26px; height: 26px; padding: 0; font-size: 1.1rem;
            background: none; border: none; color: var(--text-secondary);
        }
        .layer-actions .btn-icon:hover { background: var(--border-color); }
        .layer-item.is-hidden .layer-name, .layer-item.is-hidden .layer-icon { opacity: 0.5; }
        .layer-item.is-hidden .layer-name { text-decoration: line-through; }
        
        .card-layer-list {
            list-style: none; padding-left: 30px; margin: 5px 0; display: none;
        }
        .layer-item-container.is-expanded .card-layer-list { display: block; }
        .card-layer-item {
            font-size: 0.9rem; padding: 6px 8px; border-radius: 4px;
            color: var(--text-secondary); white-space: nowrap; overflow: hidden;
            text-overflow: ellipsis; cursor: pointer; /* Changed to pointer */
        }
        .card-layer-item:hover, .card-layer-item.selected { background-color: var(--bg-input); }
        .card-layer-item.sortable-ghost { background-color: var(--bg-image-upload-hover); }

        .layer-list hr { border: none; border-top: 1px solid var(--border-color); margin: 15px 0; }
        
        .inspector-state { display: none; }
        .inspector-state.active { display: block; animation: fadeIn 0.3s ease; }
        .inspector-placeholder { text-align: center; color: var(--text-placeholder); padding: 40px 10px; font-style: italic; }
        .inspector-placeholder .iconify { font-size: 2rem; margin-bottom: 10px; }

        .preview-block-wrapper.selected, .preview-header.selected {
            outline: 2px solid var(--color-primary);
        }
        .preview-block-wrapper.is-hidden { display: none; }
        
        body.export-mode .preview-panel { justify-content: flex-start; }
        .preview-wrapper { width: 100%; max-width: 600px; min-height: fit-content; border-radius: 20px; box-shadow: 0 4px 16px var(--shadow-medium); padding: 20px; padding-bottom: 40px; transition: all var(--transition-speed) ease; position: relative; overflow: hidden; font-family: var(--active-card-font-family); font-size: var(--active-card-font-size); }
        .preview-wrapper::before { content: none; }
        .preview-overlay { display: none; }
        .preview-header, .preview-blocks-container { position: relative; z-index: 2; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box; }
        [data-state-key], [data-card-key], [data-separator-text-key], .tag-pill span[data-tag-id] { position: relative; } /* For mobile edit icon */
        [data-state-key]:hover, [data-card-key]:hover, [data-separator-text-key]:hover, .tag-pill span[data-tag-id]:hover { outline: 1px dashed var(--color-primary); cursor: text; }
        [contenteditable="true"] { outline: 2px solid var(--color-primary); box-shadow: 0 0 8px rgba(0, 122, 255, 0.5); background-color: rgba(0, 122, 255, 0.1); border-radius: 4px; }
        .btn { display: inline-block; border: none; padding: 10px 16px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: background-color var(--transition-short) ease, transform var(--transition-short) ease, box-shadow var(--transition-short) ease; text-align: center; width: 100%; color: var(--text-on-primary); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .btn-primary { background: var(--color-primary); } .btn-primary:hover:not(:disabled) { background: var(--color-primary-hover); box-shadow: 0 4px 8px rgba(0,122,255,0.3); }
        .btn-secondary { background: var(--color-secondary); } .btn-secondary:hover:not(:disabled) { background: var(--color-secondary-hover); box-shadow: 0 4px 8px rgba(142,142,147,0.3); }
        .btn-danger { background: var(--color-danger); } .btn-danger:hover:not(:disabled) { background: var(--color-danger-hover); box-shadow: 0 4px 8px rgba(255,71,87,0.3); }
        .btn-default { background-color: var(--bg-input); border: 1px solid var(--border-input); color: var(--text-secondary); } .btn-default:hover:not(:disabled) { background-color: var(--border-color); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .btn:active:not(:disabled) { transform: scale(0.98); } .btn:disabled { background: #999; cursor: not-allowed; opacity: 0.6; }
        .btn-small { padding: 6px 10px; font-size: 0.9rem; }
        .btn-icon { width: auto; padding: 6px 10px; font-size: 0.9rem; display: flex; align-items: center; justify-content: center; }
        .editor-section { width: 100%; background: var(--bg-section); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; margin-bottom: 15px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; box-shadow: 0 2px 8px var(--shadow-light); }
        .editor-section legend { font-size: 1.1rem; font-weight: 700; color: var(--text-primary); margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); width: 100%; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .editor-section legend::after { content: " â–¼"; font-size: 0.8rem; }
        .editor-section.collapsed legend::after { content: " â–¶"; }
        .editor-section.collapsed .section-content { display: none; }
        
        .advanced-toggle-label { font-size: 0.85rem; font-weight: normal; color: var(--text-action); }
        /* é»˜è®¤éšè—æ‰€æœ‰é«˜çº§è®¾ç½® */
        .advanced-setting { display: none; }

        /* å½“å‹¾é€‰é«˜çº§æ—¶ï¼Œæ˜¾ç¤ºå¯¹åº”çš„è®¾ç½® */
        .show-advanced .advanced-setting { 
            display: block; 
            animation: fadeIn 0.3s; 
        }
        
        /* ç‰¹åˆ«å¤„ç† flex å¸ƒå±€ä¸­çš„ tab æŒ‰é’® */
        .tabs.show-advanced .tab-btn.advanced-setting,
        .show-advanced .tabs .tab-btn.advanced-setting {
            display: inline-flex;
        }
        
        /* å…³é”®ä¿®å¤ï¼šç¡®ä¿éæ¿€æ´»çš„æ ‡ç­¾é¡µå†…å®¹å³ä½¿æ˜¯é«˜çº§é€‰é¡¹ï¼Œä¹Ÿä¿æŒéšè— */
        .tab-content.advanced-setting:not(.active) {
            display: none !important;
        }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .section-header h4 { margin: 0; }

        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 6px; font-weight: 600; font-size: 0.9rem; color: var(--text-label); }
        .form-group input[type="text"], .form-group input[type="number"], .form-group input[type="file"], .form-group select, .form-group textarea { width: 100%; padding: 10px; font-size: 14px; background: var(--bg-input); border: 1px solid var(--border-input); border-radius: 6px; color: var(--text-primary); transition: all var(--transition-short) ease; max-width: 100%; overflow-wrap: break-word; }
        .form-group input[type="text"]:focus, .form-group input[type="number"]:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2); }
        .form-group textarea { min-height: 80px; resize: vertical; }
        .input-group { display: flex; align-items: center; gap: 0; border: 1px solid var(--border-input); border-radius: 6px; overflow: hidden;}
        .input-group:focus-within { border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2); }
        .input-group.simple { border: none; border-radius: 0; gap: 10px; } .input-group.simple:focus-within { box-shadow: none; }
        .input-group input[type="color"] { flex-shrink: 0; width: 40px; height: 38px; border: none; background: transparent; cursor: pointer; }
        .input-group input[type="text"].color-hex-input { flex-grow: 1; border: none; border-left: 1px solid var(--border-input); border-radius: 0; padding-left: 10px; background-color: var(--bg-input); color: var(--text-primary); }
        .input-group input[type="text"].color-hex-input:focus { outline: none; box-shadow: none; }
        .input-group input[type="range"] { flex-grow: 1; height: 20px; cursor: pointer; min-width: 100px; }
        .stepper-group { display: flex; align-items: center; gap: 5px; }
        .stepper-group input[type="range"] { flex-grow: 1; }
        .btn-stepper { display: none; flex-shrink: 0; width: 30px; height: 30px; padding: 0; font-size: 1.2rem; line-height: 30px; border-radius: 50%; }
        .radio-group { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; background: var(--bg-input); border: 1px solid var(--border-input); border-radius: 6px; padding: 10px; }
        .radio-group label { margin: 0; font-weight: normal; display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.9rem; }
        .color-control-row { display: flex; flex-wrap: wrap; gap: 15px; align-items: flex-start; min-width: 0; }
        .color-control-group { flex: 1; min-width: 150px; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer; }
        .checkbox-group label { display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer; margin: 0; }
        .checkbox-group input[type="checkbox"] { width: auto; height: auto; }
        hr.separator { border: none; border-top: 1px solid var(--border-color); margin: 20px 0; }
        .tabs { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 15px; }
        .tab-btn { padding: 8px 12px; cursor: pointer; border: none; background: none; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid transparent; }
        .tab-btn.active { color: var(--text-primary); border-bottom-color: var(--color-primary); }
        .tab-content { display: none; } .tab-content.active { display: block; }
        .gradient-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .gradient-angle-control { grid-column: 1 / -1; }
        .preview-header { padding: 30px 15px; text-align: center; border-radius: 16px; transition: all var(--transition-speed) ease; overflow-wrap: break-word; }
        #preview-avatar { width: 90px; height: 90px; border: 4px solid var(--bg-preview-page); box-shadow: 0 4px 12px var(--shadow-light); object-fit: cover; background-color: #fff; transition: all var(--transition-speed) ease; cursor: pointer; }
        #preview-nickname { margin: 12px 0 5px; font-size: 1.6rem; font-weight: 700; color: var(--text-primary); transition: color var(--transition-speed) ease; }
        #preview-subtitle { margin: 0 0 8px; font-size: 1rem; font-weight: 400; color: var(--text-primary); opacity: 0.7; transition: color var(--transition-speed) ease, margin var(--transition-speed) ease; }
        #preview-bio { margin: 0; font-size: 0.9rem; line-height: 1.4; color: var(--text-primary); opacity: 0.8; transition: color var(--transition-speed) ease; white-space: pre-wrap; }
        #preview-subtitle:empty, #preview-bio:empty { display: none; }
        .tags-container { margin-top: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
        .tag-pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 12px; font-size: 0.8rem; font-weight: 600; border-radius: 16px; transition: all var(--transition-speed) ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: grab; }
        .editor-block { background: var(--bg-editor); border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px var(--shadow-light); transition: all var(--transition-speed) ease; opacity: 1; transform: scale(1); }
        .sortable-ghost { background: var(--bg-image-upload-hover) !important; border: 2px dashed var(--color-primary); box-shadow: none !important; opacity: 0.8 !important; }
        .editor-block.sortable-chosen { box-shadow: 0 4px 12px var(--shadow-medium); transform: scale(1.02); }
        .editor-block-header { display: flex; align-items: center; padding: 0 10px; background: var(--bg-section); border-bottom: 1px solid var(--border-color); border-radius: 8px 8px 0 0; }
        .block-drag-handle { font-size: 1.5rem; color: var(--text-placeholder); padding: 10px; cursor: grab; flex-shrink: 0; }
        .block-drag-handle:active { cursor: grabbing; }
        .editor-block-title-input { font-weight: 600; color: var(--text-primary); margin: 0; flex-grow: 1; padding: 10px; border: 1px solid transparent; background: transparent; font-size: 1em; min-width: 0; overflow-wrap: break-word; border-radius: 4px; }
        .editor-block-title-input:hover { border-color: var(--border-input); }
        .editor-block-title-input:focus { outline: 1px solid var(--color-primary); background: var(--bg-input); border-color: var(--color-primary); }
        .block-actions { display: flex; align-items: center; gap: 5px; margin-left: auto; flex-shrink: 0; }
        .up-down-btns { display: flex; gap: 2px; }
        .up-down-btns button { font-size: 1rem; width: 28px; height: 28px; padding: 0; line-height: 28px; }
        .block-settings { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding-left: 10px; flex-shrink: 0; }
        .block-delete-btn { width: auto; padding: 6px 10px; font-size: 0.9rem; flex-shrink: 0; }
        .editor-block-content { padding: 15px; overflow-x: hidden; }
        .card-editors-list .empty-placeholder, .image-card-editors-list .empty-placeholder { text-align: center; padding: 15px; color: var(--text-placeholder); font-size: 0.9rem; }
        .editor-card { background: var(--bg-section); border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 15px; position: relative; padding-left: 40px; opacity: 1; transform: scale(1); }
        .editor-card.sortable-chosen { box-shadow: 0 3px 8px var(--shadow-medium); transform: scale(1.01); }
        .editor-card.is-active { border-color: var(--color-primary); background-color: var(--bg-image-upload-hover); }
        .card-drag-handle { position: absolute; top: 0; left: 0; bottom: 0; width: 40px; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; color: var(--text-placeholder); cursor: grab; border-right: 1px solid var(--border-color); }
        .card-drag-handle:active { cursor: grabbing; }
        .editor-card-header { display: flex; justify-content: flex-end; padding: 8px 10px; border-bottom: 1px solid var(--border-color); }
        .card-delete-btn { width: auto; padding: 4px 8px; font-size: 0.8rem; }
        .editor-card-content { padding: 15px; }
        .card-bg-control { display: flex; align-items: center; gap: 10px; }
        .card-bg-control input[type="file"] { flex-grow: 1; }
        .card-overlay-controls { border: 1px solid var(--border-input); border-radius: 6px; padding: 10px; margin-top: 10px; background: var(--bg-input); }
        .card-style-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
        .image-card-editor-content { display: flex; gap: 15px; align-items: flex-start; }
        .image-card-editor-thumb { flex-shrink: 0; width: 80px; }
        .image-card-editor-fields { flex-grow: 1; }
        .thumbnail-wrapper { position: relative; width: 100%; padding-top: 100%; background: var(--bg-image-thumb); border-radius: 6px; overflow: hidden; transition: all var(--transition-short) ease; }
        .thumbnail-wrapper img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transition: transform var(--transition-short) ease; }
        .thumbnail-wrapper:hover { transform: scale(1.05); }
        .thumbnail-wrapper:hover img { transform: scale(1.05); }
        .thumbnail-actions { position: absolute; top: 3px; right: 3px; display: flex; gap: 4px; opacity: 0; transition: opacity var(--transition-short) ease; }
        .thumbnail-wrapper:hover .thumbnail-actions { opacity: 1; }
        .thumbnail-actions .btn { width: 24px; height: 24px; padding: 0; font-size: 0.8rem; line-height: 24px; border-radius: 50%; background: rgba(0,0,0,0.6); color: white; border: none; }
        .thumbnail-actions .btn:hover { background: rgba(0,0,0,0.8); }
        .preview-blocks-container { margin-top: 20px; display: flex; flex-direction: column; gap: 20px; width: 100%; box-sizing: border-box; }
        .preview-blocks-container.locked-mode * { cursor: default !important; pointer-events: none !important; }
        #preview-blocks-container .empty-placeholder { text-align: center; padding: 50px 0; color: var(--text-placeholder); }
        .preview-block-wrapper.sortable-drag { opacity: 1 !important; }
        .preview-block-wrapper { cursor: pointer; }
        .preview-cards-container { width: 100%; }
        .preview-cards-single { display: flex; flex-direction: column; gap: 15px; }
        .preview-cards-dual { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .preview-cards-triple { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .masonry-active { display: block; position: relative; } /* Override grid */
        .masonry-active.preview-cards-dual .preview-card, .masonry-active.preview-cards-dual figure { width: calc(50% - 7.5px); margin-bottom: 15px; }
        .masonry-active.preview-cards-triple .preview-card, .masonry-active.preview-cards-triple figure { width: calc(33.333% - 10px); margin-bottom: 15px; }
        .preview-card { box-sizing: border-box; width: 100%; view-transition-name: var(--card-transition-name); }
        .preview-card-inner { width: 100%; height: 100%; box-sizing: border-box; position: relative; overflow: hidden; color: var(--card-text-color, var(--g-card-text-color)); border-radius: var(--g-card-border-radius); box-shadow: var(--active-card-shadow, none); border: var(--active-card-border, none); font-weight: var(--card-font-weight, normal); text-shadow: var(--active-card-text-shadow, none); padding: 15px; word-wrap: break-word; transition: all var(--transition-short) ease; -webkit-text-stroke: var(--g-card-text-stroke); line-height: var(--g-card-line-height); }
        .preview-card-inner::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 0; background-size: cover; background-position: center; border-radius: inherit; background: var(--card-bg-final); transition: background var(--transition-speed) ease; }
        .preview-card-inner::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--card-overlay-color, transparent); opacity: var(--card-overlay-opacity, 0); border-radius: inherit; z-index: 1; pointer-events: none; transition: all var(--transition-short) ease; }
        .preview-card:hover .preview-card-inner { transform: scale(1.02); box-shadow: 0 6px 16px var(--shadow-medium); }
        .preview-card.adding, figure.adding { animation: fadeInScale 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .preview-card.removing, figure.removing { animation: fadeOutScale 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .preview-card-title, .preview-card-content { position: relative; z-index: 2; margin: 0; word-wrap: break-word; overflow-wrap: break-word; color: inherit; }
        .preview-card-title { font-size: 1.1em; font-weight: inherit; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        .preview-card-title .iconify, .tag-pill .iconify { font-size: 1.1em; line-height: 1; vertical-align: middle; }
        .preview-card-content { font-size: 0.95em; line-height: inherit; white-space: pre-wrap; }
        /* For rich text */
        .preview-card-content strong, .preview-card-content b { font-weight: bold; }
        .preview-card-content em, .preview-card-content i { font-style: italic; }
        .preview-cards-container figure { margin: 0; display: flex; flex-direction: column; transition: transform 0.3s ease; }
        .preview-cards-container figure img { width: 100%; display: block; border-radius: 8px; height: auto; max-width: 100%; transition: transform 0.3s ease; }
        .preview-cards-container figure:hover img { transform: scale(1.05); }
        .preview-cards-container figure figcaption { text-align: center; margin-top: 8px; padding: 5px; overflow-wrap: break-word; color: var(--g-card-text-color); border-radius: 8px; }
        .preview-cards-container figure figcaption strong { display: block; font-weight: 600; margin-bottom: 3px; }
        .separator-preview { display: flex; align-items: center; justify-content: center; }
        .separator-preview-line { flex-grow: 1; height: 1px; }
        .spacer-preview { transition: height 0.3s ease; }
        .font-controls { display: flex; flex-direction: column; gap: 8px; margin-top: 8px; align-items: stretch; }
        .font-controls select { width: 100%; }
        .font-controls .buttons { display: flex; gap: 10px; }
        .font-controls .buttons .btn { flex-grow: 1; padding: 8px 12px; font-size: 13px; width: auto; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-modal-overlay); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility 0s var(--transition-speed) ease; backdrop-filter: blur(5px); pointer-events: none; }
        .modal-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; pointer-events: auto; }
        .modal-container { background: var(--bg-editor); border-radius: 16px; box-shadow: 0 10px 30px var(--shadow-medium); padding: 25px; width: 90%; max-width: 500px; border: 1px solid var(--border-color); transform: scale(0.95); opacity: 0; transition: all var(--transition-speed) ease; }
        .modal-overlay.visible .modal-container { transform: scale(1); opacity: 1; }
        .modal-container h3 { margin-top: 0; margin-bottom: 20px; font-size: 1.25rem; color: var(--text-primary); }
        .cropper-img-container { width: 100%; height: 300px; margin-bottom: 20px; background: var(--bg-input); border-radius: 8px; overflow: hidden; }
        .cropper-img-container img { max-width: 100%; }
        .modal-actions { display: flex; gap: 15px; justify-content: flex-end; margin-top: 15px; }
        .modal-actions .btn { width: auto; min-width: 100px; }
        #download-modal-content { text-align: center; }
        #download-modal-content img { max-width: 100%; max-height: 50vh; border-radius: 8px; border: 1px solid var(--border-color); margin-bottom: 15px; }
        #download-modal-content a { display: block; background: var(--color-primary); color: white; text-decoration: none; padding: 12px 20px; border-radius: 8px; font-size: 1rem; font-weight: 600; margin-bottom: 20px; transition: background-color var(--transition-short) ease; }
        #download-modal-content a:hover { background-color: var(--color-primary-hover); }
        .crop-ratios { margin-bottom: 15px; }
        .crop-ratios label { margin-right: 10px; font-size: 0.9rem; cursor: pointer; }
        .error-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--bg-editor); color: var(--text-primary); padding: 25px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.3); z-index: 2000; max-width: 90%; width: 450px; border: 1px solid var(--border-color); }
        .error-modal h3 { color: var(--color-danger); margin-top: 0; }
        .error-modal p { margin: 10px 0; font-size: 0.95rem; }
        .error-modal .btn { margin-top: 15px; float: right; }
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; font-size: 1.2rem; backdrop-filter: blur(5px); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s 0.3s; pointer-events: none; }
        #loading-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; pointer-events: auto; }
        .spinner { width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--color-primary); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        .toast-notification-container { position: fixed; bottom: 20px; right: 20px; z-index: 9999; display: flex; flex-direction: column; gap: 10px; }
        .toast-notification { background-color: var(--bg-card); color: var(--text-primary); padding: 12px 18px; border-radius: 8px; box-shadow: 0 4px 12px var(--shadow-medium); border: 1px solid var(--border-color); opacity: 0; transform: translateX(100%); animation: toast-in 0.5s forwards, toast-out 0.5s 4.5s forwards; font-size: 0.9rem; }
        .toast-notification.success { border-left: 4px solid #2ecc71; }
        .toast-notification.error { border-left: 4px solid var(--color-danger); }
        .toast-notification.info { border-left: 4px solid var(--color-primary); }
        #icon-picker-modal .modal-container, #texture-picker-modal .modal-container, #font-manager-modal .modal-container { max-width: 700px; }
        #icon-grid, #texture-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 10px; max-height: 50vh; overflow-y: auto; padding: 10px; border: 1px solid var(--border-input); border-radius: 8px; background: var(--bg-input); }
        #texture-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
        .icon-grid-item { display: flex; align-items: center; justify-content: center; height: 50px; font-size: 1.5rem; color: var(--text-primary); border-radius: 6px; cursor: pointer; transition: background-color var(--transition-short); position: relative; }
        .icon-grid-item:hover, .texture-grid-item:hover { background-color: var(--border-color); }
        .icon-grid-item .delete-custom-icon-btn { position: absolute; top: 2px; right: 2px; width: 18px; height: 18px; padding: 0; font-size: 0.7rem; line-height: 18px; border-radius: 50%; display: none; }
        .icon-grid-item:hover .delete-custom-icon-btn { display: flex; }
        .texture-grid-item { display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 6px; cursor: pointer; transition: background-color var(--transition-short); padding: 5px; }
        .texture-preview { width: 100%; height: 80px; border: 1px solid var(--border-color); border-radius: 4px; background-size: 20px; }
        .texture-name { font-size: 0.75rem; margin-top: 5px; color: var(--text-secondary); text-align: center; }
        #tag-manager-list, #font-manager-list { display: flex; flex-direction: column; gap: 10px; max-height: 250px; overflow-y: auto; padding: 10px; border: 1px solid var(--border-input); border-radius: 6px; background-color: var(--bg-input); margin-bottom: 15px; }
        .tag-manager-item, .font-manager-item { display: flex; align-items: center; gap: 8px; background-color: var(--bg-section); padding: 8px; border-radius: 4px; border: 1px solid var(--border-color); }
        .tag-manager-item .tag-drag-handle { cursor: grab; color: var(--text-placeholder); font-size: 1.5rem; padding: 0 8px; }
        .tag-manager-item .tag-icon-btn { flex-shrink: 0; width: 32px; height: 32px; padding: 0; font-size: 1.2rem; cursor: pointer; }
        .tag-manager-item .tag-text-input { flex-grow: 1; border: none; background: transparent; padding: 4px 6px; cursor: text; }
        .tag-manager-item .tag-delete-btn, .font-manager-item .font-delete-btn { flex-shrink: 0; width: 32px; height: 32px; padding: 0; cursor: pointer; }
        .font-manager-item-name { flex-grow: 1; }
        .empty-tag-list, .empty-font-list { text-align: center; color: var(--text-placeholder); padding: 20px 0; }
        .inset-controls { border: 1px solid var(--border-input); border-radius: 6px; padding: 15px; margin-top: 10px; background: var(--bg-input); }
        #help-modal .tab-content { max-height: 60vh; overflow-y: auto; padding: 15px; }
        #help-thanks .thanks-item { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        #help-thanks .thanks-item:last-child { border-bottom: none; }
        #help-thanks h4 { margin-top: 0; margin-bottom: 8px; }
        #help-thanks p { margin: 4px 0; }
        #help-thanks details { margin-top: 10px; }
        #help-thanks summary { cursor: pointer; font-weight: 600; color: var(--text-action); }
        #help-thanks pre { white-space: pre-wrap; word-wrap: break-word; background: var(--bg-input); padding: 10px; border-radius: 6px; font-size: 0.8rem; max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); }
        
        .palette-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(40px, 1fr)); gap: 10px; margin-top: 10px; }
        .palette-color { width: 100%; padding-top: 100%; border-radius: 8px; cursor: pointer; border: 2px solid var(--border-color); transition: transform var(--transition-short); position: relative; }
        .palette-color:hover { transform: scale(1.1); }
        .color-tooltip { position: absolute; bottom: 110%; left: 50%; transform: translateX(-50%); background: var(--bg-card); color: var(--text-primary); padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; white-space: nowrap; box-shadow: var(--shadow-medium); opacity: 0; visibility: hidden; transition: opacity var(--transition-short); }
        .palette-color:hover .color-tooltip { opacity: 1; visibility: visible; }
        #color-context-menu { position: fixed; z-index: 10000; background: var(--bg-editor); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: var(--shadow-medium); padding: 5px; display: none; min-width: 180px;}
        #color-context-menu ul { list-style: none; margin: 0; padding: 0; }
        #color-context-menu li { padding: 8px 12px; cursor: pointer; border-radius: 4px; font-size: 0.9rem; }
        #color-context-menu li:hover { background: var(--bg-input); }
        #color-context-menu hr { border: none; border-top: 1px solid var(--border-color); margin: 4px 0; }
        
        /* --- Contextual Tooltips --- */
        .tooltip-trigger {
            display: inline-block;
            margin-left: 8px;
            color: var(--text-secondary);
            cursor: help;
            position: relative;
        }

        /* --- Floating Tooltip --- */
        #floating-tooltip {
            position: fixed; /* ä½¿ç”¨ fixed å®šä½ï¼Œè„±ç¦»æ‰€æœ‰å®¹å™¨é™åˆ¶ */
            background-color: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.85rem;
            font-weight: normal;
            white-space: nowrap;
            z-index: 10001; /* ç¡®ä¿åœ¨æœ€é¡¶å±‚ */
            pointer-events: none; /* é˜²æ­¢ tooltip æœ¬èº«å¹²æ‰°é¼ æ ‡äº‹ä»¶ */
            opacity: 0;
            transition: opacity 0.2s ease;
            transform: translate(-50%, -100%); /* é»˜è®¤å®šä½åœ¨å…ƒç´ ä¸Šæ–¹ä¸­é—´ */
        }
        
        /* --- Rich Text Editor Trigger in Inspector --- */
        .rich-text-editor-trigger {
            position: relative;
            border: 1px solid var(--border-input);
            border-radius: 6px;
            background-color: var(--bg-input);
            min-height: 80px;
            padding: 10px;
            transition: all var(--transition-short);
        }
        .rich-text-editor-trigger:hover {
            border-color: var(--color-primary);
        }
        .rich-text-preview {
            font-size: 0.9em;
            color: var(--text-secondary);
            overflow: hidden;
            max-height: 120px;
            word-break: break-all;
        }
        .rich-text-preview > * {
            margin: 0 !important;
            padding: 0 !important;
        }
        .edit-content-btn {
            padding: 4px 10px; /* è°ƒæ•´ä¸€ä¸‹å†…è¾¹è·è®©å®ƒå°å·§ä¸€äº› */
            font-size: 0.85rem;
        }
        
        /* --- FEATURE: Rich Text Editor --- */
        #rich-text-editor-modal .modal-container { max-width: 800px; }
        #rich-text-editor-container { height: 35vh; margin-bottom: 15px; background-color: var(--bg-preview-page); }
        #rich-text-editor-container .ql-editor { color: var(--text-primary); }
        #rich-text-editor-container .ql-toolbar { border-color: var(--border-color); }
        #rich-text-editor-container .ql-toolbar .ql-picker-label,
        #rich-text-editor-container .ql-toolbar .ql-stroke {
             color: var(--text-secondary) !important;
             stroke: var(--text-secondary) !important;
        }
        html.dark-mode #rich-text-editor-container .ql-picker-options { background-color: var(--bg-card); border-color: var(--border-color); }
        /* --- END FEATURE --- */
        
        @keyframes toast-in { to { opacity: 1; transform: translateX(0); } }
        @keyframes toast-out { to { opacity: 0; transform: translateX(100%); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInScale { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        @keyframes fadeOutScale { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.9); } }
        .preview-header { animation: fadeIn 0.4s ease forwards; }
        
        #mobile-layer-toggle, #mobile-inspector-toggle { display: none; }
        .mobile-edit-pencil { display: none; }

        @media (max-width: 1024px) {
            .app-header-title { display: none; } 
            #mobile-layer-toggle, #mobile-inspector-toggle { display: block; z-index: 201; }
            .resizer { display: none; }
            .layer-panel, .inspector-panel {
                position: fixed; top: var(--header-height);
                width: 85%; max-width: 350px;
                height: calc(100vh - var(--header-height)); z-index: 200;
                transition: transform 0.3s ease-in-out, top 0.3s ease;
                overflow-x: hidden;
            }
            .layer-panel { left: 0; transform: translateX(-100%); border-right: 1px solid var(--border-color); }
            .inspector-panel { right: 0; transform: translateX(100%); border-left: 1px solid var(--border-color); }
            .layer-panel.is-open, .inspector-panel.is-open { transform: translateX(0); }

            .preview-panel { width: 100%; padding: 20px 10px; }
            body.panels-open::after {
                content: ''; position: fixed; top: var(--header-height); left: 0; width: 100%;
                height: calc(100vh - var(--header-height)); background: rgba(0,0,0,0.4); z-index: 199;
                opacity: 1; pointer-events: auto; transition: opacity 0.3s ease-in-out;
            }
            body.storage-warning.panels-open::after {
                top: calc(var(--header-height) + 35px);
                height: calc(100vh - var(--header-height) - 35px);
            }
            .color-control-row, .gradient-controls { flex-direction: column; gap: 10px; }
            .gradient-controls { grid-template-columns: 1fr; }
            .color-control-group { width: 100%; min-width: 0; }
            .btn-stepper { display: inline-flex; align-items: center; justify-content: center; }

            /* --- NEW: Mobile Edit Pencil --- */
            .mobile-edit-pencil {
                display: flex;
                align-items: center;
                justify-content: center;
                position: absolute;
                top: -5px;
                right: -5px;
                width: 28px;
                height: 28px;
                background-color: var(--color-primary);
                color: white;
                border-radius: 50%;
                border: 2px solid var(--bg-preview-page);
                box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                z-index: 10;
                cursor: pointer;
                opacity: 0.8;
                transition: all var(--transition-short);
                font-size: 1rem;
            }
            .mobile-edit-pencil:hover {
                transform: scale(1.1);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="storage-warning-banner">
        è­¦å‘Šï¼šæµè§ˆå™¨å­˜å‚¨ç©ºé—´å·²æ»¡ï¼Œè‡ªåŠ¨ä¿å­˜åŠŸèƒ½å·²æš‚åœã€‚è¯·<a id="storage-warning-export-link">å¯¼å‡ºé…ç½®</a>ä»¥å¤‡ä»½æ‚¨çš„å·¥ä½œï¼Œå¹¶å°è¯•åˆ é™¤ä¸€äº›å·²ç»ä¸Šä¼ çš„å›¾ç‰‡æ¥æ¢å¤åŠŸèƒ½ã€‚
    </div>

    <header class="app-header">
        <button id="mobile-layer-toggle" class="btn btn-default btn-icon" style="width: auto; padding: 6px 12px;"><span class="iconify" data-icon="mdi:layers-outline"></span> å†…å®¹</button>
        <div class="app-header-title">Blokko (v1.6.0)</div>
        <div class="header-actions-wrapper">
            <button id="lock-mode-toggle" class="btn btn-default" style="width: auto; padding: 6px 12px;" title="åˆ‡æ¢ç¼–è¾‘/é¢„è§ˆæ¨¡å¼">ç¼–è¾‘ä¸­</button>
            <button id="show-help-btn" class="btn btn-default btn-icon" style="width: auto; padding: 6px 12px;"><span class="iconify" data-icon="mdi:help-circle-outline"></span> å¸®åŠ©</button>
            <div class="theme-switch-wrapper">
                <button id="theme-toggle-btn" class="btn btn-default" style="width: auto; padding: 6px 12px;">æ˜äº®æ¨¡å¼</button>
            </div>
            <button id="mobile-inspector-toggle" class="btn btn-default btn-icon" style="width: auto; padding: 6px 12px;"><span class="iconify" data-icon="mdi:pencil-ruler"></span> æ ·å¼</button>
        </div>
    </header>

    <div class="app-container">
        <aside class="layer-panel" id="layer-panel">
            <h3 class="panel-header">å†…å®¹å›¾å±‚</h3>
            <div class="layer-list" id="layer-list">
                <!-- Layer items will be dynamically inserted here -->
            </div>
            <hr>
            <div class="form-group" style="display: flex; flex-wrap: wrap; gap: 10px;">
                <button id="add-text-block-btn" class="btn btn-default">â• æ–‡æœ¬</button>
                <button id="add-image-block-btn" class="btn btn-default">ğŸ–¼ï¸ å›¾ç‰‡</button>
                <button id="add-separator-block-btn" class="btn btn-default">ã€°ï¸ åˆ†éš”</button>
                <button id="add-spacer-block-btn" class="btn btn-default">âµ ç•™ç™½</button>
            </div>
        </aside>

        <main class="preview-panel" id="preview-panel">
            <div class="preview-wrapper" id="preview-wrapper">
                <div class="preview-overlay" id="preview-overlay"></div>
                <header class="preview-header" id="preview-header">
                    <img id="preview-avatar" src="" alt="Avatar" title="ç‚¹å‡»æ›´æ¢å¤´åƒ">
                    <h1 id="preview-nickname" data-state-key="personalInfo.nickname"></h1>
                    <h2 id="preview-subtitle" data-state-key="personalInfo.subtitle"></h2>
                    <p id="preview-bio" data-state-key="personalInfo.bio"></p>
                    <div class="tags-container" id="preview-tags-container"></div>
                </header>
                <main class="preview-blocks-container" id="preview-blocks-container"></main>
            </div>
        </main>
        
        <div class="resizer" id="resizer"></div>

        <aside class="inspector-panel" id="inspector-panel">
            <!-- Inspector content will be dynamically inserted here -->
        </aside>
    </div>

    <div class="modal-overlay" id="cropper-modal"><div class="modal-container"><h3 id="cropper-title">è£å‰ªå›¾ç‰‡</h3><div class="crop-ratios radio-group"><label><input type="radio" name="crop-ratio" value="NaN" checked> è‡ªç”±</label><label><input type="radio" name="crop-ratio" value="1"> 1:1</label><label><input type="radio" name="crop-ratio" value="1.3333"> 4:3</label><label><input type="radio" name="crop-ratio" value="1.7777"> 16:9</label></div><div class="cropper-img-container"><img id="cropper-image" src=""></div><div class="modal-actions"><button id="cropper-cancel-btn" class="btn btn-default">å–æ¶ˆ</button><button id="cropper-save-btn" class="btn btn-primary">ç¡®è®¤</button></div></div></div>
    <div class="modal-overlay" id="download-modal"><div class="modal-container"><h3 id="download-modal-title">ä¸‹è½½å·²å‡†å¤‡å¥½</h3><div id="download-modal-content"></div><div class="modal-actions" style="justify-content: center;"><button id="download-modal-close-btn" class="btn btn-default">å…³é—­</button></div></div></div>
    
    <div class="modal-overlay" id="confirm-modal">
        <div class="modal-container">
            <h3 id="confirm-modal-title">è¯·ç¡®è®¤</h3>
            <p id="confirm-modal-message" style="margin: 15px 0;"></p>
            <div class="modal-actions">
                <button id="confirm-modal-cancel-btn" class="btn btn-default">å–æ¶ˆ</button>
                <button id="confirm-modal-ok-btn" class="btn btn-primary">ç¡®è®¤</button>
            </div>
        </div>
    </div>
    
    <!-- FEATURE: Rich Text Editor Modal -->
    <div class="modal-overlay" id="rich-text-editor-modal">
        <div class="modal-container">
            <h3>ç¼–è¾‘å¡ç‰‡å†…å®¹</h3>
            <div id="rich-text-editor-container"></div>
            <div class="modal-actions">
                <button id="rich-text-cancel-btn" class="btn btn-default">å–æ¶ˆ</button>
                <button id="rich-text-save-btn" class="btn btn-primary">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="help-modal">
        <div class="modal-container" style="max-width: 700px;">
            <div class="tabs">
                <button class="tab-btn active" data-tab="help-tutorial">æ–°æ‰‹æ•™ç¨‹</button>
                <button class="tab-btn" data-tab="help-instructions">ä½¿ç”¨è¯´æ˜</button>
                <button class="tab-btn" data-tab="help-thanks">æ„Ÿè°¢ä¿¡æ¯</button>
                <button class="tab-btn" data-tab="help-changelog">æ›´æ–°æ—¥å¿—</button>
                <button class="tab-btn" data-tab="help-about">å…³äº</button>
            </div>
            <div id="help-tutorial" class="tab-content active">
                <h4>æ¬¢è¿æ¥åˆ° Blokkoï¼âœ¨</h4>
                <p>åˆ«æ‹…å¿ƒï¼Œè¿™ä¸ªå°æ•™ç¨‹å°†å¸¦ä½ å¿«é€Ÿä¸Šæ‰‹ï¼Œæ•´ä¸ªè¿‡ç¨‹åªéœ€ä¸€åˆ†é’Ÿï¼å¦‚æœä½ æœ‰ç±»ä¼¼å·¥å…·çš„ä½¿ç”¨ç»éªŒï¼Œæˆ–æ˜¯å·²ç»éå¸¸ç†Ÿæ‚‰ï¼Œçœ‹å®Œä¸‹æ–¹çš„â€œé‡è¦æç¤ºâ€å°±å¯ä»¥æ”¾å¿ƒå…³é—­å•¦ï¼</p>
                
                <h4>âš ï¸ å…³äºç‰ˆæƒçš„é‡è¦æç¤º</h4>
                <p><strong>Blokko æ˜¯ä¸€ä¸ªå®Œå…¨å…è´¹çš„æœ¬åœ°åˆ›ä½œå·¥å…·ã€‚</strong>å½“æ‚¨ä½¿ç”¨â€œä¸Šä¼ å­—ä½“â€ã€â€œä¸Šä¼ å›¾ç‰‡/å›¾æ ‡â€åŠŸèƒ½æ—¶ï¼Œæ‚¨éœ€è¦å¯¹è¿™äº›ç´ æè´Ÿè´£ã€‚è¯·ç¡®ä¿æ‚¨ä¸Šä¼ å’Œä½¿ç”¨çš„ä»»ä½•æ–‡ä»¶éƒ½å·²è·å¾—äº†åŸç‰ˆæƒæ–¹çš„åˆæ³•æˆæƒï¼Œæˆ–ä½¿ç”¨æ— ç‰ˆæƒå¯å•†ç”¨ç´ æã€‚</p>
                <p>å› ä½¿ç”¨æœªæˆæƒç´ æè€Œäº§ç”Ÿçš„ä»»ä½•ç‰ˆæƒé—®é¢˜ï¼Œå°†ç”±æ‚¨è‡ªè¡Œæ‰¿æ‹…ã€‚æ¢è¨€ä¹‹ï¼Œè‡ªå·±ä¸Šä¼ çš„ç´ æï¼Œä¸€å®šè¦æ³¨æ„ç‰ˆæƒä¿¡æ¯å“¦ï¼</p>
                
                <h4>å†™åœ¨æ­£å¼å¼€å§‹å‰</h4>
                <p>Blokko æ˜¯ä¸€ä¸ªå…è´¹çš„ã€ä¸ºç”µè„‘ç«¯ç¼–è¾‘è€Œè®¾è®¡çš„å·¥å…·ã€‚ä¸ºäº†æœ€ä½³ä½“éªŒï¼Œå»ºè®®ä½¿ç”¨PCç«¯çš„ Edge æˆ– Chrome æµè§ˆå™¨ã€‚ç§»åŠ¨ç«¯ä¹Ÿåšäº†åŸºç¡€é€‚é…ï¼Œç«–å±çŠ¶æ€ä¸‹å»ºè®®ä½¿ç”¨ Via æµè§ˆå™¨å¹¶å¼€å¯å…¨å±æ¨¡å¼ã€‚åœ¨ç«–å±ä¸‹ï¼Œâ€œå†…å®¹â€å’Œâ€œæ ·å¼â€é¢æ¿ä¼šè¢«æŠ˜å ï¼Œéœ€è¦æ‰‹åŠ¨ç‚¹å‡»å·¦ä¸Šè§’å’Œå³ä¸Šè§’çš„æŒ‰é’®æ¥å”¤å‡ºã€‚ï¼ˆå› ç²¾åŠ›æœ‰é™ï¼Œç›®å‰ç§»åŠ¨ç«¯åªèƒ½åšåˆ°â€œåŸºç¡€é€‚é…â€ï¼Œå¯èƒ½ä¼šå­˜åœ¨å¥‡æ€ªBUGï¼Œæ¯”å¦‚ä¸Šä¼ å›¾ç‰‡é»‘å±ç­‰ï¼Œå¯ä»¥åé¦ˆç»™ä½œè€…ä½†æ˜¯å¤§æ¦‚ç‡è¦å¾ˆä¹…æ‰ä¿®ï¼Œä»ç„¶å»ºè®®ä½¿ç”¨PCç«¯è¿›è¡Œç¼–è¾‘ã€‚ï¼‰</p>
                <p>Blokko é‡‡ç”¨ä¸‰æ å¼å¸ƒå±€ï¼š<b>å·¦ä¾§â€œå†…å®¹å›¾å±‚â€</b>ç®¡ç†æ‰€æœ‰åŒºå—ï¼Œ<b>ä¸­é—´æ˜¯â€œå®æ—¶é¢„è§ˆâ€</b>ï¼Œ<b>å³ä¾§æ˜¯â€œæ ·å¼æ£€æŸ¥å™¨â€</b>ã€‚åœ¨å·¦ä¾§ç‚¹å‡»ä»»æ„å›¾å±‚ï¼Œå³ä¾§å°±ä¼šè‡ªåŠ¨æ˜¾ç¤ºå…¶ç›¸å…³è®¾ç½®ã€‚é»˜è®¤çŠ¶æ€ä¸‹ï¼ˆæœªé€‰ä¸­ä»»ä½•å›¾å±‚ï¼‰ä¼šæ˜¾ç¤ºå…¨å±€è®¾ç½®ã€‚å¡ç‰‡çš„ç‹¬ç«‹æ ·å¼ä¼˜å…ˆçº§é«˜äºå…¨å±€æ ·å¼å“¦ï¼</p>
                
                <h4>ç¬¬ä¸€æ­¥ï¼šæ ¸å¿ƒæŠ€å·§ - åŒå‡»ç¼–è¾‘ï¼</h4>
                <p>Blokko æœ€ä¾¿æ·çš„æ“ä½œå°±æ˜¯â€œåŒå‡»â€ã€‚åœ¨é¢„è§ˆåŒºåŸŸï¼Œä½ çœ‹åˆ°çš„æ‰€æœ‰æ–‡å­—ï¼ˆæ¯”å¦‚æ˜µç§°ã€ç®€ä»‹ã€å¡ç‰‡æ ‡é¢˜å’Œå†…å®¹ï¼‰ï¼Œç›´æ¥åŒå‡»å®ƒä»¬å°±å¯ä»¥ç«‹åˆ»å¼€å§‹ç¼–è¾‘ï¼Œéå¸¸æ–¹ä¾¿ï¼åœ¨æ‰‹æœºä¸Šï¼Œä½ ä¹Ÿå¯ä»¥ç‚¹å‡»æ–‡å­—å³ä¸Šè§’å‡ºç°çš„é“…ç¬”å›¾æ ‡ âœï¸ æ¥ç¼–è¾‘ã€‚ï¼ˆè¯·ç¡®ä¿é¡µé¢é¡¶éƒ¨çš„æŒ‰é’®å¤„äºâ€œç¼–è¾‘ä¸­â€çŠ¶æ€ï¼‰</p>
                
                <h4>ç¬¬äºŒæ­¥ï¼šè°ƒæ•´ä½ çš„ä¸ªäººä¿¡æ¯</h4>
                <p>åœ¨å·¦ä¾§çš„â€œå†…å®¹å›¾å±‚â€é¢æ¿ï¼Œç‚¹å‡» â€œğŸ‘¤ ä¸ªäººä¿¡æ¯â€ å›¾å±‚ï¼Œå³ä¾§çš„â€œæ ·å¼â€é¢æ¿å°±ä¼šæ˜¾ç¤ºå‡ºæ‰€æœ‰ç›¸å…³è®¾ç½®ã€‚ä½ å¯ä»¥åœ¨é‚£é‡Œä¸Šä¼ å¤´åƒï¼ˆä¹Ÿå¯ä»¥ç›´æ¥ç‚¹å‡»é¢„è§ˆåŒºçš„å¤´åƒï¼‰ã€ä¿®æ”¹æ˜µç§°ã€æ·»åŠ æ ‡ç­¾ç­‰ã€‚</p>
                
                <h4>ç¬¬ä¸‰æ­¥ï¼šæ·»åŠ å’Œç®¡ç†å†…å®¹</h4>
                <p>ç‚¹å‡»å·¦ä¸‹è§’çš„â€œâ•â€ç³»åˆ—æŒ‰é’®å¯ä»¥æ·»åŠ ä¸åŒç±»å‹çš„å±•ç¤ºæ¨¡å—ã€‚åœ¨â€œå†…å®¹å›¾å±‚â€é¢æ¿ï¼Œä½ å¯ä»¥é€šè¿‡æ‹–æ‹½æ¥æ’åºæ‰€æœ‰åŒºå—ã€‚</p>
                
                <h4>ç¬¬å››æ­¥ï¼šç¾åŒ–ä¸å¯¼å‡º</h4>
                <p>å½“ä½ å¯¹å†…å®¹æ»¡æ„åï¼Œå¯ä»¥ç‚¹å‡»ä¸åŒçš„å›¾å±‚æ¥è°ƒæ•´æ ·å¼ï¼Œæˆ–è€…åœ¨æœªé€‰ä¸­ä»»ä½•å›¾å±‚æ—¶ï¼Œåœ¨å³ä¾§é¢æ¿è°ƒæ•´å…¨å±€æ ·å¼ã€‚å…¨éƒ¨å®Œæˆåï¼Œåœ¨å³ä¾§é¢æ¿çš„â€œå…¨å±€ä¸å¯¼å‡ºâ€è®¾ç½®ä¸­ï¼Œæ»‘åˆ°æœ€ä¸‹æ–¹ï¼Œç‚¹å‡»â€œå¯¼å‡ºä¸ºå›¾ç‰‡â€æŒ‰é’®ï¼Œå°±å¯ä»¥ä¿å­˜ä½ çš„æ°ä½œå•¦ï¼</p>
            </div>
            <div id="help-instructions" class="tab-content">
                <h4>æ¬¢è¿ä½¿ç”¨ Blokkoï¼</h4>
                <p><strong><span class="iconify" data-icon="mdi:cursor-default-click-outline" style="vertical-align: -0.2em;"></span> åŒå‡»/ç‚¹å‡»ç¼–è¾‘ï¼š</strong> é¢„è§ˆåŒºåŸŸçš„å¤§éƒ¨åˆ†æ–‡æœ¬å†…å®¹éƒ½å¯ä»¥é€šè¿‡åŒå‡»ï¼ˆPCç«¯ï¼‰æˆ–ç‚¹å‡»å³ä¸Šè§’é“…ç¬”å›¾æ ‡ï¼ˆç§»åŠ¨ç«¯ï¼‰ç›´æ¥è¿›è¡Œç¼–è¾‘ã€‚å¡ç‰‡å†…å®¹ç°åœ¨æ”¯æŒå¼ºå¤§çš„å¯Œæ–‡æœ¬ç¼–è¾‘ï¼</p>
                <p><strong><span class="iconify" data-icon="mdi:keyboard-outline" style="vertical-align: -0.2em;"></span> å¿«æ·é”®ï¼š</strong> æ”¯æŒ `Ctrl/Cmd + Z` æ’¤é”€å’Œ `Ctrl/Cmd + Y` é‡åšã€‚é¼ æ ‡æ‚¬åœåœ¨æ’¤é”€/é‡åšæŒ‰é’®ä¸Šï¼Œå¯ä»¥çœ‹åˆ°å…·ä½“çš„æ“ä½œå†å²ã€‚åœ¨å¯Œæ–‡æœ¬ç¼–è¾‘å™¨ä¸­ï¼Œä¹Ÿæ”¯æŒ `Ctrl/Cmd + B` (åŠ ç²—) å’Œ `Ctrl/Cmd + I` (æ–œä½“) ç­‰å¸¸ç”¨å¿«æ·é”®ã€‚</p>
                <p><strong><span class="iconify" data-icon="mdi:drag" style="vertical-align: -0.2em;"></span> æ‹–æ‹½æ’åºï¼š</strong> åœ¨å·¦ä¾§â€œå†…å®¹å›¾å±‚â€é¢æ¿ï¼Œä½ å¯ä»¥æ‹–åŠ¨å›¾å±‚æ¥è¿›è¡Œæ’åºã€‚ç°åœ¨ï¼Œé¢„è§ˆåŒºçš„ä¸ªäººä¿¡æ¯æ ‡ç­¾ä¹Ÿå¯ä»¥ç›´æ¥æ‹–æ‹½æ’åºäº†ï¼</p>
                <p><strong><span class="iconify" data-icon="mdi:view-dashboard-variant-outline" style="vertical-align: -0.2em;"></span> ç€‘å¸ƒæµå¸ƒå±€ï¼š</strong> å¯¹äºå¤šåˆ—åŒºå—ï¼ˆåŒæ’/ä¸‰æ’ï¼‰ï¼Œå¯ä»¥åœ¨å³ä¾§æ£€æŸ¥å™¨ä¸­å‹¾é€‰â€œå¯ç”¨ç€‘å¸ƒæµâ€ï¼Œä½¿å¡ç‰‡/å›¾ç‰‡é«˜åº¦è‡ªé€‚åº”ï¼Œå¸ƒå±€æ›´ç´§å‡‘ã€‚</p>
                <p><strong><span class="iconify" data-icon="mdi:lock-open-variant-outline" style="vertical-align: -0.2em;"></span> é”å®šæ¨¡å¼ï¼š</strong> ç‚¹å‡»å³ä¸Šè§’çš„ "ç¼–è¾‘ä¸­" æŒ‰é’®å¯åˆ‡æ¢åˆ° "é¢„è§ˆä¸­"ï¼Œæ­¤æ¨¡å¼ä¸‹ç¦ç”¨æ‰€æœ‰ç¼–è¾‘åŠŸèƒ½ï¼Œæ–¹ä¾¿åœ¨æ‰‹æœºä¸Šé¡ºç•…æ»‘åŠ¨æµè§ˆã€‚</p>
                <p><strong><span class="iconify" data-icon="mdi:import" style="vertical-align: -0.2em;"></span> å¯¼å…¥/å¯¼å‡ºï¼š</strong> åœ¨å³ä¾§æ£€æŸ¥å™¨çš„â€œå…¨å±€ä¸å¯¼å‡ºâ€è®¾ç½®ä¸­ï¼Œå¯ä»¥å¯¼å…¥/å¯¼å‡º .json é…ç½®æ–‡ä»¶ï¼Œæ–¹ä¾¿å¤‡ä»½å’Œåˆ†äº«ã€‚</p>
                <p><strong><span class="iconify" data-icon="mdi:database" style="vertical-align: -0.2em;"></span> æµè§ˆå™¨å­˜å‚¨ï¼š</strong> æ‚¨çš„æ‰€æœ‰ä¿®æ”¹éƒ½ä¼šè‡ªåŠ¨ä¿å­˜åœ¨å½“å‰æµè§ˆå™¨ä¸­ï¼ˆéæ— ç—•æ¨¡å¼ï¼‰ï¼Œåˆ·æ–°é¡µé¢ä¸ä¼šä¸¢å¤±è¿›åº¦ã€‚å­—ä½“å’Œå›¾ç‰‡ç­‰å¤§æ–‡ä»¶å°†ä½¿ç”¨IndexedDBå­˜å‚¨ï¼Œå®¹é‡æ›´å¤§æ›´å¯é ã€‚</p>
                
                <hr class="separator">
                <h4>ğŸ”’ éšç§ä¸æ•°æ®å®‰å…¨</h4>
                <p>Blokko è¢«è®¾è®¡ä¸ºä¸€ä¸ªçº¯å®¢æˆ·ç«¯å·¥å…·ã€‚</p>
                <p><strong>æ‚¨çš„åˆ›ä½œ100%åœ¨æœ¬åœ°ï¼š</strong> æ‚¨çš„æ‰€æœ‰åˆ›ä½œæ•°æ®ï¼ŒåŒ…æ‹¬æ‚¨ä¸Šä¼ çš„å¤´åƒã€èƒŒæ™¯å›¾ã€å­—ä½“æ–‡ä»¶ã€å¡ç‰‡å†…å®¹ç­‰ï¼Œæ°¸è¿œä¸ä¼šç¦»å¼€æ‚¨çš„ç”µè„‘ã€‚æ‰€æœ‰å¤„ç†éƒ½åœ¨æ‚¨çš„æµè§ˆå™¨ä¸­å®Œæˆï¼Œäº‘ç«¯ä¸ä¼šå­˜å‚¨æ‚¨çš„ä»»ä½•ä¿¡æ¯ã€‚</p>
                <p><strong>ç¬¬ä¸‰æ–¹æœåŠ¡ï¼ˆå›¾æ ‡æœç´¢ï¼‰ï¼š</strong></p>
                <ul>
                    <li>ä¸ºäº†æä¾›â€œåœ¨çº¿å›¾æ ‡æœç´¢â€åŠŸèƒ½ï¼Œæœ¬å·¥å…·è°ƒç”¨äº† Iconify.design çš„å…¬å…±APIã€‚</li>
                    <li>å½“æ‚¨åœ¨å›¾æ ‡æœç´¢æ¡†ä¸­è¾“å…¥å…³é”®è¯æ—¶ï¼Œè¿™ä¸ªå…³é”®è¯ä¼šè¢«å‘é€åˆ° Iconify çš„æœåŠ¡å™¨ä»¥è·å–æœç´¢ç»“æœã€‚</li>
                    <li>æ­¤è¿‡ç¨‹æ˜¯åŒ¿åçš„ï¼Œä¸åŒ…å«æ‚¨çš„ä»»ä½•ä¸ªäººä¿¡æ¯æˆ–åˆ›ä½œå†…å®¹ã€‚</li>
                </ul>
		   </div>
            <div id="help-thanks" class="tab-content">
                <p>æœ¬å·¥å…·çš„å®ç°ç¦»ä¸å¼€ä»¥ä¸‹ä¼˜ç§€çš„å¼€æºé¡¹ç›®ï¼Œåœ¨æ­¤è¡¨ç¤ºè¯šæŒšçš„æ„Ÿè°¢ï¼Œæ¬¢è¿ç‚¹å‡»åç§°è·³è½¬åˆ°å¯¹åº”å®˜ç½‘/githubä»“åº“å»æ”¯æŒä»–ä»¬çš„å·¥ä½œã€‚ï¼š</p>
                <div class="thanks-item">
                    <h4>æ ¸å¿ƒåŠŸèƒ½åº“</h4>
                    <p>ä»¥ä¸‹é¡¹ç›®å‡åŸºäºå¯¹å•†ä¸šå‹å¥½çš„å¼€æºåè®®ï¼Œç‰¹æ­¤æ„Ÿè°¢ã€‚</p>
                    <ul>
                        <li><a href="https://github.com/lokesh/color-thief" target="_blank" rel="noopener noreferrer"><strong>Color Thief</strong></a> - (MIT License) æä¾›äº†ä»å›¾ç‰‡æå–ä¸»è‰²è°ƒå’Œè°ƒè‰²æ¿çš„åŠŸèƒ½ã€‚</li>
                        <li><a href="https://html2canvas.hertzen.com/" target="_blank" rel="noopener noreferrer"><strong>html2canvas</strong></a> - (MIT License) å®ç°äº†å°†ç½‘é¡µå†…å®¹å¯¼å‡ºä¸ºå›¾ç‰‡çš„æ ¸å¿ƒåŠŸèƒ½ã€‚</li>
                        <li><a href="https://fengyuanchen.github.io/cropperjs/" target="_blank" rel="noopener noreferrer"><strong>Cropper.js</strong></a> - (MIT License) æä¾›äº†å¼ºå¤§çš„å›¾ç‰‡è£å‰ªåŠŸèƒ½ã€‚</li>
                        <li><a href="https://sortablejs.github.io/Sortable/" target="_blank" rel="noopener noreferrer"><strong>SortableJS</strong></a> - (MIT License) æä¾›äº†æµç•…çš„æ‹–æ‹½æ’åºä½“éªŒã€‚</li>
                        <li><a href="https://masonry.desandro.com/" target="_blank" rel="noopener noreferrer"><strong>Masonry.js</strong></a> - (MIT License) æä¾›äº†å¼ºå¤§çš„ç€‘å¸ƒæµ/ç Œä½“å¸ƒå±€åŠŸèƒ½ã€‚</li>
                        <li><a href="https://quilljs.com/" target="_blank" rel="noopener noreferrer"><strong>Quill.js</strong></a> - (BSD 3-Clause License) æä¾›äº†å¼ºå¤§ã€ç¨³å®šä¸”æ˜“äºæ‰©å±•çš„å¯Œæ–‡æœ¬ç¼–è¾‘åŠŸèƒ½ã€‚</li>
                    </ul>
                    <details>
                        <summary>æŸ¥çœ‹ MIT è®¸å¯è¯åŸæ–‡</summary>
                        <pre>
Copyright (c) 2024

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
                        </pre>
                    </details>
                    <details>
                        <summary>æŸ¥çœ‹ BSD 3-Clause è®¸å¯è¯åŸæ–‡</summary>
                        <pre>
Copyright (c) 2017, Jason Chen. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

* Neither the name of the author nor the names of its contributors may be
  used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
                        </pre>
                    </details>
                </div>
                 <div class="thanks-item">
                    <h4>å¼€æºå­—ä½“</h4>
                    <p>æœ¬é¡¹ç›®é›†æˆçš„æ¨èå­—ä½“ï¼Œé™¤ä¸¤æ¬¾æ¥è‡ªç«™é…·çš„å­—ä½“ä»¥å¤–ï¼Œå‡åŸºäº <strong>SIL Open Font License 1.1</strong> åè®®ï¼Œå‡å¯å…è´¹å•†ç”¨ã€‚</p>
                    <ul>
                        <li><a href="https://github.com/lxgw/LxgwWenkai?tab=readme-ov-file" target="_blank" rel="noopener noreferrer"><strong>éœé¹œæ–‡æ¥· (LXGW WenKai)</strong></a> - ç”±è½éœå­¤é¹œï¼ŒåŸºäº FONTWORKS å‡ºå“å­—ä½“ Klee One è¡ç”Ÿçš„å­—ä½“ã€‚</li>
						<li><a href="https://github.com/adobe-fonts/source-han-sans" target="_blank" rel="noopener noreferrer"><strong>æ€æºé»‘ä½“ (Source Han Sans)</strong></a> - ç”± Adobe ä¸ Google è”åˆå¼€å‘ã€‚</li>
                        <li><a href="https://github.com/adobe-fonts/source-han-serif" target="_blank" rel="noopener noreferrer"><strong>æ€æºå®‹ä½“ (Source Han Serif)</strong></a> - ç”± Adobe ä¸ Google è”åˆå¼€å‘ã€‚</li>
                        <li><a href="https://www.zcool.com.cn/special/zcoolfonts/" target="_blank" rel="noopener noreferrer"><strong>ç«™é…·å¿«ä¹ä½“ (ZCOOL KuaiLe)</strong></a> - ç”± ç«™é…· (ZCOOL) è®¾è®¡å¸ˆå›¢é˜Ÿåˆ›ä½œã€‚</li>
                        <li><a href="https://www.zcool.com.cn/special/zcoolfonts/" target="_blank" rel="noopener noreferrer"><strong>ç«™é…·å°è–‡ä½“ (ZCOOL XiaoWei)</strong></a> - ç”± ç«™é…· (ZCOOL) è®¾è®¡å¸ˆå›¢é˜Ÿåˆ›ä½œã€‚</li>
                    </ul>
                    <details>
                        <summary>æŸ¥çœ‹ SIL Open Font License 1.1 è®¸å¯è¯åŸæ–‡</summary>
                        <pre>
This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL

-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded,
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting â€” in part or in whole â€” any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining a
copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.
                        </pre>
                    </details>
                </div>
                <div class="thanks-item">
                    <h4>èµ„æºä¸æœåŠ¡</h4>
                    <ul>
                        <li>
                            <a href="https://iconify.design/" target="_blank" rel="noopener noreferrer"><strong>Iconify</strong></a>: æä¾›äº†ç»Ÿä¸€çš„å›¾æ ‡æ£€ç´¢å’ŒåŠ è½½åŠŸèƒ½ã€‚æœ¬é¡¹ç›®ä½¿ç”¨çš„åœ¨çº¿å›¾æ ‡åº“å‡åŸºäºå¯¹å•†ä¸šå‹å¥½çš„å¼€æºåè®®å‘å¸ƒï¼Œç¡®ä¿ç”¨æˆ·å¯è‡ªç”±ä½¿ç”¨ï¼ˆæ— éœ€ç½²åï¼‰ï¼š
                            <ul style="margin-top: 8px;">
                                <li><strong>MIT / ISC åè®®:</strong> Lucide, Tabler, Phosphor (ph), Heroicons, Boxicons (bx), Pixelarticons</li>
                                <li><strong>Apache 2.0 åè®®:</strong> Remix Icon (ri), IconPark, Noto Emoji, Carbon</li>
                                <li><strong>SIL OFL 1.1 åè®®:</strong> Material Design Icons (mdi)</li>
                                <li><strong>CC0 (å…¬å…±é¢†åŸŸ):</strong> Simple Icons</li>
                            </ul>
                        </li>
                        <li><a href="https://heropatterns.com/" target="_blank" rel="noopener noreferrer"><strong>Hero Patterns</strong></a>: æä¾›äº†ç²¾ç¾ã€å¯å®šåˆ¶çš„SVGèƒŒæ™¯çº¹ç† (MIT License)ã€‚</li>
						<li><a href="https://fonts.zeoseven.com/" target="_blank" rel="noopener noreferrer"><strong>ZeoSevenâ„¢ Fonts</strong></a>: æä¾›äº†åœ¨çº¿è·å–å­—ä½“æœåŠ¡ï¼Œæ‚¨ä¹Ÿå¯ä»¥åœ¨æ­¤å¤„å…è´¹è·å–æ›´å¤šå•†ä¸šå‹å¥½åè®®çš„å­—ä½“ã€‚</li>
                    </ul>
					<details>
    <summary>æŸ¥çœ‹ Apache License 2.0 è®¸å¯è¯åŸæ–‡</summary>
    <pre>
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
Monitor of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
    </pre>
</details>
                </div>
            </div>
            <div id="help-changelog" class="tab-content">
                <h4>v1.6.0 æ›´æ–°æ—¥å¿—</h4>
                <ul>
                    <li><strong>ã€æ–°å¢ã€‘å¯Œæ–‡æœ¬ç¼–è¾‘:</strong>
                        <ul>
                            <li>é›†æˆäº† Quill.js å¯Œæ–‡æœ¬ç¼–è¾‘å™¨ã€‚ç°åœ¨åŒå‡»å¡ç‰‡å†…å®¹ä¼šå¼¹å‡ºä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„ç¼–è¾‘å™¨ï¼Œæ”¯æŒåŠ ç²—ã€æ–œä½“ã€åˆ—è¡¨ã€é“¾æ¥ã€é¢œè‰²ç­‰ã€‚</li>
                            <li>ä¸ºäº†äº¤äº’ç»Ÿä¸€ï¼Œåœ¨å³ä¾§æ ·å¼æ£€æŸ¥å™¨çš„å¡ç‰‡å†…å®¹åŒºå¢åŠ äº†**â€œç¼–è¾‘å†…å®¹â€æŒ‰é’®**ï¼ŒPCå’Œç§»åŠ¨ç«¯å‡å¯è½»æ¾æ‰“å¼€ç¼–è¾‘å™¨ã€‚</li>
                        </ul>
                    </li>
                    <li><strong>ã€ä¼˜åŒ–ã€‘ç§»åŠ¨ç«¯:</strong>
                        <ul>
                            <li>åœ¨â€œç¼–è¾‘ä¸­â€æ¨¡å¼ä¸‹ï¼Œç§»åŠ¨ç«¯é¢„è§ˆåŒºçš„æ‰€æœ‰å¯ç¼–è¾‘æ–‡æœ¬ï¼ˆæ˜µç§°ã€ç®€ä»‹ã€å¡ç‰‡å†…å®¹ç­‰ï¼‰å³ä¸Šè§’éƒ½ä¼šå‡ºç°ä¸€ä¸ª**é“…ç¬”å›¾æ ‡ âœï¸**ï¼Œè§£å†³äº†å¯èƒ½å­˜åœ¨çš„åŒå‡»ä¸çµæ•çš„é—®é¢˜ã€‚</li>
                        </ul>
                    </li>
                    <li><strong>ã€ä¼˜åŒ–/æ–°å¢ã€‘æç¤º:</strong>
                        <ul>
                            <li>åœ¨â€œå¯ç”¨ç€‘å¸ƒæµâ€ã€â€œæ–‡å­—æè¾¹â€ç­‰é«˜çº§è®¾ç½®æ—å¢åŠ äº† `(?)` å›¾æ ‡ï¼Œé¼ æ ‡æ‚¬åœå³å¯æŸ¥çœ‹åŠŸèƒ½è¯´æ˜ï¼Œé™ä½äº†å­¦ä¹ æˆæœ¬ã€‚</li>
                        </ul>
                    </li>
                    <li><strong>ã€ä½“éªŒä¼˜åŒ–ã€‘å¸¦æè¿°çš„æ’¤é”€/é‡åš:</strong>
                        <ul>
                            <li>ç°åœ¨é¼ æ ‡æ‚¬åœåœ¨â€œæ’¤é”€â€æˆ–â€œé‡åšâ€æŒ‰é’®ä¸Šæ—¶ï¼Œä¼šæç¤ºå…·ä½“çš„æ“ä½œå†å²ï¼ˆå¦‚â€œæ’¤é”€: æ·»åŠ å¡ç‰‡â€ï¼‰ï¼Œè®©æ“ä½œæ›´å®‰å…¨ã€æ›´å¯æ§ã€‚</li>
                        </ul>
                    </li>
                     <li><strong>ã€åŠŸèƒ½æ–°å¢ã€‘å¤´éƒ¨åœ†è§’è®¾ç½®:</strong>
                        <ul>
                            <li>åœ¨â€œé¡µé¢ä¸å¤´éƒ¨æ ·å¼â€çš„é«˜çº§è®¾ç½®ä¸­ï¼Œå¢åŠ äº†â€œå¤´éƒ¨åœ†è§’â€è°ƒèŠ‚æ»‘å—ï¼Œå¯ä»¥è‡ªç”±å®šä¹‰å¤´éƒ¨èƒŒæ™¯çš„åœ†è§’å¤§å°ã€‚</li>
                        </ul>
                    </li>
                    <li><strong>ã€ä¿®å¤ã€‘å†…å®¹ç¼–è¾‘é€»è¾‘:</strong>
                        <ul>
                            <li>ä¿®å¤äº†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç›´æ¥åœ¨é¢„è§ˆåŒºç¼–è¾‘å¡ç‰‡å†…å®¹æ—¶ï¼Œç€‘å¸ƒæµå¸ƒå±€ä¸ä¼šè‡ªåŠ¨åˆ·æ–°çš„é—®é¢˜ã€‚</li>
                            <li>å¢å¼ºäº†å¯¹å¯Œæ–‡æœ¬å†…å®¹çš„å®‰å…¨è¿‡æ»¤ï¼Œé˜²æ­¢ç²˜è´´ä¸å¿…è¦çš„æ ·å¼ä»£ç ã€‚</li>
                        </ul>
                    </li>
                    <li><strong>ã€åˆè§„ã€‘è®¸å¯è¯æ›´æ–°:</strong>
                        <ul>
                            <li>åœ¨â€œæ„Ÿè°¢ä¿¡æ¯â€é¡µé¢ä¸­ï¼Œå·²æ·»åŠ å¯¹æ–°å¼•å…¥çš„ Quill.js (BSD-3-Clause License) çš„è‡´è°¢ã€‚</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div id="help-about" class="tab-content">
                <h4>å…³äº Blokko</h4>
                <p>Blokkoæ˜¯ä¸€ä¸ªæ–¹ä¾¿å¤§å®¶å¿«é€Ÿåˆ¶ä½œæ‰©åˆ—/è‡ªè/ç½®é¡¶å›¾çš„å°å·¥å…·ï¼å› ä¸ºæœ¬è´¨ä¸Šæ˜¯è‡ªç”¨å°å·¥å…·ï¼Œå¾ˆå¤šåœ°æ–¹éƒ½æ²¡æœ‰ç»†ç»†æ‰“ç£¨ç•¥æ˜¾ç®€é™‹ï¼Œä¹Ÿç¼ºå°‘å®Œå–„çš„æ–°æ‰‹æ•™ç¨‹_(:Ğ·ã€âˆ )_ï¼Œæœªæ¥æˆ–è®¸ä¼šè¡¥å……ä¸€ä¸ªåœ¨çº¿æ–‡æ¡£ï¼Œåˆ¶ä½œçš„åˆè¡·æ˜¯å‘ç°lit.linkç½‘ç«™å¯¹ç®€ä½“ä¸­æ–‡æ”¯æŒä¸å®Œå–„ï¼Œå¾ˆå¤šå­—ä½“éƒ½ä¼šç¼ºå­—å¯¼è‡´æ•ˆæœä¸å¥½çœ‹ï¼Œäºæ˜¯åˆ¶ä½œäº†Blokkoæ¥æ›¿ä»£ã€‚</p>
                <p><strong>ä½œè€…ï¼š</strong> å››åä¸ƒ/baozi_cola</p>
                <p>å¦‚æœä½ åœ¨ä½¿ç”¨ä¸­é‡åˆ°BUGï¼Œå¯ä»¥é€šè¿‡é“¾æ¥ç§ä¿¡æˆ‘ï¼å¦‚æœè§‰å¾—å¥½ç”¨ï¼Œä¹Ÿå¸Œæœ›èƒ½ç‚¹å‡»é“¾æ¥å»ç½®é¡¶è¯„è®ºåŒºç•™ä¸‹è¯„è®ºæˆ–è½¬å‘ï¼Œæˆ–è€…æ˜¯åœ¨è‡ªå·±çš„åˆ¶ä½œçš„å›¾è¯„è®ºåŒºæˆ–æ­£æ–‡é‡Œè´´ä¸ŠåŸåšé“¾æ¥ï¼ˆå°±æ˜¯ç½®é¡¶é‚£ä¸€æ¡ï¼Œå½“ç„¶è¿™äº›éƒ½ä¸æ˜¯å¼ºåˆ¶è¦æ±‚çš„ï¼Œä½†æ˜¯å¦‚æœå¯ä»¥çš„è¯ä¼šè®©æˆ‘å¾ˆå¼€å¿ƒï¼ï¼‰ï¼Œæœ€åæ„Ÿè°¢æ‚¨ä½¿ç”¨Blokko,å¸Œæœ›ä½ å¯ä»¥åšå‡ºä½ æ»¡æ„çš„æ•ˆæœà´¦àµà´¦à´¿Ë¶â€¢Ì€ÖŠâ€¢Ì)âœ§</p>
                <p style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <a href="https://weibo.com/u/5095783616" target="_blank" rel="noopener noreferrer" class="btn btn-default" style="width: auto; text-decoration: none;">æˆ‘çš„å¾®åšä¸»é¡µ</a>
                    <a href="https://weibo.com/5095783616/QcM8qwmLs" target="_blank" rel="noopener noreferrer" class="btn btn-default" style="width: auto; text-decoration: none;">æŸ¥çœ‹å†å²æ›´æ–°æ—¥å¿—</a>
                </p>
            </div>
            <div class="modal-actions" style="justify-content: center; margin-top: 20px;">
                <button id="help-modal-close-btn" class="btn btn-primary">å…³é—­</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="icon-picker-modal">
        <div class="modal-container">
            <h3>é€‰æ‹©å›¾æ ‡</h3>
            <div class="form-group">
                <input type="text" id="icon-search" placeholder="æœç´¢å›¾æ ‡ (ä¾‹å¦‚: bilibili, music, home, user)..." class="form-control">
            </div>
            <div id="icon-grid"></div>
            <div class="modal-actions">
                <button id="upload-icon-btn" class="btn btn-secondary">ä¸Šä¼ å›¾æ ‡ (.svg)</button>
                <input type="file" id="icon-upload-input" accept=".svg" style="display: none;">
                <button id="remove-icon-btn" class="btn btn-danger">ç§»é™¤å›¾æ ‡</button>
                <button id="icon-picker-close-btn" class="btn btn-default">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="texture-picker-modal">
        <div class="modal-container">
            <h3>é€‰æ‹©èƒŒæ™¯çº¹ç†</h3>
            <div id="texture-grid"></div>
            <div class="modal-actions">
                <button id="remove-texture-btn" class="btn btn-danger">ç§»é™¤çº¹ç†</button>
                <button id="texture-picker-close-btn" class="btn btn-default">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="font-manager-modal">
        <div class="modal-container">
            <h3>ç®¡ç†ä¸Šä¼ çš„å­—ä½“</h3>
            <div id="font-manager-list"></div>
            <div class="modal-actions" style="justify-content: center;">
                <button id="font-manager-close-btn" class="btn btn-primary">å…³é—­</button>
            </div>
        </div>
    </div>

    <div id="loading-overlay"><div class="spinner"></div><span id="loading-text">æ­£åœ¨å¤„ç†...</span></div>
    <div class="toast-notification-container" id="toast-container"></div>
    
    <div id="color-context-menu">
        <ul>
            <li data-action="apply-page-bg-solid">åº”ç”¨åˆ°é¡µé¢èƒŒæ™¯è‰²</li>
            <li data-action="apply-page-bg-gradient-start">&rarr; é¡µé¢èƒŒæ™¯æ¸å˜ (èµ·å§‹è‰²)</li>
            <li data-action="apply-page-bg-gradient-end">&rarr; é¡µé¢èƒŒæ™¯æ¸å˜ (ç»“æŸè‰²)</li>
            <hr />
            <li data-action="apply-header-bg-solid">åº”ç”¨åˆ°å¤´éƒ¨èƒŒæ™¯è‰²</li>
            <li data-action="apply-header-bg-gradient-start">&rarr; å¤´éƒ¨èƒŒæ™¯æ¸å˜ (èµ·å§‹è‰²)</li>
            <li data-action="apply-header-bg-gradient-end">&rarr; å¤´éƒ¨èƒŒæ™¯æ¸å˜ (ç»“æŸè‰²)</li>
            <li data-action="apply-header-text">åº”ç”¨åˆ°å¤´éƒ¨æ–‡å­—é¢œè‰²</li>
            <hr />
            <li data-action="apply-gcard-bg">åº”ç”¨åˆ°å…¨å±€å¡ç‰‡èƒŒæ™¯è‰²</li>
            <li data-action="apply-gcard-bg-gradient-start">&rarr; å…¨å±€å¡ç‰‡æ¸å˜ (èµ·å§‹è‰²)</li>
            <li data-action="apply-gcard-bg-gradient-end">&rarr; å…¨å±€å¡ç‰‡æ¸å˜ (ç»“æŸè‰²)</li>
            <li data-action="apply-gcard-text">åº”ç”¨åˆ°å…¨å±€å¡ç‰‡æ–‡å­—è‰²</li>
        </ul>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.2/Sortable.min.js" defer></script>
    <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js" defer></script>
    <script src="https://code.iconify.design/3/3.1.1/iconify.min.js" defer></script>
    <!-- FEATURE: Rich Text Editor - Quill.js JS -->
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.js"></script>

    
    <script>
        // Hero Patterns data. Source: https://heropatterns.com/
        const HeroPatterns = [
            { name: 'Jigsaw', svg: (c, o) => `<svg width="60" height="60" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg"><path d="M41.512 41.512c.976.976 2.256.488 2.256-1.024v-6.728c0-1.512.732-2.256 2.256-2.256h6.728c1.512 0 2.016-.244 1.024-2.256-3.904-7.808-7.808-11.712-11.712-11.712-3.904 0-7.808 3.904-11.712 11.712-.992 2.012-.504 2.256 1.024 2.256h6.728c1.512 0 2.256.732 2.256 2.256v6.728c0 1.512.244 2.016 2.256 1.024zM59 60c.504 0 1-.488 1-1V38.864c0-1.512.732-2.256 2.256-2.256h10.128c1.008 0 1.512.22 1.512 1.248 0 4.88-3.904 9.76-11.712 9.76-7.808 0-11.712-4.88-11.712-9.76 0-1.028.504-1.248 1.512-1.248h10.128c1.512 0 2.256.732 2.256 2.256V59c0 .512.488 1 1 1h16.336c.512 0 1-.488 1-1V38.864c0-1.512.732-2.256 2.256-2.256h10.128c1.008 0 1.512.22 1.512 1.248 0 4.88-3.904 9.76-11.712 9.76-7.808 0-11.712-4.88-11.712-9.76 0-1.028.504-1.248 1.512-1.248h10.128c1.512 0 2.256.732 2.256 2.256V59c0 .512.488 1 1 1H59z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Overlapping Circles', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><circle cx="5" cy="5" r="5"/><circle cx="15" cy="5" r="5"/><circle cx="5" cy="15" r="5"/><circle cx="15" cy="15" r="5"/></g></svg>` },
            { name: 'Plus', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 2h2v2H2V2zm4 0h2v2H6V2zm4 0h2v2h-2V2zm4 0h2v2h-2V2zM2 6h2v2H2V6zm4 0h2v2H6V6zm4 0h2v2h-2V6zm4 0h2v2h-2V6zM2 10h2v2H2v-2zm4 0h2v2H6v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zM2 14h2v2H2v-2zm4 0h2v2H6v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'X-Equals', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 2.5a.5.5 0 01.5-.5h14a.5.5 0 01.5.5v1a.5.5 0 01-.5.5h-14a.5.5 0 01-.5-.5v-1zM17 6H3a1 1 0 000 2h14a1 1 0 000-2zM3 12h14a1 1 0 000-2H3a1 1 0 100 2zm15 3.5a.5.5 0 01-.5.5h-14a.5.5 0 01-.5-.5v-1a.5.5 0 01.5-.5h14a.5.5 0 01.5.5v1z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Brick Wall', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h20v20H0V0zm10 12h10v2H10v-2zM0 2h10v2H0V2zm0 8h10v2H0v-2zm10 0h10v2H10v-2zM0 6h10v2H0V6zm10-4h10v2H10V2zM0 14h10v2H0v-2zm10 4h10v2H10v-2z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Floating Cogs', svg: (c, o) => `<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M9 13.09V5.5c0-.828.672-1.5 1.5-1.5h5c.828 0 1.5.672 1.5 1.5v7.59a4.5 4.5 0 10-8 0zM5.5 13a3.5 3.5 0 000 7h15a3.5 3.5 0 000-7H5.5z"/><path d="M9 13.09V5.5c0-.828.672-1.5 1.5-1.5h5c.828 0 1.5.672 1.5 1.5v7.59a4.5 4.5 0 10-8 0zM5.5 13a3.5 3.5 0 000 7h15a3.5 3.5 0 000-7H5.5z" transform="rotate(180 13 13)"/></g></svg>` },
            { name: 'Polka Dots', svg: (c, o) => `<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><circle cx="3" cy="3" r="3"/><circle cx="13" cy="13" r="3"/></g></svg>` },
            { name: 'Faceted', svg: (c, o) => `<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M0 40L40 0H20L0 20z" /><path d="M40 40V20L20 40z" /></g></svg>`},
            { name: 'Topography', svg: (c, o) => `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm5 8c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm10 0c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm13-8c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-5 8c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-10 0c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-5-18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Lines In Motion', svg: (c, o) => `<svg width="80" height="80" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><path d="M20 20v40h40V20H20zm20 38c-9.94 0-18-8.06-18-18s8.06-18 18-18 18 8.06 18 18-8.06 18-18 18z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Cicada Stripe', svg: (c, o) => `<svg width="6" height="6" viewBox="0 0 6 6" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>` },
            { name: 'Diamonds', svg: (c, o) => `<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M0 5h5L0 0v5zm10 0h-5l5-5v5zM0 5h5l5 5H5L0 5zm10 0h-5l-5 5h5l5-5z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Texture', svg: (c, o) => `<svg width="52" height="26" viewBox="0 0 52 26" xmlns="http://www.w3.org/2000/svg"><g fill="${c}" fill-opacity="${o}" fill-rule="evenodd"><path d="M10 10c0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6h2c0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4v2c-3.314 0-6-2.686-6-6 0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6zm25.464-1.95l8.486 8.486-1.414 1.414-8.486-8.486 1.414-1.414z" /><path d="M41.464 15.05l8.486-8.486-1.414-1.414-8.486 8.486 1.414 1.414z" /></g></svg>` },
            { name: 'Cross', svg: (c, o) => `<svg width="8" height="8" viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg"><path d="M4 0h1v3h3v1H5v3H4V4H1V3h3z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Rain', svg: (c, o) => `<svg width="4" height="4" viewBox="0 0 4 4" xmlns="http://www.w3.org/2000/svg"><path d="M1 3h1v1H1V3zm2-2h1v1H3V1z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Diagonal Lines', svg: (c, o) => `<svg width="4" height="4" viewBox="0 0 4 4" xmlns="http://www.w3.org/2000/svg"><path d="M-1 3h1v1H-1V3zm2-2h1v1H1V1zm2-2h1v1H3V-1z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
            { name: 'Chevrons', svg: (c, o) => `<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M0 0l5 5-5 5h5l5-5-5-5H0z" fill="${c}" fill-opacity="${o}" fill-rule="evenodd"/></svg>` },
        ];

        document.addEventListener('DOMContentLoaded', () => {
            const App = {
                db: null, // IndexedDB æ•°æ®åº“å®ä¾‹
                isStorageFull: false, // æ ‡è®°å­˜å‚¨æ˜¯å¦å·²æ»¡
                state: {},
                selection: { type: 'global', cardId: null },
                history: [],
                historyIndex: -1,
                isRestoringState: false,
                isEditingText: false,
                cropper: null,
                currentCropTarget: null,
                currentIconTarget: null, 
                // --- FEATURE: Rich Text Editor ---
                richTextEditor: null,
                currentRichTextTarget: null,
                // --- END FEATURE ---
                sortableLayers: null,
                sortablePreview: null,
                sortableTags: null,
                sortablePreviewTags: null,
                cardLayerSortables: {},
                cardSortables: {},
                imageCardSortables: {},
                masonryInstances: {},
                debouncedSaveToLocal: null,
                localFonts: [],
                uploadedFonts: [], // ç°åœ¨åªå­˜å‚¨å­—ä½“å…ƒä¿¡æ¯ { family, fullName }
                presets: {},
                icons: [], 
                texturePickerInitialized: false,
                iconPickerInitialized: false,
                colorThief: null,
                longPressTimer: null,
                lastPalette: [],
                easterEggCounter: 0,
                easterEggTimer: null,
                tooltipTimeout: null,

                init() {
                    console.log("Blokko åˆå§‹åŒ– v1.6.0 ...");
                    this.elements = this.queryElements();
                    this.presets = this.getPresets();
                    this.state = this.getDefaultState();
                    this.debouncedSaveToLocal = this.debounce(this.saveToLocal, 500);
                    
                    this.initDB().then(async () => {
                        this.bindCoreEvents();
                        this.bindEditorEvents();
                        this.bindPreviewEvents();
                        this.initResizer();
                        
                        this.loadPreferences();
                        await this.loadFromLocal();
                        
                        this.history = [{ state: this.deepClone(this.state), description: 'åˆå§‹çŠ¶æ€' }];
                        this.historyIndex = 0;
                        
                        this.renderAll(true); 
                        this.syncAllControls();
                        this.populateFontList(); 
                        this.initAllSortables();
                        this.updateExportSizePreview();
                        
                        this.setSelection({ type: 'global' });
                        this.updateUndoRedoButtons();
                        
                        const currentVersion = '1.6.0';
                        const lastVisitedVersion = localStorage.getItem('blokkoLastVersion');
                        if (currentVersion !== lastVisitedVersion) {
                            setTimeout(() => {
                                this.showToast(`å·²æ›´æ–°åˆ° v${currentVersion}ï¼ç‚¹å‡»â€œå¸®åŠ©â€æŸ¥çœ‹æ›´æ–°æ—¥å¿—ã€‚`, 'success');
                            }, 1500);
                            localStorage.setItem('blokkoLastVersion', currentVersion);
                        }
                        
                        if (window.ColorThief) {
                            this.colorThief = new ColorThief();
                        }
                    }).catch(err => {
                        console.error("æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:", err);
                        this.showFatalErrorModal('åˆå§‹åŒ–å¤±è´¥', 'æ— æ³•åˆå§‹åŒ–æœ¬åœ°æ•°æ®åº“ï¼Œè¿™å¯èƒ½æ˜¯ç”±äºæµè§ˆå™¨ç¼“å­˜æŸåã€‚æ‚¨å¯ä»¥å°è¯•é‡ç½®åº”ç”¨æ¥è§£å†³æ­¤é—®é¢˜ã€‚', err);
                    });
                },

                getDefaultState() {
                    const lightTheme = this.getPresets().light;
                    return {
                        customIcons: [],
                        personalInfo: { 
                            nickname: "ä½ çš„æ˜µç§°", nicknameColor: lightTheme.pNicknameColor,
                            subtitle: "è¿™æ˜¯å‰¯æ ‡é¢˜ï¼ŒåŒå‡»å¯ç¼–è¾‘", subtitleColor: lightTheme.pSubtitleColor,
                            bio: "è¿™æ˜¯ç®€ä»‹ï¼ŒåŒå‡»å¯ç¼–è¾‘", bioColor: lightTheme.pBioColor,
                            avatarDataUrl: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23cccccc'%3E%3Cpath d='M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z'/%3E%3C/svg%3E", 
                            avatarShape: '50%', avatarBorderSize: 4, avatarBorderColor: '#ffffff',
                            avatarSize: 100,
                            avatarOffsetX: 0,
                            tags: [
                                { id: this.generateId('t'), icon: 'mdi:palette', text: 'è®¾è®¡å¸ˆ' },
                                { id: this.generateId('t'), icon: 'mdi:github', text: 'ä»£ç çˆ±å¥½è€…' }
                            ], 
                            tagBgColor: lightTheme.pTagBgColor, tagTextColor: lightTheme.pTagTextColor
                        },
                        pageStyles: {
                            pageBgMode: 'solid', // é»˜è®¤çº¯è‰²
                            pageBgSolidColor: lightTheme.pageBgSolidColor, pageBgImageDataUrl: null, 
                            pageBgGradientStart: lightTheme.pageBgGradientStart, pageBgGradientEnd: lightTheme.pageBgGradientEnd,
                            pageBgGradientAngle: 135,
                            pageOverlayColor: "#000000", pageOverlayOpacity: 0.3,
                            pageBgPattern: '', pageBgPatternColor: '#000000', pageBgPatternOpacity: 0.1, pageBgPatternDensity: 30,
                            headerBgMode: 'solid', // é»˜è®¤çº¯è‰²
                            headerBorderRadius: 16, // NEW: Header border radius
                            headerBgColor: lightTheme.headerBgColor, headerTextColor: lightTheme.headerTextColor, headerOpacity: 1.0, 
                            headerBgGradientStart: lightTheme.headerBgGradientStart, headerBgGradientEnd: lightTheme.headerBgGradientEnd,
                            headerBgGradientAngle: 135,
                        },
                        blocks: [
                            { id: this.generateId('b'), type: 'text', title: "å•æ’å¡ç‰‡åŒºå—", isVisible: true, isExpanded: false, settings: { layout: 'single', masonryEnabled: false }, cards: [
                                { id: this.generateId('c'), icon: '', title: "è¿™æ˜¯å•æ’å¡ç‰‡", content: "åŒå‡»è¿™é‡Œè¿›è¡Œç¼–è¾‘ï¼Œç°åœ¨æ”¯æŒ<b>å¯Œæ–‡æœ¬</b>äº†å“¦ï¼", opacity: 1.0, followGlobalOpacity: true, textShadowEnabled: false }
                            ]},
                            { id: this.generateId('b'), type: 'text', title: "åŒæ’å¡ç‰‡åŒºå—", isVisible: true, isExpanded: false, settings: { layout: 'dual', masonryEnabled: false }, cards: [
                                { id: this.generateId('c'), icon: '', title: "è¿™æ˜¯åŒæ’å¡ç‰‡ 1", content: "åŒå‡»è¿™é‡Œè¿›è¡Œç¼–è¾‘", opacity: 1.0, followGlobalOpacity: true, textShadowEnabled: false },
                                { id: this.generateId('c'), icon: '', title: "è¿™æ˜¯åŒæ’å¡ç‰‡ 2", content: "åŒå‡»è¿™é‡Œè¿›è¡Œç¼–è¾‘", opacity: 1.0, followGlobalOpacity: true, textShadowEnabled: false }
                            ]},
                            { id: this.generateId('b'), type: 'separator', title: "åˆ†å‰²çº¿", isVisible: true, isExpanded: false, settings: { style: 'solid', color: '#dddddd', thickness: 1, margin: 20, text: '', icon: null, textColor: '#555555' }},
                            { id: this.generateId('b'), type: 'image', title: "å›¾ç‰‡åŒºå—", isVisible: true, isExpanded: false, settings: { layout: 'dual', masonryEnabled: false, textColor: '' }, cards: [] },
                            { id: this.generateId('b'), type: 'spacer', title: "ç•™ç™½å—", isVisible: true, isExpanded: false, settings: { height: 20 }},
                        ],
                        globalCardStyles: { 
                            bgMode: 'solid', // é»˜è®¤çº¯è‰²
                            bgColor: lightTheme.gCardBgColor, textColor: lightTheme.gCardTextColor, opacity: 1.0,
                            bgGradientStart: lightTheme.gCardBgGradientStart, bgGradientEnd: lightTheme.gCardBgGradientEnd,
                            bgGradientAngle: 135,
                            radius: 12, textAlign: "left", lineHeight: "1.5", 
                            fontFamily: "", fontSize: "1rem",
                            textStrokeWidth: 0, textStrokeColor: "#000000",
                            borderWidth: 0, borderStyle: 'none', borderColor: '#cccccc',
                        }
                    };
                },
                
                getPresets() {
                    return {
                        light: {
                            pageBgSolidColor: "#f0f2f5", pageBgGradientStart: "#f0f2f5", pageBgGradientEnd: "#e6e9ed",
                            headerBgColor: "#ffffff", headerBgGradientStart: "#ffffff", headerBgGradientEnd: "#f7f7f7",
                            headerTextColor: "#1a1a1a",
                            gCardBgColor: "#ffffff", gCardTextColor: "#1a1a1a", gCardOpacity: 1.0,
                            gCardBgGradientStart: "#ffffff", gCardBgGradientEnd: "#f5f5f5",
                            pNicknameColor: "#1a1a1a", pSubtitleColor: "#555555", pBioColor: "#555555",
                            pTagBgColor: "#eef1f5", pTagTextColor: "#3c3c43",
                        },
                        dark: {
                            pageBgSolidColor: "#121417", pageBgGradientStart: "#121417", pageBgGradientEnd: "#1a1d21",
                            headerBgColor: "#1f2229", headerBgGradientStart: "#1f2229", headerBgGradientEnd: "#252930",
                            headerTextColor: "#f0f2f5",
                            gCardBgColor: "#2c303a", gCardTextColor: "#f0f2f5", gCardOpacity: 0.95,
                            gCardBgGradientStart: "#2c303a", gCardBgGradientEnd: "#343946",
                            pNicknameColor: "#f0f2f5", pSubtitleColor: "#a0aec0", pBioColor: "#a0aec0",
                            pTagBgColor: "#3e4451", pTagTextColor: "#e2e8f0",
                        },
                        mint: {
                            pageBgSolidColor: "#ccfbf1", pageBgGradientStart: "#ccfbf1", pageBgGradientEnd: "#a7f3d0",
                            headerBgColor: "#f0fdfa", headerBgGradientStart: "#f0fdfa", headerBgGradientEnd: "#e6fcf5",
                            headerTextColor: "#0f766e",
                            gCardBgColor: "#ffffff", gCardTextColor: "#134e4a", gCardOpacity: 1.0,
                            gCardBgGradientStart: "#ffffff", gCardBgGradientEnd: "#fafffd",
                            pNicknameColor: "#064e3b", pSubtitleColor: "#115e59", pBioColor: "#134e4a",
                            pTagBgColor: "#a7f3d0", pTagTextColor: "#065f46",
                        },
                        coffee: {
                            pageBgSolidColor: "#f3e8e2", pageBgGradientStart: "#f3e8e2", pageBgGradientEnd: "#e9d8cf",
                            headerBgColor: "#fdf8f6", headerBgGradientStart: "#fdf8f6", headerBgGradientEnd: "#faf3ef",
                            headerTextColor: "#432818",
                            gCardBgColor: "#ffffff", gCardTextColor: "#5e4534", gCardOpacity: 1.0,
                            gCardBgGradientStart: "#ffffff", gCardBgGradientEnd: "#fffbf8",
                            pNicknameColor: "#432818", pSubtitleColor: "#6f4e37", pBioColor: "#5e4534",
                            pTagBgColor: "#e3d5ca", pTagTextColor: "#432818",
                        }
                    };
                },

                queryElements() {
                    const q = (selector) => document.querySelector(selector);
                    return {
                        layerPanel: q('#layer-panel'),
                        inspectorPanel: q('#inspector-panel'),
                        layerList: q('#layer-list'),
                        previewPanel: q('#preview-panel'),
                        resizer: q('#resizer'),
                        themeToggleBtn: q('#theme-toggle-btn'),
                        previewWrapper: q('#preview-wrapper'), previewOverlay: q('#preview-overlay'),
                        previewBlocksContainer: q('#preview-blocks-container'),
                        previewHeader: q('#preview-header'), previewAvatar: q('#preview-avatar'),
                        previewNickname: q('#preview-nickname'), previewSubtitle: q('#preview-subtitle'),
                        previewBio: q('#preview-bio'), previewTagsContainer: q('#preview-tags-container'),
                        addTextBlockBtn: q('#add-text-block-btn'), addImageBlockBtn: q('#add-image-block-btn'),
                        addSeparatorBlockBtn: q('#add-separator-block-btn'), addSpacerBlockBtn: q('#add-spacer-block-btn'),
                        cropperModal: q('#cropper-modal'), cropperImage: q('#cropper-image'),
                        cropperCancelBtn: q('#cropper-cancel-btn'), cropperSaveBtn: q('#cropper-save-btn'),
                        downloadModal: q('#download-modal'), downloadModalTitle: q('#download-modal-title'),
                        downloadModalContent: q('#download-modal-content'), downloadModalCloseBtn: q('#download-modal-close-btn'),
                        loadingOverlay: q('#loading-overlay'), loadingText: q('#loading-text'),
                        toastContainer: q('#toast-container'),
                        mobileLayerToggle: q('#mobile-layer-toggle'),
                        mobileInspectorToggle: q('#mobile-inspector-toggle'),
                        body: document.body,
                        showHelpBtn: q('#show-help-btn'),
                        helpModal: q('#help-modal'),
                        helpModalCloseBtn: q('#help-modal-close-btn'),
                        iconPickerModal: q('#icon-picker-modal'),
                        iconGrid: q('#icon-grid'),
                        iconSearch: q('#icon-search'),
                        removeIconBtn: q('#remove-icon-btn'),
                        iconPickerCloseBtn: q('#icon-picker-close-btn'),
                        uploadIconBtn: q('#upload-icon-btn'), iconUploadInput: q('#icon-upload-input'),
                        lockModeToggle: q('#lock-mode-toggle'),
                        texturePickerModal: q('#texture-picker-modal'),
                        textureGrid: q('#texture-grid'),
                        removeTextureBtn: q('#remove-texture-btn'),
                        texturePickerCloseBtn: q('#texture-picker-close-btn'),
                        confirmModal: q('#confirm-modal'),
                        colorContextMenu: q('#color-context-menu'),
                        fontManagerModal: q('#font-manager-modal'),
                        storageWarningBanner: q('#storage-warning-banner'),
                        // --- FEATURE: Rich Text Editor ---
                        richTextEditorModal: q('#rich-text-editor-modal'),
                        richTextEditorContainer: q('#rich-text-editor-container'),
                        richTextSaveBtn: q('#rich-text-save-btn'),
                        richTextCancelBtn: q('#rich-text-cancel-btn'),
                        // --- END FEATURE ---
                    };
                },

                bindCoreEvents() {
                    this.elements.themeToggleBtn.addEventListener('click', () => this.toggleTheme());
                    this.elements.addTextBlockBtn.addEventListener('click', () => this.addBlock('text'));
                    this.elements.addImageBlockBtn.addEventListener('click', () => this.addBlock('image'));
                    this.elements.addSeparatorBlockBtn.addEventListener('click', () => this.addBlock('separator'));
                    this.elements.addSpacerBlockBtn.addEventListener('click', () => this.addBlock('spacer'));
                    this.elements.downloadModalCloseBtn.addEventListener('click', () => this.hideDownloadModal());
                    this.elements.cropperCancelBtn.addEventListener('click', () => this.hideCropper());
                    this.elements.cropperSaveBtn.addEventListener('click', () => this.saveCrop());
                    this.elements.cropperModal.querySelector('.crop-ratios').addEventListener('change', () => this.updateCropAspectRatio());
                    
                    this.elements.mobileLayerToggle.addEventListener('click', () => this.togglePanelDrawer('layer-panel'));
                    this.elements.mobileInspectorToggle.addEventListener('click', () => this.togglePanelDrawer('inspector-panel'));

                    this.elements.previewPanel.addEventListener('click', (e) => {
                        if (this.elements.body.classList.contains('panels-open')) {
                            if (!e.target.closest('[contenteditable="true"]')) {
                                e.preventDefault();
                                e.stopPropagation();
                                this.togglePanelDrawer(false);
                            }
                        }
                    });

                    this.elements.showHelpBtn.addEventListener('click', () => this.elements.helpModal.classList.add('visible'));
                    this.elements.helpModalCloseBtn.addEventListener('click', () => this.elements.helpModal.classList.remove('visible'));
                    
                    this.elements.storageWarningBanner.querySelector('#storage-warning-export-link').addEventListener('click', () => {
                        this.setSelection({ type: 'global' });
                        setTimeout(() => this.exportConfig(false), 50);
                    });
                    
                    let aboutClickCount = 0;
                    let aboutClickTimer = null;
                    this.elements.helpModal.querySelector('.tabs').addEventListener('click', (e) => {
                        const tabBtn = e.target.closest('.tab-btn');
                        if (tabBtn) {
                            const parent = tabBtn.closest('.modal-container');
                            parent.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                            tabBtn.classList.add('active');
                            parent.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                            const targetTab = parent.querySelector(`#${tabBtn.dataset.tab}`);
                            if (targetTab) targetTab.classList.add('active');

                            this.elements.helpModalCloseBtn.textContent = (tabBtn.dataset.tab === 'help-tutorial') ? "æˆ‘å·²äº†è§£ï¼Œå¼€å§‹ä½¿ç”¨" : "å…³é—­";

                            if (tabBtn.dataset.tab === 'help-about') {
                                clearTimeout(aboutClickTimer);
                                aboutClickCount++;
                                aboutClickTimer = setTimeout(() => aboutClickCount = 0, 2000);
                                if (aboutClickCount >= 5) {
                                    aboutClickCount = 0;
                                    clearTimeout(aboutClickTimer);
                                    this.activateDebugMode();
                                }
                            }
                        }
                    });
                    
                    this.elements.iconPickerCloseBtn.addEventListener('click', () => this.hideIconPicker());
                    this.elements.removeIconBtn.addEventListener('click', () => this.selectIcon(null));
                    this.elements.iconSearch.addEventListener('input', this.debounce((e) => this.renderIconGrid(e.target.value), 300));
                    this.elements.iconGrid.addEventListener('click', (e) => {
                        const item = e.target.closest('.icon-grid-item');
                        if (item) {
                            if (e.target.closest('.delete-custom-icon-btn')) {
                                this.deleteCustomIcon(item.dataset.iconName);
                            } else {
                                this.selectIcon(item.dataset.icon);
                            }
                        }
                    });
                    
                    this.elements.uploadIconBtn.addEventListener('click', () => this.elements.iconUploadInput.click());
                    this.elements.iconUploadInput.addEventListener('change', e => this.handleIconUpload(e));
                    this.elements.lockModeToggle.addEventListener('click', () => this.toggleLockMode());
                    
                    // --- FEATURE: Rich Text Editor ---
                    this.elements.richTextSaveBtn.addEventListener('click', () => this.saveRichText());
                    this.elements.richTextCancelBtn.addEventListener('click', () => this.hideRichTextEditor());
                    // --- END FEATURE ---

                    this.elements.layerList.addEventListener('click', e => {
                        const layerItemContainer = e.target.closest('.layer-item-container');
                        if (!layerItemContainer) return;

                        const layerItem = layerItemContainer.querySelector('.layer-item');
                        const cardItem = e.target.closest('.card-layer-item');
                        
                        // Action buttons on main layer item
                        const actionBtn = e.target.closest('.layer-actions button, .layer-toggle');
                        if (actionBtn) {
                            const blockId = layerItem.dataset.id;
                            if (actionBtn.matches('.toggle-visibility-btn')) {
                                this.toggleBlockVisibility(blockId);
                            } else if (actionBtn.matches('.duplicate-block-btn')) {
                                this.duplicateBlock(blockId);
                            } else if (actionBtn.matches('.add-card-to-block-btn')) {
                                const block = this.findBlock(blockId);
                                if (block.type === 'text') this.addCard(blockId, true);
                                else if (block.type === 'image') this.addImageCard(blockId);
                            } else if (actionBtn.matches('.layer-toggle')) {
                                this.toggleLayerExpansion(blockId);
                            }
                            return; // Prevent selection change on button click
                        }

                        // Click on a sub-card item
                        if (cardItem) {
                            const blockId = cardItem.closest('.layer-item-container').dataset.blockId;
                            const cardId = cardItem.dataset.cardId;
                            this.setSelection({ type: 'block', id: blockId, cardId: cardId });
                            const cardEditorEl = this.elements.inspectorPanel.querySelector(`.editor-card[data-card-id="${cardId}"]`);
                            if (cardEditorEl) {
                                cardEditorEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        } 
                        // Click on a main layer item
                        else {
                            const { type, id } = layerItem.dataset;
                            this.setSelection({ type, id });
                        }
                    });

                    this.elements.texturePickerCloseBtn.addEventListener('click', () => this.elements.texturePickerModal.classList.remove('visible'));
                    this.elements.removeTextureBtn.addEventListener('click', () => this.selectTexture(null));
                    this.elements.textureGrid.addEventListener('click', e => {
                        const item = e.target.closest('.texture-grid-item');
                        if (item) this.selectTexture(item.dataset.textureName);
                    });

                    this.elements.layerList.addEventListener('dblclick', e => {
                        const layerNameEl = e.target.closest('.layer-name');
                        const layerItem = e.target.closest('.layer-item');
                        if (!layerNameEl || !layerItem || layerItem.dataset.type === 'personalInfo' || this.isEditingText) return;
                        
                        this.isEditingText = true;
                        layerNameEl.contentEditable = true;
                        layerNameEl.focus();
                        document.execCommand('selectAll', false, null);

                        const handleEditEnd = () => {
                            this.isEditingText = false;
                            layerNameEl.contentEditable = false;
                            layerNameEl.removeEventListener('blur', handleEditEnd);
                            layerNameEl.removeEventListener('keydown', handleKeydown);
                            
                            const blockId = layerItem.dataset.id;
                            this.updateBlockTitle(blockId, layerNameEl.innerText, true, `é‡å‘½ååŒºå—ä¸º "${layerNameEl.innerText}"`);
                            const inspectorTitleInput = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${blockId}"] .editor-block-title-input`);
                            if (inspectorTitleInput) inspectorTitleInput.value = layerNameEl.innerText;
                        };
                        const handleKeydown = (ev) => {
                            if (ev.key === 'Enter') {
                                ev.preventDefault();
                                layerNameEl.blur();
                            } else if (ev.key === 'Escape') {
                                layerNameEl.innerText = this.findBlock(layerItem.dataset.id).title;
                                layerNameEl.blur();
                            }
                        };
                        layerNameEl.addEventListener('blur', handleEditEnd);
                        layerNameEl.addEventListener('keydown', handleKeydown);
                    });
                    
                    this.elements.colorContextMenu.addEventListener('click', e => {
                        const action = e.target.dataset.action;
                        const color = this.elements.colorContextMenu.dataset.color;
                        if(action && color) this.applyQuickColor(action, color);
                        this.hideColorContextMenu();
                    });
                    document.addEventListener('click', (e) => {
                        if (!e.target.closest('#color-context-menu')) {
                            this.hideColorContextMenu();
                        }
                    });

                    const titleEl = document.querySelector('.app-header-title');
                    if (titleEl) {
                        titleEl.addEventListener('click', () => {
                            clearTimeout(this.easterEggTimer);
                            this.easterEggCounter++;
                            if (this.easterEggCounter >= 6) {
                                window.open('https://www.bilibili.com/video/BV1m4411M7iy/', '_blank');
                                this.showToast('ğŸ¥š ä½ å‘ç°äº†ä¸€ä¸ªå½©è›‹ï¼', 'success');
                                this.easterEggCounter = 0;
                            } else {
                                this.easterEggTimer = setTimeout(() => {
                                    this.easterEggCounter = 0;
                                }, 2000);
                            }
                        });
                    }

                    document.addEventListener('keydown', e => {
                        // --- FIX: Prevent shortcuts when Rich Text Editor is active ---
                        if (this.richTextEditor && this.richTextEditor.hasFocus()) {
                            return;
                        }
                        const activeEl = document.activeElement;
                        if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) {
                            return;
                        }
                        const isModifierPressed = e.ctrlKey || e.metaKey;
                        if (!isModifierPressed) return;
                        const key = e.key.toLowerCase();
                        if (key === 'z' && !e.shiftKey) {
                            e.preventDefault();
                            this.undo();
                        }
                        if (key === 'y' || (key === 'z' && e.shiftKey)) {
                            e.preventDefault();
                            this.redo();
                        }
                    });
                },
                
                bindEditorEvents() {
                    const panel = this.elements.inspectorPanel;

                    panel.addEventListener('input', e => {
                        if (this.isRestoringState) return;
                        const target = e.target;
                        
                        if (target.matches('.tag-manager-item .tag-text-input')) {
                            const tagItem = target.closest('.tag-manager-item');
                            if (tagItem) this.updateTag(tagItem.dataset.tagId, 'text', target.value, false);
                        }

                        if (target.matches('#font-search-input')) {
                            this.populateFontList(target.value);
                            return;
                        }

                        const updateSource = target.closest('[data-state-key], [data-setting-key], [data-card-key], [data-color-sync-key], [data-block-id-for-title]');
                        if (!updateSource) return;

                        let value = target.type === 'checkbox' ? target.checked : (target.type === 'number' || target.type === 'range') ? parseFloat(target.value) : target.value;
                        
                        if (target.matches('.color-hex-input')) {
                            let hexValue = target.value.replace(/[^#0-9a-fA-F]/g, '');
                            const colorInput = target.previousElementSibling;

                            if (colorInput) {
                                let validHexForPicker = hexValue.startsWith('#') ? hexValue : '#' + hexValue;
                                if (/^#[0-9a-fA-F]{3}$/.test(validHexForPicker)) {
                                    validHexForPicker = '#' + validHexForPicker[1] + validHexForPicker[1] + validHexForPicker[2] + validHexForPicker[2] + validHexForPicker[3] + validHexForPicker[3];
                                    colorInput.value = validHexForPicker;
                                } 
                                else if (/^#[0-9a-fA-F]{6}$/.test(validHexForPicker)) {
                                    colorInput.value = validHexForPicker;
                                }
                            }
                        } 
                        else if (target.type === 'color') {
                            const hexInput = target.nextElementSibling;
                             if(hexInput && hexInput.matches('.color-hex-input')) hexInput.value = value;
                        }

                        const colorInput = target.closest('.input-group')?.querySelector('input[type="color"]');
                        const keySource = colorInput || target;

                        const stateKey = keySource.dataset.stateKey;
                        const blockEl = keySource.closest('.editor-block');
                        const settingKey = keySource.dataset.settingKey;
                        const cardKey = keySource.dataset.cardKey;
                        const blockIdForTitle = updateSource.dataset.blockIdForTitle;
                        
                        if (stateKey) {
                            this.updateState(stateKey, value, false);
                        } else if (blockIdForTitle) {
                            this.updateBlockTitle(blockIdForTitle, value, false);
                        } else if (blockEl && settingKey) {
                             this.updateBlockSettings(blockEl.dataset.blockId, settingKey, value, false);
                        } else if (blockEl && cardKey) {
                            const cardEl = keySource.closest('.editor-card');
                            if (cardEl) this.updateCard(blockEl.dataset.blockId, cardEl.dataset.cardId, cardKey, value, false);
                        }

                        if (target.type === 'range') {
                            const valueDisplay = target.closest('.form-group').querySelector('.angle-value, .spacer-height-value, #gCardRadiusValue, .avatar-size-value, .header-radius-value');
                            if (valueDisplay) valueDisplay.textContent = value;
                        }
                    });

                    panel.addEventListener('blur', e => {
                        const target = e.target;
                        if (target.matches('.color-hex-input')) {
                            let value = target.value.replace(/#/g, '');
                            if (/^[0-9a-fA-F]{3}$/.test(value)) {
                                value = value.split('').map(char => char + char).join('');
                            }
                            if (/^[0-9a-fA-F]{6}$/.test(value)) {
                                target.value = '#' + value;
                                target.dispatchEvent(new Event('input', { bubbles: true }));
                                target.dispatchEvent(new Event('change', { bubbles: true }));
                            }
                        }
                    }, true);

                    panel.addEventListener('change', e => {
                        if (this.isRestoringState) return;
                        const target = e.target;
                        
                        if (target.matches('.advanced-toggle')) {
                            const section = target.closest('.editor-section, .editor-card-content');
                            const isOpen = section.classList.toggle('show-advanced');
                            if (section.id) {
                                localStorage.setItem(`blokko-advanced-${section.id}`, isOpen);
                            }
                            return;
                        }

                        if (target.dataset.stateKey || target.closest('.editor-block') || target.dataset.colorSyncKey || target.matches('.tag-manager-item .tag-text-input')) {
                            let description = 'ä¿®æ”¹æ ·å¼';
                            if (target.dataset.stateKey) description = `ä¿®æ”¹ ${target.dataset.stateKey}`;
                            if (target.closest('.editor-block')) description = `ä¿®æ”¹åŒºå—è®¾ç½®`;
                            this.pushHistory(description);
                        }
                        
                        if (target.type === 'radio' && target.closest('.editor-card')) {
                            this.renderInspector();
                        }

                        const fileInputs = {
                            '#avatar-upload': 'avatar',
                            '#page-bg-upload': 'pageBg',
                            '#color-thief-upload': 'colorThief'
                        };
                        for (const selector in fileInputs) {
                            if (target.matches(selector)) this.handleImageUpload(e, fileInputs[selector]);
                        }
                        if (target.matches('#font-upload-input')) this.handleFontUpload(e);
                        if (target.matches('#config-file-input')) this.handleConfigFile(e);
                        if (target.matches('.card-bg-upload')) {
                           const cardEl = target.closest('.editor-card');
                           const blockEl = target.closest('.editor-block');
                           if (cardEl && blockEl) this.handleCardBgUpload(e, blockEl.dataset.blockId, cardEl.dataset.cardId);
                        }
                        if (target.matches('.image-upload-input')) {
                            const blockEl = target.closest('.editor-block');
                            if (blockEl) {
                                this.handleImageGalleryUpload(blockEl.dataset.blockId, e.target.files);
                            }
                        }
                        
                        if (target.matches('#hd-export-toggle, #custom-width-toggle, #custom-width-input, #export-rounded-corners-toggle, #export-corner-radius-input')) {
                            const customWidthToggle = panel.querySelector('#custom-width-toggle');
                            const customWidthInput = panel.querySelector('#custom-width-input');
                            const hdExportToggle = panel.querySelector('#hd-export-toggle');
                            const exportRoundedToggle = panel.querySelector('#export-rounded-corners-toggle');
                            const cornerRadiusInput = panel.querySelector('#export-corner-radius-input');
    
                            if (target.id === 'custom-width-toggle') {
                                customWidthInput.disabled = !target.checked;
                                if (target.checked) hdExportToggle.checked = false;
                            }
                            
                            if (target.id === 'hd-export-toggle' && target.checked) {
                                customWidthToggle.checked = false;
                                customWidthInput.disabled = true;
                            }
    
                            if (target.id === 'export-rounded-corners-toggle') {
                                cornerRadiusInput.disabled = !target.checked;
                            }
    
                            this.updateExportSizePreview();
                        }

                        if (target.matches('[name^="block-layout"]')) {
                            const blockEl = target.closest('.editor-block');
                            if (blockEl) {
                                const masonryToggle = blockEl.querySelector('.masonry-toggle-container');
                                if (masonryToggle) masonryToggle.style.display = ['dual', 'triple'].includes(target.value) ? 'block' : 'none';
                            }
                            this.renderInspector();
                        }

                        if (target.matches('[data-card-key="followGlobalOpacity"]')) {
                            const opacitySliderGroup = target.closest('.editor-card-content').querySelector('.advanced-setting.opacity-control');
                            if (opacitySliderGroup) opacitySliderGroup.style.display = target.checked ? 'none' : 'block';
                        }
                    });
                    
                    panel.addEventListener('click', e => {
                        const target = e.target;
                        
                        // NEW: Rich Text Editor Trigger
                        const richTextTrigger = target.closest('.rich-text-editor-trigger, .edit-content-btn');
                        if (richTextTrigger) {
                            const cardEl = richTextTrigger.closest('.editor-card');
                            const blockEl = richTextTrigger.closest('.editor-block');
                            if (cardEl && blockEl) {
                                const cardId = cardEl.dataset.cardId;
                                const previewCardContent = this.elements.previewBlocksContainer
                                    .querySelector(`.preview-card[data-card-id="${cardId}"] .preview-card-content`);
                                if (previewCardContent) this.showRichTextEditor(previewCardContent);
                            }
                            return;
                        }

                        const stepperBtn = e.target.closest('.btn-stepper');
                        if (stepperBtn) {
                            const rangeInput = stepperBtn.parentElement.querySelector('input[type="range"]');
                            if (rangeInput) {
                                const step = parseFloat(rangeInput.step) || 1;
                                const currentValue = parseFloat(rangeInput.value);
                                let newValue = stepperBtn.classList.contains('plus') ? currentValue + step : currentValue - step;
                                
                                const min = parseFloat(rangeInput.min);
                                const max = parseFloat(rangeInput.max);
                                if (!isNaN(min)) newValue = Math.max(min, newValue);
                                if (!isNaN(max)) newValue = Math.min(max, newValue);
                                
                                rangeInput.value = newValue;
                                rangeInput.dispatchEvent(new Event('input', { bubbles: true }));
                                rangeInput.dispatchEvent(new Event('change', { bubbles: true }));
                            }
                            return;
                        }

                        const legend = target.closest('.editor-section > legend');
                        if (legend) {
                            legend.parentElement.classList.toggle('collapsed');
                            return; 
                        }

                        const actionButton = target.closest('button, .back-to-global-btn');
                        if (!actionButton) return;
                        
                        const actions = {
                            '#undo-btn': () => this.undo(),
                            '#redo-btn': () => this.redo(),
                            '#import-btn': () => panel.querySelector('#config-file-input')?.click(),
                            '#export-btn': () => this.exportConfig(false),
                            '#export-template-btn': () => this.exportConfig(true),
                            '#export-png-btn': () => this.exportPNG(),
                            '#load-local-fonts-btn': () => this.loadLocalFonts(),
                            '#upload-font-btn': () => panel.querySelector('#font-upload-input')?.click(),
                            '#manage-fonts-btn': () => this.showFontManager(),
                            '#add-new-tag-btn': () => this.addNewTag(),
                            '#show-texture-picker-btn': () => this.initTexturePicker(),
                            '#clear-texture-btn': () => this.selectTexture(null),
                            '.back-to-global-btn': () => this.setSelection({type: 'global'}),
                            '#reset-btn': () => this.resetToDefault(),
                            '#clear-page-bg-btn': () => {
                                this.updateState('pageStyles.pageBgImageDataUrl', null, true, 'æ¸…é™¤é¡µé¢èƒŒæ™¯å›¾');
                                this.showToast('èƒŒæ™¯å›¾å·²æ¸…é™¤', 'info');
                            },
                            '#pick-color-btn': () => panel.querySelector('#color-thief-upload')?.click(),
                            '#reset-avatar-transform-btn': () => {
                                this.pushHistory('é‡ç½®å¤´åƒä½ç½®ä¸å¤§å°');
                                this.updateState('personalInfo.avatarSize', 100, false);
                                this.updateState('personalInfo.avatarOffsetX', 0, false);
                                this.showToast('å¤´åƒä½ç½®ä¸å¤§å°å·²é‡ç½®', 'info');
                            },
                        };
                        for(const selector in actions) {
                            if (actionButton.matches(selector)) {
                                actions[selector]();
                                return;
                            }
                        }

                        if (actionButton.dataset.preset) this.applyPreset(this.presets[actionButton.dataset.preset]);
                        
                        if (actionButton.dataset.resetKey) {
                            const keyPath = actionButton.dataset.resetKey;
                            const keyMap = { nicknameColor: 'pNicknameColor', subtitleColor: 'pSubtitleColor', bioColor: 'pBioColor', tagBgColor: 'pTagBgColor', tagTextColor: 'pTagTextColor' };
                            const basePreset = this.presets.light;
                            const key = keyPath.split('.')[1];
                            const defaultValue = basePreset[keyMap[key]] || '#ffffff';
                            this.updateState(keyPath, defaultValue, true, 'é‡ç½®é¢œè‰²');
                            this.showToast('é¢œè‰²å·²é‡ç½®', 'info');
                        }
                        
                        const tagItem = target.closest('.tag-manager-item');
                        if (tagItem) {
                            if (target.closest('.tag-icon-btn')) { this.initIconPicker(); this.showIconPicker('tag', tagItem.dataset.tagId); }
                            if (target.closest('.tag-delete-btn')) this.deleteTag(tagItem.dataset.tagId);
                        }
                        
                        const blockEl = target.closest('.editor-block');
                        if (blockEl) {
                            const blockId = blockEl.dataset.blockId;
                            if (target.closest('.block-delete-btn')) { this.deleteBlock(blockId); }
                            else if (target.closest('.add-card-btn')) this.addCard(blockId);
                            else if (target.closest('.add-image-btn')) this.addImageCard(blockId);
                            
                            const cardEl = target.closest('.editor-card');
                            if (cardEl) {
                                const cardId = cardEl.dataset.cardId;
                                if (target.closest('.card-delete-btn')) this.deleteCard(blockId, cardId);
                                else if (target.closest('.card-clear-bg-btn')) {
                                    this.updateCard(blockId, cardId, 'bgImageDataUrl', null, true, 'æ¸…é™¤å¡ç‰‡èƒŒæ™¯å›¾');
                                    this.showToast('å¡ç‰‡èƒŒæ™¯å›¾å·²æ¸…é™¤', 'info');
                                }
                                else if (target.closest('.crop-image-btn')) this.cropImage(blockId, cardId);
                                else if (target.closest('.select-icon-btn')) { 
                                    this.initIconPicker();
                                    this.showIconPicker('card', blockId, cardId);
                                }
                                else if(target.closest('[data-reset-card-key]')) {
                                    const keyToReset = target.closest('[data-reset-card-key]').dataset.resetCardKey;
                                    this.updateCard(blockId, cardId, keyToReset, null, true, 'é‡ç½®å¡ç‰‡æ ·å¼');
                                    this.showToast('å·²é‡ç½®ä¸ºå…¨å±€æ ·å¼', 'info');
                                }
                            } else if (target.closest('.select-icon-btn[data-separator-icon-btn]')) {
                                this.initIconPicker();
                                this.showIconPicker('separator', blockId);
                            } else if (target.closest('[data-reset-block-key]')) {
                                const keyToReset = target.closest('[data-reset-block-key]').dataset.resetBlockKey;
                                this.updateBlockSettings(blockId, keyToReset, null, true, 'é‡ç½®åŒºå—æ ·å¼');
                                this.showToast('å·²é‡ç½®', 'info');
                            }
                        }
                        
                        const tabBtn = target.closest('.tabs .tab-btn');
                        if (tabBtn) {
                            const parent = tabBtn.closest('.tab-group-wrapper, .editor-section > .section-content');
                            if (!parent) return;
                            parent.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                            tabBtn.classList.add('active');
                            parent.querySelectorAll(':scope > .tab-content').forEach(content => content.classList.remove('active'));
                            const targetTab = parent.querySelector(`#${tabBtn.dataset.tab}`);
                            if (targetTab) targetTab.classList.add('active');
                            
                            const newMode = tabBtn.dataset.tab.includes('gradient') ? 'gradient' : 'solid';
                            if (parent.closest('#global-card-styles-section')) {
                                this.updateState('globalCardStyles.bgMode', newMode, true, 'åˆ‡æ¢å…¨å±€å¡ç‰‡èƒŒæ™¯æ¨¡å¼');
                            } else if (parent.closest('#page-styles-section')) {
                                if (tabBtn.dataset.tab.startsWith('page-bg')) {
                                    this.updateState('pageStyles.pageBgMode', newMode, true, 'åˆ‡æ¢é¡µé¢èƒŒæ™¯æ¨¡å¼');
                                } else if (tabBtn.dataset.tab.startsWith('header-bg')) {
                                    this.updateState('pageStyles.headerBgMode', newMode, true, 'åˆ‡æ¢å¤´éƒ¨èƒŒæ™¯æ¨¡å¼');
                                }
                            }
                        }
                    });

                    // å­—ä½“ç®¡ç†å™¨ Modal çš„äº‹ä»¶
                    const fontManagerModal = this.elements.fontManagerModal;
                    fontManagerModal.querySelector('#font-manager-close-btn').addEventListener('click', () => {
                        fontManagerModal.classList.remove('visible');
                    });
                    fontManagerModal.addEventListener('click', e => {
                        const deleteBtn = e.target.closest('.font-delete-btn');
                        if (deleteBtn) {
                            const item = deleteBtn.closest('.font-manager-item');
                            if (item) {
                                this.deleteFont(item.dataset.fontFamily);
                            }
                        }
                    });
                    
                    panel.addEventListener('mouseover', e => {
                        const trigger = e.target.closest('.tooltip-trigger');
                        if (trigger) {
                            const tooltipText = trigger.dataset.tooltip;
                            if (!tooltipText) return;
                            
                            this.tooltipTimeout = setTimeout(() => {
                                let tooltip = document.getElementById('floating-tooltip');
                                if (!tooltip) {
                                    tooltip = document.createElement('div');
                                    tooltip.id = 'floating-tooltip';
                                    document.body.appendChild(tooltip);
                                }
                                tooltip.textContent = tooltipText;
                                
                                const triggerRect = trigger.getBoundingClientRect();
                                tooltip.style.left = `${triggerRect.left + triggerRect.width / 2}px`;
                                tooltip.style.top = `${triggerRect.top - 8}px`; // åœ¨å›¾æ ‡ä¸Šæ–¹ç•™å‡º 8px é—´è·
                                tooltip.style.opacity = '1';
                            }, 300); // å»¶è¿Ÿ 300ms æ˜¾ç¤º
                        }
                    });
                
                    panel.addEventListener('mouseout', e => {
                        const trigger = e.target.closest('.tooltip-trigger');
                        if (trigger) {
                            clearTimeout(this.tooltipTimeout);
                            let tooltip = document.getElementById('floating-tooltip');
                            if (tooltip) {
                                tooltip.style.opacity = '0';
                                // åŠ¨ç”»ç»“æŸåå†ç§»é™¤ï¼Œé¿å…é—ªçƒ
                                setTimeout(() => {
                                    if(tooltip) tooltip.remove();
                                }, 200);
                            }
                        }
                    });
                },

                bindPreviewEvents(){
                     this.elements.previewPanel.addEventListener('click', e => {
                        // NEW: Mobile edit pencil handling
                        const pencil = e.target.closest('.mobile-edit-pencil');
                        if (pencil) {
                            e.preventDefault();
                            e.stopPropagation();
                            const target = pencil.parentElement;
                             if (target.matches('.preview-card-content[data-card-key="content"]')) {
                                this.showRichTextEditor(target);
                            } else if (target.closest('[data-state-key], [data-card-key], [data-tag-text-id], [data-separator-text-key]')) {
                                this.triggerInlineEdit(target);
                            }
                            return;
                        }

                        if (e.target.closest('#preview-avatar')) {
                            if (this.selection.type !== 'personalInfo') {
                                this.setSelection({ type: 'personalInfo' });
                            }
                            setTimeout(() => {
                                const avatarUploadInput = this.elements.inspectorPanel.querySelector('#avatar-upload');
                                if (avatarUploadInput) {
                                    avatarUploadInput.click();
                                }
                            }, 50);
                            return;
                        }

                        if (this.isEditingText) return;
                        
                        const header = e.target.closest('.preview-header');
                        if (header) {
                            this.setSelection({ type: 'personalInfo' });
                            return;
                        }

                        const blockWrapper = e.target.closest('.preview-block-wrapper');
                        if (blockWrapper && blockWrapper.dataset.blockId) {
                            const cardWrapper = e.target.closest('.preview-card, figure');
                            const cardId = cardWrapper ? cardWrapper.dataset.cardId : null;
                            this.setSelection({ type: 'block', id: blockWrapper.dataset.blockId, cardId: cardId });
                            if (cardId) {
                                const cardEditorEl = this.elements.inspectorPanel.querySelector(`.editor-card[data-card-id="${cardId}"]`);
                                if (cardEditorEl) {
                                    cardEditorEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        } else {
                            if (e.target.closest('.preview-wrapper')) {
                                this.setSelection({ type: 'global' });
                            }
                        }
                     });

                     this.elements.previewWrapper.addEventListener('dblclick', e => {
                        // if (window.innerWidth <= 1024) return; // Allow dblclick on mobile
                        if (this.elements.previewBlocksContainer.classList.contains('locked-mode')) return;

                        // --- FEATURE: Rich Text Editor ---
                        const cardContentTarget = e.target.closest('.preview-card-content[data-card-key="content"]');
                        if (cardContentTarget) {
                            this.showRichTextEditor(cardContentTarget);
                            return;
                        }
                        
                        const target = e.target.closest('[data-state-key], [data-card-key], [data-tag-text-id], [data-separator-text-key]');
                        if (target) {
                           this.triggerInlineEdit(target);
                        }
                    });
                    
                    this.elements.previewWrapper.addEventListener('input', e => {
                        const target = e.target;
                        if (target.contentEditable === 'true') {
                            const stateKey = target.dataset.stateKey;
                            const cardKey = target.dataset.cardKey;
                            const separatorKey = target.dataset.separatorTextKey;
                            const tagId = target.dataset.tagTextId;
                            const value = target.innerText;

                            const updateStateObject = (path, val) => {
                                let obj = this.state;
                                const keys = path.split('.');
                                for (let i = 0; i < keys.length - 1; i++) { obj = obj?.[keys[i]]; }
                                if(obj) obj[keys[keys.length - 1]] = val;
                            };

                            if (stateKey) {
                                updateStateObject(stateKey, value);
                                this.syncControl(stateKey);
                            } else if (cardKey) {
                                const cardEl = target.closest('.preview-card, figure');
                                const blockEl = target.closest('.preview-block-wrapper');
                                if (cardEl && blockEl) {
                                    const block = this.findBlock(blockEl.dataset.blockId);
                                    const card = block?.cards.find(c => c.id === cardEl.dataset.cardId);
                                    if(card) card[cardKey] = value;
                                    
                                    const editorInput = this.elements.inspectorPanel.querySelector(`.editor-card[data-card-id="${cardEl.dataset.cardId}"] [data-card-key="${cardKey}"]`);
                                    if(editorInput) editorInput.value = value;
                                    this.renderLayerPanel();
                                }
                            } else if (separatorKey) {
                                const block = this.findBlock(separatorKey);
                                if(block) block.settings.text = value;
                                const editorInput = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${separatorKey}"] [data-setting-key="text"]`);
                                if(editorInput) editorInput.value = value;
                            } else if (tagId) {
                                const tag = this.state.personalInfo.tags.find(t => t.id === tagId);
                                if (tag) {
                                    tag.text = value;
                                    const inspectorInput = this.elements.inspectorPanel.querySelector(`.tag-manager-item[data-tag-id="${tagId}"] .tag-text-input`);
                                    if (inspectorInput) inspectorInput.value = value;
                                }
                            }
                        }
                    });
                },

                triggerInlineEdit(target) {
                    if (!target || this.isEditingText) return;
                    this.isEditingText = true;
                    target.contentEditable = true;
                    target.focus();
                    document.execCommand('selectAll', false, null);

                    const handleEditEnd = () => {
                        target.contentEditable = false;
                        this.isEditingText = false;
                        target.removeEventListener('blur', handleEditEnd);
                        target.removeEventListener('keydown', handleKeydown);
                        
                        this.pushHistory('ç¼–è¾‘æ–‡æœ¬');

                        const blockEl = target.closest('.preview-block-wrapper');
                        if (blockEl && this.masonryInstances[blockEl.dataset.blockId]) {
                            this.masonryInstances[blockEl.dataset.blockId].layout();
                        }
                    };
                    
                    const handleKeydown = (ev) => {
                        if (ev.key === 'Enter' && !ev.shiftKey) {
                            ev.preventDefault();
                            target.blur();
                        }
                    };

                    target.addEventListener('blur', handleEditEnd);
                    target.addEventListener('keydown', handleKeydown);
                },

                initResizer() {
                     const resizer = this.elements.resizer;
                        const inspectorPanel = this.elements.inspectorPanel;
                        let isResizing = false;
                    
                        resizer.addEventListener('mousedown', (e) => {
                            isResizing = true;
                            document.body.style.cursor = 'col-resize';
                            document.body.style.userSelect = 'none';
                    
                            document.addEventListener('mousemove', handleMouseMove);
                            document.addEventListener('mouseup', stopResize);
                        });
                    
                        const handleMouseMove = (e) => {
                            if (!isResizing) return;
                            const newWidth = window.innerWidth - e.clientX;
                            if (newWidth > 350 && newWidth < window.innerWidth * 0.6) {
                                inspectorPanel.style.width = `${newWidth}px`;
                                this.relayoutAllMasonry();
                            }
                        };
                    
                        const stopResize = () => {
                            isResizing = false;
                            document.body.style.cursor = 'default';
                            document.body.style.userSelect = 'auto';
                            document.removeEventListener('mousemove', handleMouseMove);
                            document.removeEventListener('mouseup', stopResize);
                            this.updateExportSizePreview();
                        };
                },

                relayoutAllMasonry() {
                    Object.values(this.masonryInstances).forEach(m => m && m.layout());
                    this.updateExportSizePreview();
                },

                renderAll(isInitial = false) {
                    this.updateGlobalCardStyleVars();
                    this.renderPersonalInfo();
                    this.renderPageStyles();
                    this.renderLayerPanel();
                    this.renderInspector();
                    this.renderPreviewBlocks();
                    this.renderMobileEditPencils();
                },
                
                async renderPersonalInfo() {
                    const info = this.state.personalInfo;
                    
                    const setAvatarSrc = async (url) => {
                        if (url && url.startsWith('idb://')) {
                            try {
                                const imageId = url.substring(6);
                                const imageRecord = await this.getImageFromDB(imageId);
                                if (imageRecord && imageRecord.blob) {
                                    this.elements.previewAvatar.src = URL.createObjectURL(imageRecord.blob);
                                } else {
                                    this.elements.previewAvatar.src = this.getDefaultState().personalInfo.avatarDataUrl; // Fallback
                                }
                            } catch (e) {
                                console.error('Failed to load avatar from DB', e);
                                this.elements.previewAvatar.src = this.getDefaultState().personalInfo.avatarDataUrl;
                            }
                        } else {
                            this.elements.previewAvatar.src = url || this.getDefaultState().personalInfo.avatarDataUrl;
                        }
                    };
                    await setAvatarSrc(info.avatarDataUrl);

                    this.elements.previewNickname.textContent = info.nickname;
                    this.elements.previewSubtitle.textContent = info.subtitle;
                    this.elements.previewBio.textContent = info.bio;
                    
                    this.elements.previewNickname.style.color = info.nicknameColor;
                    this.elements.previewSubtitle.style.color = info.subtitleColor;
                    this.elements.previewBio.style.color = info.bioColor;

                    const baseSize = 90;
                    const newSize = baseSize * ((info.avatarSize || 100) / 100);
                    const offsetX = info.avatarOffsetX || 0;
                    this.elements.previewAvatar.style.width = `${newSize}px`;
                    this.elements.previewAvatar.style.height = `${newSize}px`;
                    this.elements.previewAvatar.style.transform = `translateX(${offsetX}%)`;

                    this.elements.previewAvatar.style.borderRadius = info.avatarShape;
                    this.elements.previewAvatar.style.borderWidth = `${info.avatarBorderSize}px`;
                    this.elements.previewAvatar.style.borderColor = info.avatarBorderColor;
                    
                    this.elements.previewHeader.style.boxShadow = 'none';

                    this.elements.previewTagsContainer.innerHTML = (info.tags || [])
                        .map(tag => {
                            const iconHTML = tag.icon ? `<span class="iconify" data-icon="${tag.icon}"></span>` : '';
                            return `<span class="tag-pill" style="background-color:${info.tagBgColor}; color:${info.tagTextColor};">${iconHTML}<span data-tag-text-id="${tag.id}">${this.escapeHTML(tag.text)}</span></span>`;
                        }).join('');
                },
                
                async renderPageStyles() {
                    const styles = this.state.pageStyles;
                    const wrapper = this.elements.previewWrapper;
                    
                    let bgLayers = [];
                    let bgSizes = [];
                    let bgPositions = [];
                    let bgColor = 'transparent';

                    if (styles.pageBgPattern) {
                        const pattern = HeroPatterns.find(p => p.name === styles.pageBgPattern);
                        if(pattern) {
                            const coloredSvg = pattern.svg(styles.pageBgPatternColor, styles.pageBgPatternOpacity);
                            const base64Svg = btoa(unescape(encodeURIComponent(coloredSvg)));
                            bgLayers.push(`url("data:image/svg+xml;base64,${base64Svg}")`);
                            bgSizes.push(`${styles.pageBgPatternDensity}px`);
                            bgPositions.push('center');
                        }
                    }

                    if (styles.pageBgImageDataUrl) {
                        let imageUrl = styles.pageBgImageDataUrl;
                        if (imageUrl.startsWith('idb://')) {
                            try {
                                const imageId = imageUrl.substring(6);
                                const imageRecord = await this.getImageFromDB(imageId);
                                if (imageRecord && imageRecord.blob) {
                                    imageUrl = URL.createObjectURL(imageRecord.blob);
                                }
                            } catch(e) { console.error('Failed to load page background from DB', e); }
                        }

                        const overlayOpacity = parseFloat(styles.pageOverlayOpacity);
                        if (overlayOpacity > 0) {
                            const finalOverlayColor = this.hexToRgba(styles.pageOverlayColor, overlayOpacity);
                            bgLayers.push(`linear-gradient(${finalOverlayColor}, ${finalOverlayColor})`);
                            bgSizes.push('cover');
                            bgPositions.push('center');
                        }
                        bgLayers.push(`url(${imageUrl})`);
                        bgSizes.push('cover');
                        bgPositions.push('center');
                    }
                    
                    if (styles.pageBgMode === 'gradient') {
                        bgLayers.push(`linear-gradient(${styles.pageBgGradientAngle}deg, ${styles.pageBgGradientStart}, ${styles.pageBgGradientEnd})`);
                        bgSizes.push('cover');
                        bgPositions.push('center');
                    } else {
                        bgColor = styles.pageBgSolidColor;
                    }

                    wrapper.style.backgroundColor = bgColor;
                    wrapper.style.backgroundImage = bgLayers.join(', ');
                    wrapper.style.backgroundSize = bgSizes.join(', ');
                    wrapper.style.backgroundPosition = bgPositions.join(', ');

                    if (styles.headerBgMode === 'gradient') {
                        const gradient = `linear-gradient(${styles.headerBgGradientAngle}deg, ${this.hexToRgba(styles.headerBgGradientStart, styles.headerOpacity)}, ${this.hexToRgba(styles.headerBgGradientEnd, styles.headerOpacity)})`;
                        this.elements.previewHeader.style.background = gradient;
                    } else {
                        this.elements.previewHeader.style.background = this.hexToRgba(styles.headerBgColor, styles.headerOpacity);
                    }
                    
                    // --- FEATURE: Header Border Radius ---
                    this.elements.previewHeader.style.borderRadius = `${styles.headerBorderRadius}px`;

                    this.elements.previewNickname.style.color = this.state.personalInfo.nicknameColor;
                    this.elements.previewSubtitle.style.color = this.state.personalInfo.subtitleColor;
                    this.elements.previewBio.style.color = this.state.personalInfo.bioColor;
                },

                renderLayerPanel() {
                    const list = this.elements.layerList;
                    const {type, id, cardId} = this.selection;
                    
                    let html = `<div class="layer-item-container">
                                    <div class="layer-item ${type === 'personalInfo' ? 'selected' : ''}" data-type="personalInfo">
                                        <button class="layer-toggle"></button>
                                        <span class="layer-icon iconify" data-icon="mdi:account-circle-outline"></span>
                                        <span class="layer-name">ä¸ªäººä¿¡æ¯</span>
                                    </div>
                               </div><hr>`;

                    html += this.state.blocks.map(b => {
                        const iconMap = { text: 'mdi:format-text-variant-outline', image: 'mdi:image-multiple-outline', separator: 'mdi:minus', spacer: 'mdi:arrow-expand-vertical' };
                        const isHidden = b.isVisible === false;
                        const isExpandable = (b.type === 'text' || b.type === 'image') && b.cards && b.cards.length > 0;
                        const isExpanded = b.isExpanded ? 'is-expanded' : '';
                        const hasQuickAdd = (b.type === 'text' || b.type === 'image');
                        
                        const cardsListHTML = isExpandable ? `<ul class="card-layer-list" data-block-id="${b.id}">
                            ${b.cards.map(c => `<li class="card-layer-item ${cardId === c.id ? 'selected' : ''}" data-card-id="${c.id}">${this.escapeHTML(c.title) || 'æ— æ ‡é¢˜å¡ç‰‡'}</li>`).join('')}
                        </ul>` : '';

                        const quickAddBtn = hasQuickAdd ? `<button class="btn-icon add-card-to-block-btn" title="æ·»åŠ å¡ç‰‡/å›¾ç‰‡"><span class="iconify" data-icon="mdi:plus"></span></button>` : '';

                        return `<div class="layer-item-container ${isExpandable ? 'is-expandable' : ''} ${isExpanded}" data-block-id="${b.id}">
                                    <div class="layer-item ${type === 'block' && id === b.id ? 'selected' : ''} ${isHidden ? 'is-hidden': ''}" data-type="block" data-id="${b.id}">
                                        <button class="layer-toggle"><span class="iconify" data-icon="mdi:chevron-right"></span></button>
                                        <span class="layer-icon iconify" data-icon="${iconMap[b.type]}"></span>
                                        <span class="layer-name">${this.escapeHTML(b.title)}</span>
                                        <div class="layer-actions">
                                            ${quickAddBtn}
                                            <button class="btn-icon toggle-visibility-btn" title="åˆ‡æ¢æ˜¾ç¤º/éšè—"><span class="iconify" data-icon="${isHidden ? 'mdi:eye-off' : 'mdi:eye'}"></span></button>
                                            <button class="btn-icon duplicate-block-btn" title="å¤åˆ¶æ ·å¼"><span class="iconify" data-icon="mdi:content-copy"></span></button>
                                        </div>
                                    </div>
                                    ${cardsListHTML}
                                </div>`;
                    }).join('');
                    
                    list.innerHTML = html;
                    this.initNestedSortables();
                },

                renderInspector() {
                    const panel = this.elements.inspectorPanel;
                    const { type, id } = this.selection;
                    let html = '';

                    switch(type) {
                        case 'personalInfo':
                            html = this.createPersonalInfoInspectorHTML();
                            break;
                        case 'block':
                            const block = this.findBlock(id);
                            if (block) html = this.createEditorBlockHTML(block);
                            break;
                        default:
                            html = this.createGlobalInspectorHTML();
                    }

                    panel.innerHTML = html;

                    panel.querySelectorAll('.editor-section').forEach(section => {
                        if (section.id) {
                            const isOpen = localStorage.getItem(`blokko-advanced-${section.id}`) === 'true';
                            if (isOpen) {
                                section.classList.add('show-advanced');
                                const toggle = section.querySelector('.advanced-toggle');
                                if (toggle) toggle.checked = true;
                            }
                        }
                    });
                    
                    if (this.selection.type === 'global') {
                        this.populateFontList();
                        this.bindColorThiefEvents();
                        if (this.lastPalette && this.lastPalette.length > 0) {
                            this.renderPalette(this.lastPalette);
                        }
                    }
                    
                    panel.querySelectorAll('.thumbnail-wrapper img').forEach(img => {
                        const cardEl = img.closest('.editor-card');
                        if (!cardEl) return;
                        const cardId = cardEl.dataset.cardId;
                        const blockEl = img.closest('.editor-block');
                        if (!blockEl) return;
                        const blockId = blockEl.dataset.blockId;
                        const block = this.findBlock(blockId);
                        const card = block?.cards.find(c => c.id === cardId);
                        if (card && card.url) {
                            const setSrc = async (url) => {
                                if (url && url.startsWith('idb://')) {
                                    const imageId = url.substring(6);
                                    const record = await this.getImageFromDB(imageId);
                                    if (record && record.blob) img.src = URL.createObjectURL(record.blob);
                                } else {
                                    img.src = url;
                                }
                            };
                            setSrc(card.url);
                        }
                    });

                    this.syncAllControls();
                    this.updateUndoRedoButtons();

                    if (type === 'block') {
                        const block = this.findBlock(id);
                        if (block.type === 'text') {
                            this.initSortableCards(id);
                        } else if (block.type === 'image') {
                            this.initSortableImageCards(id);
                        }
                    } else if (type === 'personalInfo') {
                        this.renderTagManager();
                        this.initSortableTags();
                    }
                },

                createGlobalInspectorHTML() {
                    const backBtn = this.selection.type !== 'global' ? `<button class="back-to-global-btn">â† è¿”å›å…¨å±€</button>` : '';
                    const headerBorderRadiusHTML = `
                        <div class="form-group advanced-setting">
                            <label>å¤´éƒ¨åœ†è§’ (px): <span class="header-radius-value">16</span></label>
                            <div class="input-group simple stepper-group">
                                <button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button>
                                <input type="range" data-state-key="pageStyles.headerBorderRadius" min="0" max="50" step="1">
                                <button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button>
                            </div>
                        </div>`;

                    return `
                        <h3 class="panel-header">å…¨å±€æ ·å¼ä¸å¯¼å‡º ${backBtn}</h3>
                        <div class="inspector-state active">
                             <fieldset class="editor-section" id="page-styles-section">
                                <legend>é¡µé¢ä¸å¤´éƒ¨æ ·å¼</legend>
                                <div class="section-content">
								 <div class="tab-group-wrapper">
                                 <div class="section-header" style="margin-bottom: 5px;">
                                 <h4 style="margin: 0;">å¤´éƒ¨èƒŒæ™¯</h4>
                                 <label class="checkbox-group advanced-toggle-label"><input type="checkbox" class="advanced-toggle"> é«˜çº§</label>
                                    </div>
                                        <div class="tabs"><button class="tab-btn" data-tab="header-bg-solid">çº¯è‰²</button><button class="tab-btn advanced-setting" data-tab="header-bg-gradient">æ¸å˜</button></div>
                                        <div id="header-bg-solid" class="tab-content"><div class="form-group"><label>å¤´éƒ¨èƒŒæ™¯é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerBgColor"><input type="text" class="color-hex-input" data-state-key="pageStyles.headerBgColor"></div></div></div>
                                        <div id="header-bg-gradient" class="tab-content advanced-setting"><div class="gradient-controls"><div class="form-group"><label>èµ·å§‹é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerBgGradientStart"><input type="text" class="color-hex-input" data-state-key="pageStyles.headerBgGradientStart"></div></div><div class="form-group"><label>ç»“æŸé¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.headerBgGradientEnd"><input type="text" class="color-hex-input" data-state-key="pageStyles.headerBgGradientEnd"></div></div><div class="gradient-angle-control form-group"><label>è§’åº¦ (<span class="angle-value">135</span>Â°):<span class="tooltip-trigger" data-tooltip="è®¾ç½®æ¸å˜çš„æ–¹å‘ï¼Œ0åº¦ä¸ºä»ä¸‹åˆ°ä¸Šï¼Œ90åº¦ä¸ºä»å·¦åˆ°å³ã€‚"><span class="iconify" data-icon="mdi:help-circle-outline"></span></span></label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="pageStyles.headerBgGradientAngle" min="0" max="360" step="1"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div></div></div>
                                        <div class="form-group advanced-setting"><label>å¤´éƒ¨ä¸é€æ˜åº¦:</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="pageStyles.headerOpacity" min="0" max="1" step="0.05"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div>
                                        ${headerBorderRadiusHTML}
                                    </div>
								<hr class="separator">
                                    <div class="tab-group-wrapper">
                                        <div class="section-header" style="margin-bottom: 5px;">
                                            <h4 style="margin: 0;">é¡µé¢èƒŒæ™¯</h4>   
                                        </div>
                                        <div class="tabs"><button class="tab-btn" data-tab="page-bg-solid">çº¯è‰²/å›¾ç‰‡</button><button class="tab-btn advanced-setting" data-tab="page-bg-gradient">æ¸å˜</button></div>
                                        <div id="page-bg-solid" class="tab-content">
                                            <div class="form-group"><label>é¡µé¢èƒŒæ™¯é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgSolidColor"><input type="text" class="color-hex-input" data-state-key="pageStyles.pageBgSolidColor"></div></div>
                                            <div class="form-group"><label>èƒŒæ™¯å›¾ (å¯é€‰):</label><div class="input-group simple"><input type="file" id="page-bg-upload" accept="image/*" style="width:100%"><button id="clear-page-bg-btn" class="btn btn-default btn-small">æ¸…é™¤</button></div></div>
                                            <div id="page-image-controls" class="advanced-setting">
                                                <div class="form-group"><label>å›¾ç‰‡é®ç½©é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageOverlayColor"><input type="text" class="color-hex-input" data-state-key="pageStyles.pageOverlayColor"></div></div>
                                                <div class="form-group"><label>å›¾ç‰‡é®ç½©ä¸é€æ˜åº¦:</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="pageStyles.pageOverlayOpacity" min="0" max="1" step="0.05"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div>
                                            </div>
                                        </div>
                                        <div id="page-bg-gradient" class="tab-content advanced-setting"><div class="gradient-controls"><div class="form-group"><label>èµ·å§‹é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgGradientStart"><input type="text" class="color-hex-input" data-state-key="pageStyles.pageBgGradientStart"></div></div><div class="form-group"><label>ç»“æŸé¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgGradientEnd"><input type="text" class="color-hex-input" data-state-key="pageStyles.pageBgGradientEnd"></div></div><div class="gradient-angle-control form-group"><label>è§’åº¦ (<span class="angle-value">135</span>Â°):</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="pageStyles.pageBgGradientAngle" min="0" max="360" step="1"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div></div></div>
                                        <div class="advanced-setting" style="margin-top: 10px;">
                                            <div class="form-group"><button id="show-texture-picker-btn" class="btn btn-default">ğŸ¨ æ·»åŠ çº¹ç†</button></div>
                                            <div id="page-texture-controls" class="inset-controls"><div class="form-group"><label>å½“å‰çº¹ç†: <span id="current-texture-name">æ— </span></label><button id="clear-texture-btn" class="btn btn-default btn-small">æ¸…é™¤çº¹ç†</button></div><div class="color-control-row"><div class="color-control-group"><label>çº¹ç†é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="pageStyles.pageBgPatternColor"><input type="text" class="color-hex-input" data-state-key="pageStyles.pageBgPatternColor"></div></div><div class="color-control-group"><label>çº¹ç†ä¸é€æ˜åº¦:</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="pageStyles.pageBgPatternOpacity" min="0" max="1" step="0.05"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div></div><div class="form-group"><label>çº¹ç†å¯†åº¦:</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="pageStyles.pageBgPatternDensity" min="10" max="100" step="2"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div></div>
                                        </div>
                                    </div>
                                </div>
                            </fieldset>
                            <fieldset class="editor-section" id="color-thief-section">
                                <legend>ğŸ¨ æ™ºèƒ½å–è‰²</legend>
                                <div class="section-content">
                                    <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: -10px; margin-bottom: 15px;">ä¸Šä¼ å›¾ç‰‡ï¼Œè‡ªåŠ¨æå–è°ƒè‰²æ¿ã€‚å³é”® (PC) æˆ–é•¿æŒ‰ (æ‰‹æœº) è‰²å—å¯å¿«æ·åº”ç”¨ã€‚</p>
                                    <button id="pick-color-btn" class="btn btn-default">ä¸Šä¼ å›¾ç‰‡åˆ†æé¢œè‰²</button>
                                    <input type="file" id="color-thief-upload" accept="image/*" style="display: none;">
                                    <div class="palette-container" id="color-thief-palette"></div>
                                </div>
                            </fieldset>
                            <fieldset class="editor-section" id="global-card-styles-section"> 
                                <legend>å…¨å±€å¡ç‰‡æ ·å¼</legend>
                                <div class="section-content">
                                    <div style="text-align: right; margin-bottom: 10px;">
                                        <label class="checkbox-group advanced-toggle-label"><input type="checkbox" class="advanced-toggle"> é«˜çº§</label>
                                    </div>
                                    <div class="tabs"><button class="tab-btn" data-tab="card-bg-solid">çº¯è‰²</button><button class="tab-btn advanced-setting" data-tab="card-bg-gradient">æ¸å˜</button></div>
                                    <div id="card-bg-solid" class="tab-content"><div class="color-control-row"><div class="color-control-group"><label>èƒŒæ™¯è‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.bgColor"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.bgColor"></div></div><div class="color-control-group"><label>æ–‡å­—é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.textColor"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.textColor"></div></div></div></div>
                                    <div id="card-bg-gradient" class="tab-content advanced-setting"><div class="gradient-controls"><div class="form-group"><label>èµ·å§‹é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.bgGradientStart"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.bgGradientStart"></div></div><div class="form-group"><label>ç»“æŸé¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.bgGradientEnd"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.bgGradientEnd"></div></div><div class="gradient-angle-control form-group"><label>è§’åº¦ (<span class="angle-value">135</span>Â°):</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="globalCardStyles.bgGradientAngle" min="0" max="360" step="1"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div></div></div>
                                    <div class="form-group"><label>ä¸é€æ˜åº¦:</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="globalCardStyles.opacity" min="0" max="1" step="0.05"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div>
                                    <div class="form-group advanced-setting"><label>åœ†è§’ (px): <span id="gCardRadiusValue">12</span></label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="globalCardStyles.radius" min="0" max="40" step="1"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div>
                                    <div class="advanced-setting"><hr class="separator"><label>å¡ç‰‡è¾¹æ¡†:<span class="tooltip-trigger" data-tooltip="è¾¹æ¡†åœ¨ç¼–è¾‘å™¨é¢„è§ˆåŒºå¯èƒ½æ˜¾ç¤ºä¸å®Œç¾ï¼ˆå¦‚äº§ç”Ÿç¼éš™ï¼‰ï¼Œä½†åœ¨æœ€ç»ˆå¯¼å‡ºçš„å›¾ç‰‡ä¸­æ˜¯æ­£å¸¸çš„ã€‚"><span class="iconify" data-icon="mdi:help-circle-outline"></span></span></label><div class="form-group inset-controls"><div class="form-group"><label>æ ·å¼:</label><select data-state-key="globalCardStyles.borderStyle"><option value="none">æ— </option><option value="solid">å®çº¿</option><option value="dashed">è™šçº¿</option><option value="dotted">ç‚¹çŠ¶</option><option value="double">åŒå®çº¿</option></select></div><div class="color-control-row"><div class="color-control-group"><label>ç²—ç»†(px):</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="globalCardStyles.borderWidth" min="0" max="10" step="1"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div><div class="color-control-group"><label>é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.borderColor"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.borderColor"></div></div></div></div></div>
                                    <hr class="separator"><div class="form-group"><label>å¯¹é½:</label><div class="radio-group"><label><input type="radio" name="gCardAlign" value="left" data-state-key="globalCardStyles.textAlign">å±…å·¦</label><label><input type="radio" name="gCardAlign" value="center" data-state-key="globalCardStyles.textAlign">å±…ä¸­</label><label><input type="radio" name="gCardAlign" value="right" data-state-key="globalCardStyles.textAlign">å±…å³</label></div></div>
                                    <div class="form-group"><label>è¡Œé«˜:</label><div class="radio-group"><label><input type="radio" name="gCardLineHeight" value="1.4" data-state-key="globalCardStyles.lineHeight">ç´§å‡‘</label><label><input type="radio" name="gCardLineHeight" value="1.5" data-state-key="globalCardStyles.lineHeight">ä¸­ç­‰</label><label><input type="radio" name="gCardLineHeight" value="1.6" data-state-key="globalCardStyles.lineHeight">å®½æ¾</label></div></div>
                                    <hr class="separator"><div class="form-group"><label>å­—ä½“:</label><div class="font-controls"><input type="text" id="font-search-input" placeholder="æœç´¢æœ¬åœ°å­—ä½“..." style="margin-bottom: 5px;"><select id="font-family-select" data-state-key="globalCardStyles.fontFamily"></select><div class="buttons"><button id="load-local-fonts-btn" class="btn btn-default">åŠ è½½æœ¬åœ°</button><button id="upload-font-btn" class="btn btn-default">ä¸Šä¼ å­—ä½“</button><button id="manage-fonts-btn" class="btn btn-default">ç®¡ç†</button></div><input type="file" id="font-upload-input" accept=".ttf,.woff,.woff2,.otf" style="display: none;"></div></div>
                                    <div class="form-group"> <label>å­—å·:</label> <select data-state-key="globalCardStyles.fontSize"> <option value="0.9rem">å°</option> <option value="1rem" selected>ä¸­ (é»˜è®¤)</option> <option value="1.1rem">å¤§</option> </select> </div>
                                    <div class="advanced-setting"><label>æ–‡å­—æè¾¹:<span class="tooltip-trigger" data-tooltip="ä¸ºæ–‡å­—æ·»åŠ è¾¹æ¡†ï¼Œå»ºè®®å®½åº¦ä¸è¶…è¿‡2pxï¼Œä»¥ä¿è¯å¯è¯»æ€§ã€‚"><span class="iconify" data-icon="mdi:help-circle-outline"></span></span></label><div class="color-control-row"><div class="color-control-group"><label>ç²—ç»†(px):</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="globalCardStyles.textStrokeWidth" min="0" max="5" step="0.5"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div><div class="color-control-group"><label>é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="globalCardStyles.textStrokeColor"><input type="text" class="color-hex-input" data-state-key="globalCardStyles.textStrokeColor"></div></div></div></div>
                                </div>
                            </fieldset>
                            <fieldset class="editor-section" id="export-section">
                                <legend>æ“ä½œ</legend>
                                <div class="section-content">
                                    <div class="form-group" style="display: flex; gap: 10px;"> <button id="undo-btn" class="btn btn-default" disabled>æ’¤å›</button> <button id="redo-btn" class="btn btn-default" disabled>é‡åš</button> </div>
                                    <div class="form-group" style="display: flex; gap: 10px;"> <button id="import-btn" class="btn btn-secondary">å¯¼å…¥é…ç½®</button> <button id="export-btn" class="btn btn-secondary">å¯¼å‡ºé…ç½®</button> <button id="export-template-btn" class="btn btn-secondary">å­˜ä¸ºæ¨¡æ¿</button></div>
                                    <div class="form-group">
                                        <div class="checkbox-group" style="margin-bottom: 10px;"><label><input type="checkbox" id="hd-export-toggle"> è¶…æ¸…å¯¼å‡º (1800px)</label></div>
                                        <div class="checkbox-group" style="margin-bottom: 10px;"><label><input type="checkbox" id="custom-width-toggle"> è‡ªå®šä¹‰å®½åº¦</label><input type="number" id="custom-width-input" value="1200" style="width: 80px; padding: 4px 8px;" disabled></div>
                                        <div class="checkbox-group" style="margin-bottom: 10px;"><label><input type="checkbox" id="export-rounded-corners-toggle"> å¯¼å‡ºä¸ºåœ†è§’å›¾ç‰‡</label><input type="number" id="export-corner-radius-input" value="20" style="width: 60px; padding: 4px 8px;" disabled></div>
                                        <div id="export-size-preview" style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 5px;"></div>
                                        <button id="export-png-btn" class="btn btn-primary" style="margin-top:10px;">å¯¼å‡ºä¸ºå›¾ç‰‡ (1200px)</button>
                                    </div>
                                    <hr class="separator"><div class="form-group"><label>é¢„è®¾ä¸»é¢˜:</label><div class="input-group simple"> <button data-preset="light" class="btn btn-default btn-small">æ˜äº®</button> <button data-preset="dark" class="btn btn-default btn-small">æš—é»‘</button> <button data-preset="mint" class="btn btn-default btn-small">è–„è·</button> <button data-preset="coffee" class="btn btn-default btn-small">å’–å•¡</button> </div></div>
                                    <div class="form-group"><button id="reset-btn" class="btn btn-danger">æ¢å¤é»˜è®¤æ¨¡æ¿</button></div>
                                    <input type="file" id="config-file-input" accept=".json" style="display: none;">
                                </div>
                            </fieldset>
                        </div>
                    `;
                },

                createPersonalInfoInspectorHTML() {
                    const backBtn = this.selection.type !== 'global' ? `<button class="back-to-global-btn">â† è¿”å›å…¨å±€</button>` : '';
                    return `
                        <h3 class="panel-header">ä¸ªäººä¿¡æ¯è®¾ç½® ${backBtn}</h3>
                        <div class="inspector-state active">
                             <fieldset class="editor-section" id="personal-info-section">
                                <legend>ä¸ªäººä¿¡æ¯</legend>
                                <div class="section-content">
                                    <div style="text-align: right; margin-bottom: 10px;">
                                        <label class="checkbox-group advanced-toggle-label"><input type="checkbox" class="advanced-toggle"> é«˜çº§</label>
                                    </div>
                                    <div class="form-group"><label>å¤´åƒä¸Šä¼  (ç‚¹å‡»å·¦ä¾§é¢„è§ˆåŒºçš„å¤´åƒä¹Ÿå¯ä¸Šä¼ ):</label><input type="file" id="avatar-upload" accept="image/*"></div>
                                    <div class="form-group advanced-setting"><label>å¤´åƒå½¢çŠ¶:</label><div class="radio-group"><label><input type="radio" name="avatarShape" value="50%" data-state-key="personalInfo.avatarShape">åœ†å½¢</label><label><input type="radio" name="avatarShape" value="16px" data-state-key="personalInfo.avatarShape">åœ†è§’</label><label><input type="radio" name="avatarShape" value="0px" data-state-key="personalInfo.avatarShape">æ–¹å½¢</label></div></div>
                                    <div class="form-group advanced-setting"><label>å¤´åƒè¾¹æ¡†:</label><div class="color-control-row"><div class="color-control-group"><label>ç²—ç»†(px):</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="personalInfo.avatarBorderSize" min="0" max="10" step="1"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div><div class="color-control-group"><label>é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="personalInfo.avatarBorderColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.avatarBorderColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.avatarBorderColor">é‡ç½®</button></div></div></div></div>
                                    <hr class="separator advanced-setting">
                                    <div class="form-group advanced-setting"><label>å¤´åƒå¤§å° (%): <span class="avatar-size-value">100</span></label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="personalInfo.avatarSize" min="50" max="200" step="1"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div>
                                    <div class="form-group advanced-setting"><label>å¤´åƒæ°´å¹³ä½ç½®:</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-state-key="personalInfo.avatarOffsetX" min="-100" max="100" step="1"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div>
                                    <div class="form-group advanced-setting"><button id="reset-avatar-transform-btn" class="btn btn-default btn-small">æ¢å¤é»˜è®¤ä½ç½®ä¸å¤§å°</button></div>
                                    <hr class="separator">
                                    <div class="form-group"><label>æ˜µç§°:</label><input type="text" data-state-key="personalInfo.nickname" data-preview-target="#preview-nickname"></div>
                                    <div class="form-group"><label>æ˜µç§°é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="personalInfo.nicknameColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.nicknameColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.nicknameColor">é‡ç½®</button></div></div>
                                    <div class="form-group"><label>å‰¯æ ‡é¢˜ (å¯é€‰):</label><input type="text" data-state-key="personalInfo.subtitle" data-preview-target="#preview-subtitle"></div>
                                    <div class="form-group advanced-setting"><label>å‰¯æ ‡é¢˜é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="personalInfo.subtitleColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.subtitleColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.subtitleColor">é‡ç½®</button></div></div>
                                    <div class="form-group"><label>ç®€ä»‹ (å¯é€‰):</label><textarea data-state-key="personalInfo.bio" rows="3" data-preview-target="#preview-bio"></textarea></div>
                                    <div class="form-group advanced-setting"><label>ç®€ä»‹é¢œè‰²:</label><div class="input-group"><input type="color" data-state-key="personalInfo.bioColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.bioColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.bioColor">é‡ç½®</button></div></div>
                                    <hr class="separator">
                                    <div class="form-group"><label>æ ‡ç­¾ç®¡ç†å™¨ (å¯ç‚¹å‡»æ ‡ç­¾å‰æ‹–æ‹½æ’åº):</label><div id="tag-manager-list"></div><div class="input-group simple" style="margin-top: 10px;"><input type="text" id="new-tag-text-input" placeholder="è¾“å…¥æ–°æ ‡ç­¾æ–‡å­—..."><button id="add-new-tag-btn" class="btn btn-default btn-small">æ·»åŠ æ ‡ç­¾</button></div></div>
                                    <div class="form-group advanced-setting"><label>æ ‡ç­¾æ ·å¼:</label><div class="color-control-row"><div class="color-control-group"><label>èƒŒæ™¯</label><div class="input-group"><input type="color" data-state-key="personalInfo.tagBgColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.tagBgColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.tagBgColor">é‡ç½®</button></div></div><div class="color-control-group"><label>æ–‡å­—</label><div class="input-group"><input type="color" data-state-key="personalInfo.tagTextColor"><input type="text" class="color-hex-input" data-state-key="personalInfo.tagTextColor"><button class="btn btn-default btn-small" data-reset-key="personalInfo.tagTextColor">é‡ç½®</button></div></div></div></div>
                                </div>
                            </fieldset>
                        </div>
                    `;
                },

                renderPreviewBlocks() {
                    this.elements.previewBlocksContainer.innerHTML = this.state.blocks.length ? this.state.blocks.map(b => `<div class="preview-block-wrapper ${b.isVisible === false ? 'is-hidden' : ''}" data-block-id="${b.id}">${this.createPreviewBlockHTML(b)}</div>`).join('') : '<div class="empty-placeholder">(é¢„è§ˆåŒº) æ— åŒºå—</div>';
                    this.postRenderAsyncUpdates(this.elements.previewBlocksContainer);
                    this.state.blocks.forEach(b => this.initMasonryForBlock(b.id));
                    this.updateHighlights();
                    this.renderMobileEditPencils();
                },

                createEditorBlockHTML(block) {
                    let content = '';
                    const backBtn = this.selection.type !== 'global' ? `<button class="back-to-global-btn">â† è¿”å›å…¨å±€</button>` : '';
                    const masonryCheckboxHTML = `
                        <div class="masonry-toggle-container" style="${['dual', 'triple'].includes(block.settings.layout) ? 'display: block;' : 'display: none;'}">
                            <div class="checkbox-group" style="margin-top: 10px;">
                                <label><input type="checkbox" data-setting-key="masonryEnabled" ${block.settings.masonryEnabled ? 'checked' : ''}> å¯ç”¨ç€‘å¸ƒæµ
                                <span class="tooltip-trigger" data-tooltip="ä½¿å¡ç‰‡é«˜åº¦è‡ªé€‚åº”å†…å®¹ï¼Œå®ç°ç´§å‡‘çš„ç Œä½“å¼å¸ƒå±€ã€‚é€‚åˆå›¾ç‰‡æˆ–æ–‡å­—é•¿çŸ­ä¸ä¸€çš„åœºæ™¯ã€‚"><span class="iconify" data-icon="mdi:help-circle-outline"></span></span>
                                </label>
                            </div>
                        </div>`;
                    const layoutRadiosHTML = `
                        <div class="radio-group">
                            <label><input type="radio" data-setting-key="layout" name="block-layout-${block.id}" value="single" ${block.settings.layout === 'single' ? 'checked' : ''}> å•æ’</label>
                            <label><input type="radio" data-setting-key="layout" name="block-layout-${block.id}" value="dual" ${block.settings.layout === 'dual' ? 'checked' : ''}> åŒæ’</label>
                            <label><input type="radio" data-setting-key="layout" name="block-layout-${block.id}" value="triple" ${block.settings.layout === 'triple' ? 'checked' : ''}> ä¸‰æ’</label>
                        </div>`;

                    if (block.type === 'text') {
                        let cardsHTML = !block.cards?.length ? '<div class="empty-placeholder">æš‚æ— å¡ç‰‡</div>' : block.cards.map(c => `<div class="editor-card ${this.selection.cardId === c.id ? 'is-active' : ''}" data-card-id="${c.id}">${this.createEditorCardHTML(c)}</div>`).join('');
                        content = `<div class="form-group"><label>å¸ƒå±€:</label>${layoutRadiosHTML}${masonryCheckboxHTML}</div>
                                   <hr class="separator"><div class="card-editors-list">${cardsHTML}</div><button class="btn btn-default add-card-btn" style="margin-top: 15px;">â• æ·»åŠ å¡ç‰‡</button>`;
                    } else if (block.type === 'image') {
                        let imageCardsHTML = !block.cards?.length ? '<div class="empty-placeholder">æš‚æ— å›¾ç‰‡</div>' : block.cards.map(c => `<div class="editor-card ${this.selection.cardId === c.id ? 'is-active' : ''}" data-card-id="${c.id}">${this.createEditorImageCardHTML(c)}</div>`).join('');
                        content = `<div class="form-group"><label>å¸ƒå±€:</label>${layoutRadiosHTML}${masonryCheckboxHTML}</div>
                                   <div class="form-group"><label>æ–‡å­—é¢œè‰²:</label><div class="input-group"><input type="color" data-setting-key="textColor" value="${block.settings.textColor || ''}"><input type="text" class="color-hex-input" data-setting-key="textColor" value="${block.settings.textColor || ''}" placeholder="å…¨å±€é»˜è®¤"><button class="btn btn-default btn-small" data-reset-block-key="textColor">é‡ç½®</button></div></div>
                                   <hr class="separator"><div class="image-card-editors-list">${imageCardsHTML}</div><button class="btn btn-default add-image-btn" style="margin-top: 15px;">â• æ·»åŠ å›¾ç‰‡</button>
                                   <input type="file" class="image-upload-input" multiple accept="image/*" style="display: none;">`;
                    } else if (block.type === 'separator') {
                        const s = block.settings;
                        const iconHTML = s.icon ? `<span class="iconify" data-icon="${s.icon}"></span>` : 'é€‰æ‹©å›¾æ ‡';
                        content = `<div class="form-group"><label>æ ·å¼:</label><div class="radio-group"><label><input type="radio" name="sep-style-${block.id}" data-setting-key="style" value="solid" ${s.style==='solid'?'checked':''}>å®çº¿</label><label><input type="radio" name="sep-style-${block.id}" data-setting-key="style" value="dashed" ${s.style==='dashed'?'checked':''}>è™šçº¿</label><label><input type="radio" name="sep-style-${block.id}" data-setting-key="style" value="dotted" ${s.style==='dotted'?'checked':''}>ç‚¹çŠ¶</label></div></div><div class="color-control-row"><div class="color-control-group"><label>çº¿æ¡é¢œè‰²:</label><div class="input-group"><input type="color" data-setting-key="color" value="${s.color}"><input type="text" class="color-hex-input" data-setting-key="color" value="${s.color}"><button class="btn btn-default btn-small" data-reset-block-key="color">é‡ç½®</button></div></div><div class="color-control-group"><label>ç²—ç»†(px):</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-setting-key="thickness" min="1" max="10" value="${s.thickness}"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div></div><div class="form-group"><label>å‚ç›´é—´è·(px):</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-setting-key="margin" min="0" max="50" value="${s.margin}"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div><hr class="separator"><div class="form-group"><label>åµŒå…¥æ–‡æœ¬ (å¯é€‰):</label><div class="input-group"><input type="text" data-setting-key="text" value="${this.escapeHTML(s.text || '')}" style="border-right: none;"><button class="btn btn-default select-icon-btn" data-separator-icon-btn="true" style="width: auto; flex-shrink: 0; border-radius: 0 6px 6px 0;">${iconHTML}</button></div></div><div class="form-group"><label>æ–‡æœ¬é¢œè‰²:</label><div class="input-group"><input type="color" data-setting-key="textColor" value="${s.textColor}"><input type="text" class="color-hex-input" data-setting-key="textColor" value="${s.textColor}"><button class="btn btn-default btn-small" data-reset-block-key="textColor">é‡ç½®</button></div></div>`;
                    } else if (block.type === 'spacer') {
                        const s = block.settings;
                        content = `<div class="form-group"><label>é«˜åº¦ (px): <span class="spacer-height-value">${s.height}</span></label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-setting-key="height" min="1" max="200" value="${s.height}"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div>`;
                    }

                    return `<h3 class="panel-header">åŒºå—è®¾ç½® ${backBtn}</h3><div class="editor-block" data-block-id="${block.id}"><div class="editor-block-header"><input type="text" class="editor-block-title-input" data-block-id-for-title="${block.id}" value="${this.escapeHTML(block.title || '')}" placeholder="åŒºå—æ ‡é¢˜ (å¯ç¼–è¾‘)"><div class="block-actions"><button class="btn btn-danger btn-small block-delete-btn">åˆ é™¤</button></div></div><div class="editor-block-content">${content}</div></div>`;
                },

                createPreviewBlockHTML(block) {
                    let layoutClass = 'preview-cards-single';
                    if (block.settings.layout === 'dual') layoutClass = 'preview-cards-dual';
                    if (block.settings.layout === 'triple') layoutClass = 'preview-cards-triple';
                    
                    let cardsHTML = '';
                    if (block.type === 'text') {
                        cardsHTML = (block.cards || []).map(card => this.createPreviewCardHTML(card)).join('');
                    } else if (block.type === 'image') {
                        cardsHTML = (block.cards || []).map(card => this.createPreviewImageCardHTML(card, block.settings)).join('');
                    }

                    if (block.type === 'text' || block.type === 'image') {
                        return `<div class="preview-cards-container ${layoutClass}">${cardsHTML}</div>`;
                    } else if (block.type === 'separator') {
                         const s = block.settings;
                         const hasTextOrIcon = s.text || s.icon;
                         const iconHTML = s.icon ? `<span class="iconify" data-icon="${s.icon}" style="margin-right: 8px; vertical-align: -0.15em;"></span>` : '';
                         const textHTML = `<span data-separator-text-key="${block.id}" style="color: ${s.textColor}; padding: 0 12px; flex-shrink: 0;">${iconHTML}${this.escapeHTML(s.text || '')}</span>`;
                         const lineHTML = `<div class="separator-preview-line" style="flex-grow: 1; border-top: ${s.thickness}px ${s.style} ${s.color};"></div>`;
                         return `<div class="separator-preview" style="margin: ${s.margin}px 0;">${lineHTML}${hasTextOrIcon ? textHTML + lineHTML : ''}</div>`;
                    } else if (block.type === 'spacer') {
                        return `<div class="spacer-preview" style="height: ${block.settings.height}px;"></div>`;
                    }
                    return '';
                },

                createPreviewCardHTML(card) {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'preview-card';
                    cardEl.dataset.cardId = card.id;
                    cardEl.style.setProperty('--card-transition-name', `card-${card.id}`);
                    const iconHTML = card.icon ? `<span class="iconify" data-icon="${card.icon}"></span>` : '';
                    
                    const finalAlign = (card.textAlign === undefined || card.textAlign === null || card.textAlign === '') ? this.state.globalCardStyles.textAlign : card.textAlign;
                    const justifyContent = { left: 'flex-start', center: 'center', right: 'flex-end' }[finalAlign] || 'flex-start';
                    
                    cardEl.innerHTML = `<div class="preview-card-inner">
                            <h3 class="preview-card-title" data-card-key="title" style="justify-content: ${justifyContent};">${iconHTML}${this.escapeHTML(card.title || '')}</h3>
                            <div class="preview-card-content" data-card-key="content">${card.content || ''}</div>
                        </div>`;
                    return cardEl.outerHTML;
                },

                createPreviewImageCardHTML(card, blockSettings = {}) {
                    const textColorStyle = blockSettings.textColor ? `style="color: ${blockSettings.textColor};"` : '';
                    const figcaptionContent = (card.title || card.description) ? 
                        `<figcaption ${textColorStyle}>
                            ${card.title ? `<strong data-card-key="title">${this.escapeHTML(card.title)}</strong>` : ''}
                            <span data-card-key="description">${this.escapeHTML(card.description || '')}</span>
                        </figcaption>` 
                        : '';
                    
                    const figureHTML = `<figure data-card-id="${card.id}">
                        <img src="" alt="${this.escapeHTML(card.title || '')}" loading="lazy">
                        ${figcaptionContent}
                    </figure>`;

                   return figureHTML;
                },

                createEditorCardHTML(card) {
                    const iconHTML = card.icon ? `<span class="iconify" data-icon="${card.icon}" style="font-size: 1.2em; vertical-align: middle; margin-right: 5px;"></span>` : 'é€‰æ‹©å›¾æ ‡';
                    const g = this.state.globalCardStyles;
                    const contentPreview = card.content || '<span style="color: var(--text-placeholder);">ç‚¹å‡»ç¼–è¾‘å†…å®¹...</span>';

                    return `<span class="card-drag-handle">â˜°</span><div class="editor-card-header"><button class="btn btn-danger btn-small card-delete-btn">åˆ </button></div>
                        <div class="editor-card-content">
                            <h4>åŸºç¡€è®¾ç½®</h4>
                            <div class="form-group"><label>æ ‡é¢˜:</label><div class="input-group"><input type="text" data-card-key="title" value="${this.escapeHTML(card.title || '')}" style="border-right: none;"><button class="btn btn-default select-icon-btn" style="width: auto; flex-shrink: 0; border-radius: 0 6px 6px 0; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${iconHTML}</button></div></div>
                            <div class="form-group">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                    <label style="margin-bottom: 0;">å†…å®¹:<span class="tooltip-trigger" data-tooltip="æ­¤å¤„æ”¯æŒå¯Œæ–‡æœ¬ç¼–è¾‘ã€‚å¡ç‰‡å†…éƒ¨è®¾ç½®çš„æ–‡æœ¬é¢œè‰²ã€èƒŒæ™¯è‰²ä¼šè¦†ç›–æ­¤å¤„çš„æ ·å¼ã€‚"><span class="iconify" data-icon="mdi:help-circle-outline"></span></span></label>
                                    <button class="btn btn-default btn-small edit-content-btn"><span class="iconify" data-icon="mdi:pencil"></span> ç¼–è¾‘å†…å®¹</button>
                                </div>
                                <div class="rich-text-editor-trigger">
                                    <div class="rich-text-preview">${contentPreview}</div>
                                </div>
                            </div>
                            <div class="form-group"><label>å¯¹é½:</label><div class="radio-group">
                                <label><input type="radio" name="card-${card.id}-align" value="" data-card-key="textAlign" ${!['left', 'center', 'right'].includes(card.textAlign) ? 'checked' : ''}>é»˜è®¤</label>
                                <label><input type="radio" name="card-${card.id}-align" value="left" data-card-key="textAlign" ${card.textAlign === 'left' ? 'checked' : ''}>å·¦</label>
                                <label><input type="radio" name="card-${card.id}-align" value="center" data-card-key="textAlign" ${card.textAlign === 'center' ? 'checked' : ''}>ä¸­</label>
                                <label><input type="radio" name="card-${card.id}-align" value="right" data-card-key="textAlign" ${card.textAlign === 'right' ? 'checked' : ''}>å³</label>
                            </div></div>
                            <hr class="separator">
                            <div class="color-control-row">
                                <div class="color-control-group"><label>èƒŒæ™¯è‰²:</label><div class="input-group"><input type="color" data-card-key="bgColor" value="${card.bgColor || ''}"><input class="color-hex-input" type="text" data-card-key="bgColor" value="${card.bgColor || ''}" placeholder="${g.bgColor} (å…¨å±€)"><button class="btn btn-default btn-small" data-reset-card-key="bgColor">é‡ç½®</button></div></div>
                                <div class="color-control-group"><label>æ–‡å­—é¢œè‰²:</label><div class="input-group"><input type="color" data-card-key="textColor" value="${card.textColor || ''}"><input class="color-hex-input" type="text" data-card-key="textColor" value="${card.textColor || ''}" placeholder="${g.textColor} (å…¨å±€)"><button class="btn btn-default btn-small" data-reset-card-key="textColor">é‡ç½®</button></div></div>
                            </div>
                            <hr class="separator">
                            <div class="form-group"><label>èƒŒæ™¯å›¾:</label><div class="input-group simple"><input type="file" class="card-bg-upload" accept="image/*"><button class="btn btn-default btn-small card-clear-bg-btn">æ¸…é™¤</button></div></div>
                            <div class="card-overlay-controls" style="${card.bgImageDataUrl ? '' : 'display:none;'}"><label>å›¾ç‰‡è’™ç‰ˆ:</label><div class="color-control-row"><div class="color-control-group"><label>é¢œè‰²:</label><div class="input-group"><input type="color" data-card-key="overlayColor" value="${card.overlayColor || '#ffffff'}"><input class="color-hex-input" type="text" data-card-key="overlayColor" value="${card.overlayColor || '#ffffff'}"></div></div><div class="color-control-group"><label>ä¸é€æ˜åº¦:</label><div class="input-group simple stepper-group"><button class="btn btn-default btn-stepper minus" aria-label="å‡å°‘">-</button><input type="range" data-card-key="overlayOpacity" min="0" max="1" step="0.05" value="${card.overlayOpacity ?? 0.5}"><button class="btn btn-default btn-stepper plus" aria-label="å¢åŠ ">+</button></div></div></div></div>
                        </div>`;
                },

                createEditorImageCardHTML(card) {
                    const imgHTML = `<img src="" loading="lazy">`;

                    return `<span class="card-drag-handle">â˜°</span>
                        <div class="editor-card-header"><button class="btn btn-danger btn-small card-delete-btn">åˆ </button></div>
                        <div class="editor-card-content">
                            <div class="image-card-editor-content">
                                <div class="image-card-editor-thumb">
                                    <div class="thumbnail-wrapper">
                                        ${imgHTML}
                                        <div class="thumbnail-actions">
                                            <button class="btn btn-icon crop-image-btn" title="è£å‰ª"><span class="iconify" data-icon="mdi:crop"></span></button>
                                        </div>
                                    </div>
                                </div>
                                <div class="image-card-editor-fields">
                                    <div class="form-group"><label>æ ‡é¢˜:</label><input type="text" data-card-key="title" value="${this.escapeHTML(card.title || '')}"></div>
                                    <div class="form-group"><label>æè¿°:</label><textarea data-card-key="description" rows="2">${this.escapeHTML(card.description || '')}</textarea></div>
                                </div>
                            </div>
                        </div>`;
                },
                
                async applyCardStyles(cardEl, cardData) {
                    const g = this.state.globalCardStyles;
                    const use = (key, val) => (val === undefined || val === null || val === '') ? g[key] : val;
                    
                    const followGlobalOpacity = cardData.followGlobalOpacity !== false;
                    const finalOpacity = followGlobalOpacity ? g.opacity : (cardData.opacity ?? 1.0);
                    
                    const innerEl = cardEl.querySelector('.preview-card-inner');
                    if (!innerEl) return;
                    
                    if (parseFloat(finalOpacity) < 0.01) {
                        innerEl.style.setProperty('--card-bg-final', 'transparent');
                        innerEl.style.boxShadow = 'none';
                        innerEl.style.border = 'var(--active-card-border)'; 
                    } else {
                        const finalTextColor = use('textColor', cardData.textColor);
                        let finalBg;
                        if (cardData.bgImageDataUrl) {
                            let imageUrl = cardData.bgImageDataUrl;
                            if(imageUrl.startsWith('idb://')) {
                                try {
                                    const imageId = imageUrl.substring(6);
                                    const record = await this.getImageFromDB(imageId);
                                    if(record && record.blob) imageUrl = URL.createObjectURL(record.blob);
                                } catch (e) { console.error('Failed to load card bg from DB', e); }
                            }
                            finalBg = `url(${imageUrl})`;
                        } else if (cardData.bgColor) {
                            finalBg = this.hexToRgba(cardData.bgColor, finalOpacity);
                        } else {
                            if (g.bgMode === 'gradient') {
                                finalBg = `linear-gradient(${g.bgGradientAngle}deg, ${this.hexToRgba(g.bgGradientStart, finalOpacity)}, ${this.hexToRgba(g.bgGradientEnd, finalOpacity)})`;
                            } else {
                                finalBg = this.hexToRgba(g.bgColor, finalOpacity);
                            }
                        }
                        
                        innerEl.style.setProperty('--card-bg-final', finalBg);
                        innerEl.style.setProperty('--card-text-color', finalTextColor);
                        innerEl.style.textAlign = use('textAlign', cardData.textAlign);
                        innerEl.style.fontSize = cardData.fontSize || 'inherit'; 
                        innerEl.style.setProperty('--card-font-weight', cardData.fontWeight || 'normal');
                        innerEl.style.setProperty('--active-card-text-shadow', 'none');
                        
                        innerEl.style.setProperty('--card-overlay-color', cardData.overlayColor || '#FFF');
                        const overlayOpacity = cardData.bgImageDataUrl ? (cardData.overlayOpacity ?? 0.5) : 0;
                        innerEl.style.setProperty('--card-overlay-opacity', parseFloat(overlayOpacity) > 0 ? overlayOpacity : 0);
                        
                        innerEl.style.boxShadow = 'var(--active-card-shadow)';
                        innerEl.style.border = 'var(--active-card-border)';
                    }
                },

                updateState(keyPath, value, pushHistory = true, historyDescription = null) {
                    if (pushHistory && !this.isRestoringState) {
                        this.pushHistory(historyDescription || 'ä¿®æ”¹æ ·å¼');
                    }
                    let obj = this.state;
                    const keys = keyPath.split('.');
                    for (let i = 0; i < keys.length - 1; i++) { obj = obj?.[keys[i]]; }
                    if(obj) obj[keys[keys.length - 1]] = value;
                    this.debouncedSaveToLocal();
                    this.triggerRender(keyPath);
                    this.syncControl(keyPath);
                },

                triggerRender(keyPath) {
                    // --- NEW: Flicker Reduction Logic ---
                    const styles = this.state.pageStyles;
                    const gCard = this.state.globalCardStyles;
                    const info = this.state.personalInfo;
                    const r = document.documentElement.style;

                    const directUpdateMap = {
                        'pageStyles.headerBgColor': () => { if (styles.headerBgMode === 'solid') this.elements.previewHeader.style.background = this.hexToRgba(styles.headerBgColor, styles.headerOpacity); },
                        'pageStyles.headerBgGradientStart': () => { if (styles.headerBgMode === 'gradient') this.elements.previewHeader.style.background = `linear-gradient(${styles.headerBgGradientAngle}deg, ${this.hexToRgba(styles.headerBgGradientStart, styles.headerOpacity)}, ${this.hexToRgba(styles.headerBgGradientEnd, styles.headerOpacity)})`},
                        'pageStyles.headerBgGradientEnd': () => { if (styles.headerBgMode === 'gradient') this.elements.previewHeader.style.background = `linear-gradient(${styles.headerBgGradientAngle}deg, ${this.hexToRgba(styles.headerBgGradientStart, styles.headerOpacity)}, ${this.hexToRgba(styles.headerBgGradientEnd, styles.headerOpacity)})`},
                        'pageStyles.headerBgGradientAngle': () => { if (styles.headerBgMode === 'gradient') this.elements.previewHeader.style.background = `linear-gradient(${styles.headerBgGradientAngle}deg, ${this.hexToRgba(styles.headerBgGradientStart, styles.headerOpacity)}, ${this.hexToRgba(styles.headerBgGradientEnd, styles.headerOpacity)})`},
                        'pageStyles.headerOpacity': () => this.renderPageStyles(),
                        'pageStyles.headerBorderRadius': () => { this.elements.previewHeader.style.borderRadius = `${styles.headerBorderRadius}px`; },
                        'pageStyles.pageBgSolidColor': () => { if(styles.pageBgMode === 'solid') this.elements.previewWrapper.style.backgroundColor = styles.pageBgSolidColor; },
                        'pageStyles.pageBgGradientStart': () => { if(styles.pageBgMode === 'gradient') this.renderPageStyles(); },
                        'pageStyles.pageBgGradientEnd': () => { if(styles.pageBgMode === 'gradient') this.renderPageStyles(); },
                        'pageStyles.pageBgGradientAngle': () => { if(styles.pageBgMode === 'gradient') this.renderPageStyles(); },
                        'pageStyles.pageOverlayOpacity': () => this.renderPageStyles(),
                        'pageStyles.pageOverlayColor': () => this.renderPageStyles(),

                        'globalCardStyles.opacity': () => { r.setProperty('--g-card-opacity', gCard.opacity); this.renderPreviewBlocks(); },
                        'globalCardStyles.radius': () => r.setProperty('--g-card-border-radius', `${gCard.radius}px`),
                        'globalCardStyles.bgColor': () => { r.setProperty('--g-card-bg-color', gCard.bgColor); if(gCard.bgMode === 'solid') this.renderPreviewBlocks(); },
                        'globalCardStyles.textColor': () => { r.setProperty('--g-card-text-color', gCard.textColor); this.renderPreviewBlocks(); },
                        'globalCardStyles.bgGradientStart': () => { if(gCard.bgMode === 'gradient') this.renderPreviewBlocks(); },
                        'globalCardStyles.bgGradientEnd': () => { if(gCard.bgMode === 'gradient') this.renderPreviewBlocks(); },
                        'globalCardStyles.bgGradientAngle': () => { if(gCard.bgMode === 'gradient') this.renderPreviewBlocks(); },
                        'globalCardStyles.borderWidth': () => { r.setProperty('--active-card-border', gCard.borderWidth > 0 && gCard.borderStyle !== 'none' ? `${gCard.borderWidth}px ${gCard.borderStyle} ${gCard.borderColor}` : 'none'); },
                        'globalCardStyles.borderStyle': () => { r.setProperty('--active-card-border', gCard.borderWidth > 0 && gCard.borderStyle !== 'none' ? `${gCard.borderWidth}px ${gCard.borderStyle} ${gCard.borderColor}` : 'none'); },
                        'globalCardStyles.borderColor': () => { r.setProperty('--active-card-border', gCard.borderWidth > 0 && gCard.borderStyle !== 'none' ? `${gCard.borderWidth}px ${gCard.borderStyle} ${gCard.borderColor}` : 'none'); },
                        'globalCardStyles.textStrokeWidth': () => { r.setProperty('--g-card-text-stroke', gCard.textStrokeWidth > 0 ? `${gCard.textStrokeWidth}px ${gCard.textStrokeColor}` : '0px transparent'); },
                        'globalCardStyles.textStrokeColor': () => { r.setProperty('--g-card-text-stroke', gCard.textStrokeWidth > 0 ? `${gCard.textStrokeWidth}px ${gCard.textStrokeColor}` : '0px transparent'); },
                        
                        'personalInfo.nicknameColor': () => { this.elements.previewNickname.style.color = info.nicknameColor; },
                        'personalInfo.subtitleColor': () => { this.elements.previewSubtitle.style.color = info.subtitleColor; },
                        'personalInfo.bioColor': () => { this.elements.previewBio.style.color = info.bioColor; },
                        'personalInfo.tagBgColor': () => { this.elements.previewTagsContainer.querySelectorAll('.tag-pill').forEach(el => el.style.backgroundColor = info.tagBgColor); },
                        'personalInfo.tagTextColor': () => { this.elements.previewTagsContainer.querySelectorAll('.tag-pill').forEach(el => el.style.color = info.tagTextColor); },
                        'personalInfo.avatarBorderSize': () => { this.elements.previewAvatar.style.borderWidth = `${info.avatarBorderSize}px`; },
                        'personalInfo.avatarBorderColor': () => { this.elements.previewAvatar.style.borderColor = info.avatarBorderColor; },
                    };

                    if (directUpdateMap[keyPath]) {
                        directUpdateMap[keyPath]();
                        return; // Exit after direct update
                    }
                    // --- END OF Flicker Reduction Logic ---
                    
                    const mainKey = keyPath.split('.')[0];
                    const keyParts = keyPath.split('.');

                    if (mainKey === 'personalInfo') {
                        const subKey = keyParts[1];

                        if (subKey === 'tags' && keyParts.length > 3 && (keyParts[3] === 'text' || keyParts[3] === 'icon')) {
                            this.renderPersonalInfo();
                            return; 
                        }

                        switch (subKey) {
                            case 'nickname':
                                this.elements.previewNickname.textContent = this.state.personalInfo.nickname;
                                break;
                            case 'subtitle':
                                this.elements.previewSubtitle.textContent = this.state.personalInfo.subtitle;
                                break;
                            case 'bio':
                                this.elements.previewBio.textContent = this.state.personalInfo.bio;
                                break;
                            default:
                                this.renderPersonalInfo();
                                if (subKey === 'tags') this.renderTagManager();
                        }
                        this.renderMobileEditPencils();
                        return;
                    }

                    if (mainKey === 'pageStyles' || mainKey === 'globalCardStyles') {
                        if (mainKey === 'globalCardStyles') this.updateGlobalCardStyleVars();
                        this.renderPageStyles();
                        this.renderPreviewBlocks();
                        if (this.selection.type === 'global') {
                            this.syncAllControls();
                        }
                        return;
                    }

                    if (mainKey === 'blocks') {
                        if (keyParts.length <= 2) { 
                            this.renderLayerPanel();
                            this.renderPreviewBlocks();
                            return;
                        }

                        const blockIndex = parseInt(keyParts[1], 10);
                        const block = this.state.blocks[blockIndex];
                        if (!block) return;

                        const updatedProperty = keyParts[2];
                        
                        if (updatedProperty === 'title') {
                            const layerItem = this.elements.layerList.querySelector(`.layer-item[data-id="${block.id}"] .layer-name`);
                            if (layerItem) layerItem.textContent = block.title;
                            return;
                        }

                        if (updatedProperty === 'isVisible' || updatedProperty === 'settings' || updatedProperty === 'isExpanded') {
                            this.renderPreviewBlockById(block.id);
                            const layerItemContainer = this.elements.layerList.querySelector(`.layer-item-container[data-block-id="${block.id}"]`);
                            if(layerItemContainer) {
                                layerItemContainer.querySelector('.layer-item').classList.toggle('is-hidden', block.isVisible === false);
                                layerItemContainer.classList.toggle('is-expanded', block.isExpanded === true);
                            }
                            return;
                        }

                        if (updatedProperty === 'cards') {
                             if (keyParts.length <= 4) { 
                                this.renderLayerPanel();
                                this.renderPreviewBlockById(block.id);
                                return;
                            }
                            
                            const cardIndex = parseInt(keyParts[3], 10);
                            const cardProp = keyParts[4];
                            const card = block.cards[cardIndex];
                            if (!card) return;
                            
                            if (cardProp === 'title') {
                                const cardLayerItem = this.elements.layerList.querySelector(`.card-layer-item[data-card-id="${card.id}"]`);
                                if (cardLayerItem) cardLayerItem.textContent = card.title || 'æ— æ ‡é¢˜å¡ç‰‡';
                            }
                            this.renderPreviewBlockById(block.id);
                            return;
                        }
                    }
                },
                
                addCard(blockId, isQuickAdd = false) {
                    const block = this.findBlock(blockId);
                    if (!block || block.type !== 'text') return;
                    
                    const newCard = { id: this.generateId('c'), icon: '', title: `æ–°å¡ç‰‡`, content: 'ç‚¹å‡»ç¼–è¾‘å†…å®¹', opacity: 1.0, followGlobalOpacity: true, textShadowEnabled: false };
                    
                    this.pushHistory('æ·»åŠ å¡ç‰‡');
                    block.cards.push(newCard);
                    this.debouncedSaveToLocal();
                    
                    if (isQuickAdd) {
                        const cardListEl = this.elements.layerList.querySelector(`.layer-item-container[data-block-id="${blockId}"] .card-layer-list`);
                        if (cardListEl) {
                            const newCardLayerItem = document.createElement('li');
                            newCardLayerItem.className = 'card-layer-item';
                            newCardLayerItem.dataset.cardId = newCard.id;
                            newCardLayerItem.textContent = newCard.title || 'æ— æ ‡é¢˜å¡ç‰‡';
                            cardListEl.appendChild(newCardLayerItem);
                            this.toggleLayerExpansion(blockId, true);
                        }
                    } else {
                        this.renderLayerPanel();
                    }

                    this.renderInspector();
                    
                    const container = this.elements.previewBlocksContainer.querySelector(`[data-block-id="${blockId}"] > div`);
                    if (!container) {
                        this.renderPreviewBlockById(blockId);
                        return;
                    };

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = this.createPreviewCardHTML(newCard);
                    const newCardEl = tempDiv.firstChild;
                    this.applyCardStyles(newCardEl, newCard); 
                    container.appendChild(newCardEl);

                    const masonry = this.masonryInstances[blockId];
                    if (masonry) {
                        masonry.appended(newCardEl);
                        masonry.layout();
                    }

                    newCardEl.classList.add('adding');
                    newCardEl.addEventListener('animationend', () => newCardEl.classList.remove('adding'), { once: true });
                    
                    const newCardEditorEl = this.elements.inspectorPanel.querySelector(`.editor-card[data-card-id="${newCard.id}"]`);
                    if (newCardEditorEl) {
                        newCardEditorEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                },

                addImageCard(blockId) {
                    const blockEl = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${blockId}"]`);
                    if (blockEl) {
                        blockEl.querySelector('.image-upload-input').click();
                    }
                },

                deleteCard(blockId, cardId) {
                    const block = this.findBlock(blockId);
                    if (!block) return;
                    
                    const cardEl = this.elements.previewBlocksContainer.querySelector(`[data-card-id="${cardId}"]`);
                    
                    const doDelete = () => {
                        this.pushHistory('åˆ é™¤å¡ç‰‡');
                        block.cards = block.cards.filter(c => c.id !== cardId);
                        this.debouncedSaveToLocal();
                        this.renderInspector();
                        this.renderLayerPanel();
                        
                        const masonry = this.masonryInstances[blockId];
                        if (!masonry) {
                            this.renderPreviewBlockById(blockId);
                        } else {
                            masonry.layout();
                        }

                        this.showToast('å¡ç‰‡å·²åˆ é™¤', 'info');
                    };

                    if (cardEl) {
                        const masonry = this.masonryInstances[blockId];
                        if (masonry) {
                            masonry.remove(cardEl);
                        }

                        cardEl.classList.add('removing');
                        cardEl.addEventListener('animationend', () => {
                            if (!masonry) cardEl.remove();
                            doDelete();
                        }, { once: true });

                    } else {
                        doDelete();
                    }
                },

                async loadFromLocal() { 
                    const json = localStorage.getItem('blokkoState'); 
                    if (!json) {
                        this.showToast('æ¬¢è¿ä½¿ç”¨ Blokkoï¼å·²ä¸ºæ‚¨åŠ è½½é»˜è®¤æ¨¡æ¿ã€‚', 'info');
                        await this.loadFontsFromDB();
                        return;
                    };
                    try { 
                        let saved = JSON.parse(json);
                        if (saved && saved.personalInfo) {
                            saved = await this.processStateForImageMigration(saved);

                            if (typeof saved.personalInfo.tags === 'string') {
                                saved.personalInfo.tags = saved.personalInfo.tags.split(/[,ï¼Œã€]/).map(t => t.trim()).filter(Boolean)
                                    .map(text => ({ id: this.generateId('t'), icon: null, text }));
                                this.showToast('æ—§ç‰ˆé…ç½®å·²åŠ è½½ï¼Œæ ‡ç­¾æ•°æ®å·²è‡ªåŠ¨è½¬æ¢ã€‚', 'info');
                            }
                            
                            let migrated = false;
                            saved.blocks.forEach(block => {
                                if (block.type === 'image' && block.images && !block.cards) {
                                    block.cards = block.images.map(img => ({ ...img, id: this.generateId('ic') }));
                                    delete block.images;
                                    migrated = true;
                                }
                                if (block.isVisible === undefined) block.isVisible = true;
                                if (block.isExpanded === undefined) block.isExpanded = false;
                            });
                            if (migrated) this.showToast('æ—§ç‰ˆå›¾ç‰‡åŒºå—å·²è‡ªåŠ¨å‡çº§', 'info');
                            
                            const defaultState = this.getDefaultState();
                            this.state = this.mergeDeep(defaultState, saved);
                            
                            if (saved.uploadedFonts) {
                                for (const font of saved.uploadedFonts) {
                                    if (font.data) {
                                        try {
                                           const fontBuffer = this.base64ToArrayBuffer(font.data);
                                           await this.saveFontToDB({ family: font.family, fullName: font.fullName, data: fontBuffer });
                                        } catch(e) { console.error("ä»localStorageè¿ç§»å­—ä½“å¤±è´¥:", e)}
                                    }
                                }
                                delete this.state.uploadedFonts;
                                this.saveToLocal(); // Save back without old font data
                            }
                        }
                    } catch (e) { 
                        localStorage.removeItem('blokkoState'); 
                        this.showErrorModal('åŠ è½½å­˜æ¡£å¤±è´¥', 'æ‚¨çš„æœ¬åœ°å­˜æ¡£å¯èƒ½å·²æŸåï¼Œå·²ä¸ºæ‚¨åŠ è½½é»˜è®¤æ¨¡æ¿ã€‚é”™è¯¯ä¿¡æ¯: ' + e.message);
                        console.error("ä» localStorage åŠ è½½çŠ¶æ€å¤±è´¥:", e);
                    } finally {
                        await this.loadFontsFromDB();
                        this.hideLoading();
                    }
                },
                
                mergeDeep(target, source) {
                    const isObject = (obj) => obj && typeof obj === 'object';
                    let output = { ...target };
                    if (isObject(target) && isObject(source)) {
                        Object.keys(source).forEach(key => {
                            if (isObject(source[key])) {
                                if (!(key in target)) {
                                    Object.assign(output, { [key]: source[key] });
                                } else if (Array.isArray(source[key])) {
                                    output[key] = source[key];
                                } else {
                                    output[key] = this.mergeDeep(target[key], source[key]);
                                }
                            } else {
                                Object.assign(output, { [key]: source[key] });
                            }
                        });
                    }
                    return output;
                },
                
                syncControl(keyPath) {
                    this.isRestoringState = true;
                    try {
                        const inputs = this.elements.inspectorPanel.querySelectorAll(`[data-state-key="${keyPath}"], [data-setting-key="${keyPath.split('.').slice(2).join('.')}"]`);
                        if (inputs.length === 0) return;

                        const value = keyPath.split('.').reduce((o, k) => o && o[k], this.state);

                        inputs.forEach(input => {
                            if (input.type === 'radio') {
                                input.checked = (input.value == value);
                            } else if (input.type === 'checkbox') {
                                input.checked = !!value;
                            } else {
                                input.value = value ?? '';
                            }

                            if (input.type === 'range') {
                                const valueDisplay = input.closest('.form-group').querySelector('.angle-value, .spacer-height-value, #gCardRadiusValue, .avatar-size-value, .header-radius-value');
                                if (valueDisplay) valueDisplay.textContent = value;
                            }
                        });
                    } catch (e) {
                         console.error(`åŒæ­¥æ§ä»¶ ${keyPath} æ—¶å‡ºé”™:`, e);
                    } finally {
                        this.isRestoringState = false;
                    }
                },

                syncAllControls() {
                    this.isRestoringState = true;
                    try {
                        this.elements.inspectorPanel.querySelectorAll('[data-state-key], [data-setting-key]').forEach(input => {
                            try {
                                const stateKey = input.dataset.stateKey;
                                const settingKey = input.dataset.settingKey;
                                let value;

                                if (stateKey) {
                                    if (stateKey === 'personalInfo.tags') return;
                                    value = stateKey.split('.').reduce((o, k) => o && o[k], this.state);
                                } else if (settingKey && this.selection.type === 'block') {
                                    const block = this.findBlock(this.selection.id);
                                    if (block) value = block.settings[settingKey];
                                }
                                
                                if (value !== undefined) {
                                    if (input.type === 'radio') {
                                        input.checked = (input.value == value);
                                    } else if (input.type === 'checkbox') {
                                        input.checked = !!value;
                                    } else if (input.matches('textarea[data-card-key="content"]')) {
                                        input.value = (value || '').replace(/<[^>]*>?/gm, '');
                                    }
                                    else {
                                        input.value = value ?? '';
                                    }

                                    if (input.type === 'color') {
                                        const hexInput = input.nextElementSibling;
                                        if(hexInput && hexInput.matches('.color-hex-input')) {
                                            hexInput.value = value || (input.placeholder || '');
                                        }
                                    }
                                    if (input.type === 'range') {
                                        const valueDisplay = input.closest('.form-group').querySelector('.angle-value, .spacer-height-value, #gCardRadiusValue, .avatar-size-value, .header-radius-value');
                                        if(valueDisplay) valueDisplay.textContent = value;
                                    }
                                }
                            } catch (e) {}
                        });
                        
                        const gCardSection = this.elements.inspectorPanel.querySelector('#global-card-styles-section');
                        if (gCardSection) {
                            const gCardActiveTab = this.state.globalCardStyles.bgMode === 'gradient' ? 'card-bg-gradient' : 'card-bg-solid';
                            gCardSection.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === gCardActiveTab));
                            gCardSection.querySelectorAll(':scope > .section-content > .tab-content').forEach(c => c.classList.toggle('active', c.id === gCardActiveTab));
                        }

                        const pageSection = this.elements.inspectorPanel.querySelector('#page-styles-section');
                        if (pageSection) {
                            const pageActiveTab = this.state.pageStyles.pageBgMode === 'gradient' ? 'page-bg-gradient' : 'page-bg-solid';
                            const headerActiveTab = this.state.pageStyles.headerBgMode === 'gradient' ? 'header-bg-gradient' : 'header-bg-solid';
                            pageSection.querySelectorAll('[data-tab^="page-bg-"]').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === pageActiveTab));
                            pageSection.querySelectorAll('#page-bg-solid, #page-bg-gradient').forEach(c => c.classList.toggle('active', c.id === pageActiveTab));
                            pageSection.querySelectorAll('[data-tab^="header-bg-"]').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === headerActiveTab));
                            pageSection.querySelectorAll('#header-bg-solid, #header-bg-gradient').forEach(c => c.classList.toggle('active', c.id === headerActiveTab));
                        }
                        
                        const pageImageControls = this.elements.inspectorPanel.querySelector('#page-image-controls');
                        if (pageImageControls) {
                            pageImageControls.style.display = this.state.pageStyles.pageBgImageDataUrl ? 'block' : 'none';
                        }
                        const pageTextureControls = this.elements.inspectorPanel.querySelector('#page-texture-controls');
                        if (pageTextureControls) {
                            pageTextureControls.style.display = this.state.pageStyles.pageBgPattern ? 'block' : 'none';
                            const currentTextureName = pageTextureControls.querySelector('#current-texture-name');
                            if(currentTextureName) currentTextureName.textContent = this.state.pageStyles.pageBgPattern || 'æ— ';
                        }
                        
                    } finally {
                        this.isRestoringState = false;
                    }
                },
                
                findBlock(blockId) { return this.state.blocks.find(b => b.id === blockId); },
                findBlockIndex(blockId) { return this.state.blocks.findIndex(b => b.id === blockId); },
                updateBlockTitle(blockId, title, pushHistory, historyDescription) { 
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) this.updateState(`blocks.${blockIndex}.title`, title, pushHistory, historyDescription);
                },
                updateBlockSettings(blockId, key, value, pushHistory, historyDescription) {
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) this.updateState(`blocks.${blockIndex}.settings.${key}`, value, pushHistory, historyDescription);
                },
                updateCard(blockId, cardId, key, value, pushHistory, historyDescription) {
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) {
                        const cardIndex = this.state.blocks[blockIndex].cards.findIndex(c => c.id === cardId);
                        if (cardIndex > -1) this.updateState(`blocks.${blockIndex}.cards.${cardIndex}.${key}`, value, pushHistory, historyDescription);
                    }
                },

                renderPreviewBlockById(blockId) {
                    const wrapper = this.elements.previewBlocksContainer.querySelector(`.preview-block-wrapper[data-block-id="${blockId}"]`);
                    const block = this.findBlock(blockId);
                    if (block && wrapper) {
                        wrapper.classList.toggle('is-hidden', block.isVisible === false);
                        wrapper.innerHTML = this.createPreviewBlockHTML(block);
                        this.postRenderAsyncUpdates(wrapper); 
                        this.initMasonryForBlock(blockId);
                    }
                    this.renderMobileEditPencils();
                },
                
                pushHistory(description = 'æ“ä½œ') {
                     if (this.isRestoringState) return; 
                        if (this.historyIndex < this.history.length - 1) { 
                            this.history = this.history.slice(0, this.historyIndex + 1); 
                        } 
                        this.history.push({ state: this.deepClone(this.state), description }); 
                        if (this.history.length > 50) this.history.shift(); 
                        this.historyIndex = this.history.length - 1;
                        this.updateUndoRedoButtons(); 
                },
                undo(){
                    if (document.activeElement && document.activeElement.isContentEditable) {
                        document.activeElement.blur();
                    }
                    if (this.historyIndex <= 0) return;

                    const actionDescription = this.history[this.historyIndex].description;

                    this.isRestoringState = true; 
                    this.historyIndex--; 
                    this.state = this.deepClone(this.history[this.historyIndex].state); 
                    this.renderAll(); 
                    this.syncAllControls(); 
                    this.updateUndoRedoButtons(); 
                    this.isRestoringState = false; 
                    this.showToast(`å·²æ’¤é”€: ${actionDescription}`, 'info');
                },
                redo(){
                    if (document.activeElement && document.activeElement.isContentEditable) {
                        document.activeElement.blur();
                    }
                    if (this.historyIndex >= this.history.length - 1) return; 
                    this.isRestoringState = true; 
                    this.historyIndex++; 

                    const actionDescription = this.history[this.historyIndex].description;
                    
                    this.state = this.deepClone(this.history[this.historyIndex].state); 
                    this.renderAll(); 
                    this.syncAllControls(); 
                    this.updateUndoRedoButtons(); 
                    this.isRestoringState = false; 
                    this.showToast(`å·²é‡åš: ${actionDescription}`, 'info');
                },
                updateUndoRedoButtons(){
                    const undoBtn = this.elements.inspectorPanel.querySelector('#undo-btn');
                    const redoBtn = this.elements.inspectorPanel.querySelector('#redo-btn');
                    if (undoBtn) {
                        undoBtn.disabled = this.historyIndex <= 0;
                        if (this.historyIndex > 0) {
                            undoBtn.title = `æ’¤é”€: ${this.history[this.historyIndex].description}`;
                        } else {
                            undoBtn.title = 'æ’¤é”€';
                        }
                    }
                    if (redoBtn) {
                        redoBtn.disabled = this.historyIndex >= this.history.length - 1;
                        if (this.historyIndex < this.history.length - 1) {
                            redoBtn.title = `é‡åš: ${this.history[this.historyIndex + 1].description}`;
                        } else {
                            redoBtn.title = 'é‡åš';
                        }
                    }
                },

                async handleImageUpload(event, target, cardInfo = null){
                     const file = event.target.files[0];
                     if (!file) return;
                     this.showLoading('æ­£åœ¨å¤„ç†å›¾ç‰‡...');
                     try {
                         const reader = new FileReader();
                         reader.onload = async e => {
                             const dataUrl = e.target.result;
                             if(target === 'colorThief') {
                                 this.analyzeColorsFromImage(dataUrl); 
                                 return;
                             }
                             const compressedUrl = await this.compressImage(dataUrl, 0.9, 1200);
                             if (['avatar', 'pageBg', 'cardBg', 'imageCard'].includes(target)) {
                                 this.showCropper(compressedUrl, { type: target, ...cardInfo, originalType: file.type });
                             } else {
                                this.hideLoading();
                             }
                         };
                         reader.onerror = (err) => {
                             this.showErrorModal('å›¾ç‰‡è¯»å–å¤±è´¥', err.message);
                             this.hideLoading();
                         };
                         reader.readAsDataURL(file);
                     } catch(err) {
                         this.showErrorModal('å›¾ç‰‡å¤„ç†å¤±è´¥', err.message);
                         this.hideLoading();
                     } finally {
                         event.target.value = '';
                     }
                },
                
                handleCardBgUpload(event, blockId, cardId){
                    this.handleImageUpload(event, 'cardBg', { blockId, cardId });
                },
                async handleImageGalleryUpload(blockId, files){
                     const block = this.findBlock(blockId); 
                        if (!block || !files.length) return; 
                        this.showLoading(`æ­£åœ¨ä¸Šä¼  ${files.length} å¼ å›¾ç‰‡...`);
                        try {
                            this.pushHistory(`æ·»åŠ  ${files.length} å¼ å›¾ç‰‡`); 
                            const newCards = [];
                            for(const file of files) {
                                const url = await this.readFileAsDataURL(file).then(url => this.compressImage(url, 0.9, 1200, file.type));
                                const blob = this.dataURLToBlob(url);
                                const imageId = this.generateId('img');
                                await this.saveImageToDB({ id: imageId, blob });
                                newCards.push({ id: this.generateId('ic'), url: `idb://${imageId}`, title: '', description: '' });
                            }
                            block.cards.push(...newCards);
                            this.debouncedSaveToLocal();
                            this.renderInspector(); 
                            this.renderLayerPanel();
                            this.renderPreviewBlockById(blockId); 
                        } catch (err) {
                            this.showErrorModal('å›¾ç‰‡ä¸Šä¼ å¤±è´¥', err.message);
                        } finally {
                            this.hideLoading();
                            const input = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${blockId}"] .image-upload-input`);
                            if (input) input.value = '';
                        }
                },
                async cropImage(blockId, cardId){
                    const block = this.findBlock(blockId);
                    const card = block?.cards.find(c => c.id === cardId);
                    if (card && card.url) {
                        let imageUrl = card.url;
                        if (imageUrl.startsWith('idb://')) {
                            const record = await this.getImageFromDB(imageUrl.substring(6));
                            if (record && record.blob) {
                                imageUrl = URL.createObjectURL(record.blob);
                            }
                        }
                        this.showCropper(imageUrl, { type: 'imageCard', blockId, cardId, originalType: 'image/png' });
                    }
                },
                
                showCropper(imageSrc, target) {
                    this.currentCropTarget = target;
                    const cropperImage = this.elements.cropperImage;
                    const modal = this.elements.cropperModal;
                
                    if (this.cropper) {
                        this.cropper.destroy();
                        this.cropper = null;
                    }
                    cropperImage.src = '';
                
                    const initializeCropper = () => {
                        cropperImage.removeEventListener('load', initializeCropper);
                        cropperImage.removeEventListener('error', handleLoadError);
                
                        if (cropperImage.naturalWidth === 0 || cropperImage.naturalHeight === 0) {
                            handleLoadError();
                            return;
                        }
                
                        this.cropper = new Cropper(cropperImage, {
                            aspectRatio: NaN,
                            viewMode: 1,
                            background: false,
                            ready: () => {
                                this.hideLoading();
                            }
                        });
                
                        const freeRatioInput = modal.querySelector('input[name="crop-ratio"][value="NaN"]');
                        if (freeRatioInput) {
                            freeRatioInput.checked = true;
                        }
                    };
                
                    const handleLoadError = () => {
                        cropperImage.removeEventListener('load', initializeCropper);
                        cropperImage.removeEventListener('error', handleLoadError);
                        this.showErrorModal('å›¾ç‰‡åŠ è½½å¤±è´¥', 'æ— æ³•åœ¨è£å‰ªå™¨ä¸­åŠ è½½å›¾ç‰‡ï¼Œæ–‡ä»¶å¯èƒ½å·²æŸåæˆ–æ ¼å¼ä¸å—æ”¯æŒã€‚');
                        this.hideCropper();
                        this.hideLoading();
                    };
                
                    cropperImage.addEventListener('load', initializeCropper);
                    cropperImage.addEventListener('error', handleLoadError);
                
                    this.showLoading('æ­£åœ¨åŠ è½½å›¾ç‰‡...');
                    modal.classList.add('visible');
                    cropperImage.src = imageSrc;
                },

                hideCropper(){
                     this.elements.cropperModal.classList.remove('visible');
                     if (this.cropper) {
                         this.cropper.destroy();
                         this.cropper = null;
                     }
                     this.elements.cropperImage.src = '';
                },

                saveCrop(){
                     if (!this.cropper || !this.currentCropTarget) return;
                        this.showLoading('æ­£åœ¨ä¿å­˜å›¾ç‰‡...');
                        try {
                            const { type, blockId, cardId, originalType } = this.currentCropTarget;
                            let quality = 0.9;
                            let maxWidth = 1024;
                            if (type === 'pageBg') maxWidth = 1920;
                            if (type === 'avatar' || type === 'cardBg') maxWidth = 400;

                            const canvas = this.cropper.getCroppedCanvas({ maxWidth });
                            
                            canvas.toBlob(async (blob) => {
                                if (!blob) {
                                    this.showErrorModal('è£å‰ªå¤±è´¥', 'æ— æ³•ç”Ÿæˆå›¾ç‰‡ Blobã€‚');
                                    return;
                                }
                                
                                const imageId = this.generateId('img');
                                await this.saveImageToDB({ id: imageId, blob: blob });
                                const idbUrl = `idb://${imageId}`;

                                this.pushHistory('è£å‰ªå›¾ç‰‡');
                                if (type === 'avatar') {
                                    this.updateState('personalInfo.avatarDataUrl', idbUrl, false);
                                } else if (type === 'pageBg') {
                                    this.updateState('pageStyles.pageBgImageDataUrl', idbUrl, false);
                                } else if (type === 'imageCard') {
                                    this.updateCard(blockId, cardId, 'url', idbUrl, false);
                                } else if (type === 'cardBg') {
                                    this.updateCard(blockId, cardId, 'bgImageDataUrl', idbUrl, false);
                                }
                                this.hideCropper();
                                this.hideLoading();

                            }, originalType || 'image/jpeg', quality);

                        } catch (err) {
                            console.error('ä¿å­˜è£å‰ªå¤±è´¥:', err);
                            this.showErrorModal('ä¿å­˜è£å‰ªå¤±è´¥', 'å¤„ç†å›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯ã€‚');
                            this.hideLoading();
                        }
                },
                updateCropAspectRatio(){
                     if(this.cropper) this.cropper.setAspectRatio(parseFloat(document.querySelector('input[name="crop-ratio"]:checked').value)); 
                },
                
                // --- FEATURE: Rich Text Editor ---
                showRichTextEditor(targetElement) {
                    if (!targetElement) return;

                    const cardEl = targetElement.closest('.preview-card');
                    const blockEl = targetElement.closest('.preview-block-wrapper');
                    if (!cardEl || !blockEl) return;
                    
                    this.currentRichTextTarget = {
                        blockId: blockEl.dataset.blockId,
                        cardId: cardEl.dataset.cardId,
                        element: targetElement
                    };
                    
                    const block = this.findBlock(this.currentRichTextTarget.blockId);
                    const card = block.cards.find(c => c.id === this.currentRichTextTarget.cardId);

                    if (this.richTextEditor) {
                        this.richTextEditor.root.innerHTML = card.content || '';
                    } else {
                        this.richTextEditor = new Quill('#rich-text-editor-container', {
                            modules: {
                                toolbar: [
                                    [{ 'header': [1, 2, 3, false] }],
                                    ['bold', 'italic', 'underline', 'strike'],
                                    ['link'],
                                    [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                                    [{ 'color': [] }, { 'background': [] }],
                                    ['clean']
                                ]
                            },
                            theme: 'snow'
                        });
                        this.richTextEditor.root.innerHTML = card.content || '';
                    }
                    
                    this.elements.richTextEditorModal.classList.add('visible');
                    this.richTextEditor.focus();
                },
                
                hideRichTextEditor() {
                    this.elements.richTextEditorModal.classList.remove('visible');
                    this.currentRichTextTarget = null;
                },

                saveRichText() {
                    if (!this.richTextEditor || !this.currentRichTextTarget) return;
                    
                    const { blockId, cardId } = this.currentRichTextTarget;
                    const newContent = this.richTextEditor.root.innerHTML;

                    this.updateCard(blockId, cardId, 'content', newContent, true, 'ç¼–è¾‘å¡ç‰‡å†…å®¹');
                    this.hideRichTextEditor();
                    this.showToast('å†…å®¹å·²ä¿å­˜', 'success');
                },
                // --- END FEATURE ---

                async loadLocalFonts(){
                     if (!window.queryLocalFonts) {
                            this.showErrorModal('åŠŸèƒ½ä¸æ”¯æŒ', 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè®¿é—®æœ¬åœ°å­—ä½“ã€‚è¯·å°è¯•ä½¿ç”¨â€œä¸Šä¼ å­—ä½“â€åŠŸèƒ½ã€‚');
                            return;
                        }
                        try {
                            this.showLoading('æ­£åœ¨åŠ è½½æœ¬åœ°å­—ä½“...');
                            const fonts = await window.queryLocalFonts();
                            this.localFonts = fonts.map(font => ({ family: font.family, fullName: font.fullName, type: 'local' }));
                            this.populateFontList();
                            this.showToast(`åŠ è½½äº† ${this.localFonts.length} ä¸ªæœ¬åœ°å­—ä½“`, 'success');
                        } catch (err) {
                            console.error('æ— æ³•è®¿é—®æœ¬åœ°å­—ä½“:', err);
                            this.showErrorModal('åŠ è½½æœ¬åœ°å­—ä½“å¤±è´¥', 'è¿™æ˜¯ä¸€ä¸ªå®éªŒæ€§çš„æµè§ˆå™¨åŠŸèƒ½ï¼Œå¯èƒ½å› å®‰å…¨è®¾ç½®æˆ–æµè§ˆå™¨ç‰ˆæœ¬è€Œä¸ç¨³å®šã€‚å¦‚æœæŒç»­å¤±è´¥ï¼Œå»ºè®®ä½¿ç”¨â€œä¸Šä¼ å­—ä½“â€åŠŸèƒ½ã€‚');
                        } finally {
                            this.hideLoading();
                        }
                },
                async handleFontUpload(event){
                     const file = event.target.files[0];
                        if (!file) return;
                        this.showLoading('æ­£åœ¨ä¸Šä¼ å¹¶åŠ è½½å­—ä½“...');
                        try {
                            const fontData = await this.readFileAsArrayBuffer(file);
                            const fontName = file.name.replace(/\.[^/.]+$/, "");
                            if (this.uploadedFonts.some(f => f.family === fontName) || this.localFonts.some(f => f.family === fontName)) {
                                this.showErrorModal('å­—ä½“å·²å­˜åœ¨', `å­—ä½“ "${fontName}" å·²å­˜åœ¨!`);
                                return;
                            }
                            
                            await this.saveFontToDB({ family: fontName, fullName: `${fontName} (ä¸Šä¼ )`, data: fontData });
                            
                            const fontFace = new FontFace(fontName, fontData.slice(0));
                            await fontFace.load();
                            document.fonts.add(fontFace);
                            
                            this.uploadedFonts.push({ family: fontName, fullName: `${fontName} (ä¸Šä¼ )`, type: 'uploaded' });
                            this.populateFontList();
                            this.updateState('globalCardStyles.fontFamily', fontName, true, `ä¸Šä¼ å­—ä½“ ${fontName}`);
                            this.showToast(`å­—ä½“ "${fontName}" ä¸Šä¼ æˆåŠŸ`, 'success');
                        } catch (error) {
                            console.error('å­—ä½“ä¸Šä¼ å¤±è´¥:', error);
                            this.showErrorModal('å­—ä½“ä¸Šä¼ å¤±è´¥', 'å­—ä½“æ–‡ä»¶æ— æ•ˆæˆ–åŠ è½½å¤±è´¥ã€‚');
                        } finally {
                            event.target.value = '';
                            this.hideLoading();
                        }
                },
                
                populateFontList(searchTerm = ''){
                     const select = this.elements.inspectorPanel.querySelector('#font-family-select');
                     if (!select) return;
                        const currentFont = this.state.globalCardStyles.fontFamily;
                        select.innerHTML = '';
                        
                        const recommendedFonts = [
                            { family: 'Noto Sans CJK', fullName: 'æ€æºé»‘ä½“' },
                            { family: 'Noto Serif CJK', fullName: 'æ€æºå®‹ä½“' },
                            { family: 'HappyZcool-2016', fullName: 'ç«™é…·å¿«ä¹ä½“' },
                            { family: 'ZCOOL XiaoWei', fullName: 'ç«™é…·å°è–‡ä½“' },
							{ family: 'LXGW WenKai', fullName: 'éœé¹œæ–‡æ¥·' },
                        ];

                        const allFonts = [...this.uploadedFonts, ...this.localFonts];
                        const categories = { cjk: [], sans: [], serif: [], uploaded: [], other: [] };
                        
                        const filteredFonts = searchTerm
                            ? allFonts.filter(font => 
                                font.family.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                font.fullName.toLowerCase().includes(searchTerm.toLowerCase()))
                            : allFonts;

                        filteredFonts.forEach(font => {
                            if (recommendedFonts.some(rf => rf.family === font.family)) return;
                            const category = this.getFontCategory(font);
                            if (!categories[category].some(f => f.family === font.family)) {
                                 categories[category].push(font);
                            }
                        });

                        const requiredFonts = this.getAllRequiredFonts();
                        requiredFonts.forEach(reqFont => {
                            if (!allFonts.some(f => f.family === reqFont) && !recommendedFonts.some(rf => rf.family === reqFont)) {
                               const placeholderFont = { family: reqFont, fullName: `${reqFont} (éœ€è¦é‡æ–°ä¸Šä¼ )`, type: 'uploaded', missing: true };
                               if (!categories.uploaded.some(f => f.family === reqFont)) {
                                   categories.uploaded.push(placeholderFont);
                               }
                            }
                        });

                        const createOptgroup = (label, fonts) => {
                            if (fonts.length === 0) return '';
                            const options = fonts
                                .sort((a, b) => a.fullName.localeCompare(b.fullName))
                                .map(f => `<option value="${this.escapeHTML(f.family)}" style="font-family: '${this.escapeHTML(f.family)}', sans-serif;" ${f.missing?'disabled':''}>${this.escapeHTML(f.fullName)}</option>`)
                                .join('');
                            return `<optgroup label="${label}">${options}</optgroup>`;
                        };

                        let html = '<option value="">ç³»ç»Ÿé»˜è®¤</option>';
                        html += createOptgroup('æ¨èå­—ä½“', recommendedFonts);
                        html += createOptgroup('å·²ä¸Šä¼ å­—ä½“', categories.uploaded);
                        html += createOptgroup('ä¸­æ–‡ / CJK', categories.cjk);
                        html += createOptgroup('æ— è¡¬çº¿ (Sans-serif)', categories.sans);
                        html += createOptgroup('è¡¬çº¿ (Serif)', categories.serif);
                        html += createOptgroup('å…¶ä»–', categories.other);

                        select.innerHTML = html;
                        select.value = currentFont;
                },
                
                getFontCategory(font){
                     if (font.type === 'uploaded') return 'uploaded';
                        const name = (font.family + font.fullName).toLowerCase();
                        if (/(hei|song|ming|gothic|kai|fang|yuan|deng|é»‘|å®‹|æ˜|ã‚´ã‚·ãƒƒã‚¯|æ¥·|åœ“)/.test(name) || /[\u4e00-\u9fa5]/.test(name)) {
                            return 'cjk';
                        }
                        if (name.includes('serif')) return 'serif';
                        if (name.includes('sans')) return 'sans';
                        return 'other';
                },
                getAllRequiredFonts(){
                     const fonts = new Set();
                        if (this.state.globalCardStyles.fontFamily) {
                            fonts.add(this.state.globalCardStyles.fontFamily);
                        }
                        return Array.from(fonts);
                },
                
                applyPreset(preset){
                     this.pushHistory('åº”ç”¨é¢„è®¾ä¸»é¢˜'); 
                        
                        this.state.pageStyles.pageBgSolidColor = preset.pageBgSolidColor; 
                        this.state.pageStyles.pageBgGradientStart = preset.pageBgGradientStart;
                        this.state.pageStyles.pageBgGradientEnd = preset.pageBgGradientEnd;

                        this.state.pageStyles.headerBgColor = preset.headerBgColor;
                        this.state.pageStyles.headerBgGradientStart = preset.headerBgGradientStart;
                        this.state.pageStyles.headerBgGradientEnd = preset.headerBgGradientEnd;
                        this.state.pageStyles.headerTextColor = preset.headerTextColor; 
                        
                        this.state.globalCardStyles.bgColor = preset.gCardBgColor; 
                        this.state.globalCardStyles.bgGradientStart = preset.gCardBgGradientStart;
                        this.state.globalCardStyles.bgGradientEnd = preset.gCardBgGradientEnd;
                        this.state.globalCardStyles.textColor = preset.gCardTextColor; 
                        this.state.globalCardStyles.opacity = preset.gCardOpacity; 
                        
                        this.state.personalInfo.nicknameColor = preset.pNicknameColor;
                        this.state.personalInfo.subtitleColor = preset.pSubtitleColor;
                        this.state.personalInfo.bioColor = preset.pBioColor;
                        this.state.personalInfo.tagBgColor = preset.pTagBgColor;
                        this.state.personalInfo.tagTextColor = preset.pTagTextColor;
                        
                        this.state.pageStyles.pageBgMode = 'solid';
                        this.state.pageStyles.headerBgMode = 'solid';
                        this.state.globalCardStyles.bgMode = 'solid';

                        this.debouncedSaveToLocal();
                        this.renderAll(); 
                        this.syncAllControls();
                        this.showToast('é¢„è®¾å·²åº”ç”¨', 'success');
                },
                
                readFileAsDataURL(file){return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    })},
                readFileAsArrayBuffer(file){return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(file);
                    })},
                compressImage(dataUrl, quality = 0.9, maxWidth = 1024, originalType = 'image/jpeg'){return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            let { width, height } = img;
                            if (width > maxWidth) {
                                height = (maxWidth / width) * height;
                                width = maxWidth;
                            }
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            const outputType = originalType === 'image/png' ? 'image/png' : 'image/jpeg';
                            resolve(canvas.toDataURL(outputType, quality));
                        };
                        img.onerror = (err) => reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æŸåã€‚'));
                        img.src = dataUrl;
                    })},
                
                toggleTheme(){
                    const isDark = document.documentElement.classList.toggle('dark-mode'); 
                    localStorage.setItem('blokkoTheme', isDark ? 'dark' : 'light'); 
                    this.elements.themeToggleBtn.textContent = isDark ? 'æš—é»‘æ¨¡å¼' : 'æ˜äº®æ¨¡å¼'; 
                },
                loadPreferences(){
                    const isDark = localStorage.getItem('blokkoTheme') === 'dark';
                    if (isDark) { 
                        document.documentElement.classList.add('dark-mode');
                    } 
                    this.elements.themeToggleBtn.textContent = isDark ? 'æš—é»‘æ¨¡å¼' : 'æ˜äº®æ¨¡å¼';
                },
                saveToLocal(){
                     try { 
                            const stateToSave = this.deepClone(this.state);
                            delete stateToSave.uploadedFonts;
                            localStorage.setItem('blokkoState', JSON.stringify(stateToSave));
                            if (this.isStorageFull) {
                                this.isStorageFull = false;
                                this.removeStorageFullToast();
                            }
                        } catch (e) {
                            console.error("ä¿å­˜åˆ° localStorage å¤±è´¥:", e);
                            if (e.name === 'QuotaExceededError') {
                                this.isStorageFull = true;
                                this.showStorageFullToast();
                            }
                        } 
                },
                
                generateFilename(type){
                    const nickname = (this.state.personalInfo.nickname || '').replace(/[^a-z0-9\u4e00-\u9fa5]/gi, '_').substring(0, 15) || 'Blokko';
                    const date = new Date();
                    const dateString = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
                    const randomString = Math.random().toString(36).substring(2, 8);
                    return `${nickname}-${dateString}-${type}-${randomString}`;
                },
                
                async exportConfig(isTemplate = false){
                     let stateToSave = this.deepClone(this.state);
                        
                        if (isTemplate) {
                            stateToSave.personalInfo.nickname = "ä½ çš„æ˜µç§°";
                            stateToSave.personalInfo.subtitle = "è¿™æ˜¯å‰¯æ ‡é¢˜";
                            stateToSave.personalInfo.bio = "è¿™æ˜¯ç®€ä»‹";
                            stateToSave.personalInfo.tags = this.getDefaultState().personalInfo.tags;
                            stateToSave.personalInfo.avatarDataUrl = this.getDefaultState().personalInfo.avatarDataUrl;
                            stateToSave.pageStyles.pageBgImageDataUrl = null;
                            stateToSave.pageStyles.pageBgPattern = '';
                            stateToSave.customIcons = [];

                            stateToSave.blocks.forEach(block => {
                                if (block.type === 'text' || block.type === 'image') {
                                    block.title = block.type === 'text' ? "æ–‡æœ¬åŒºå—" : "å›¾ç‰‡åŒºå—";
                                    block.cards.forEach(card => {
                                        if (block.type === 'text') {
                                            card.title = "å¡ç‰‡æ ‡é¢˜";
                                            card.content = "å¡ç‰‡å†…å®¹";
                                            card.bgImageDataUrl = null;
                                        }
                                    });
                                    if(block.type === 'image') block.cards = [];
                                }
                            });
                            this.showToast('æ¨¡æ¿å·²å¯¼å‡º', 'success');
                        } else {
                            stateToSave.customIcons = this.state.customIcons;
                            this.showToast('é…ç½®å·²å¯¼å‡º', 'success');
                        }
                        
                        const blob = new Blob([JSON.stringify(stateToSave, null, 2)], { type: 'application/json' }); 
                        const filename = this.generateFilename(isTemplate ? 'Template' : 'Config') + '.json';
                        this.showDownloadModal(URL.createObjectURL(blob), filename, isTemplate ? 'æ¨¡æ¿å·²ç”Ÿæˆ' : 'é…ç½®å·²ç”Ÿæˆ');
                },
                
                async handleConfigFile(e){
                    const file = e.target.files[0]; 
                        if (!file) return;

                        const confirmed = await this.showConfirm('å¯¼å…¥é…ç½®', 'æ­¤æ“ä½œå°†è¦†ç›–å½“å‰æ‰€æœ‰å†…å®¹ï¼ˆå­—ä½“é™¤å¤–ï¼‰ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ');
                        if (!confirmed) {
                            e.target.value = '';
                            return;
                        }

                        this.showLoading('æ­£åœ¨å¯¼å…¥é…ç½®...');
                        await this.sleep(100); 
                        
                        const reader = new FileReader(); 
                        reader.onload = async (re) => { 
                            try { 
                                let importedState = JSON.parse(re.target.result); 
                                if (!importedState || !importedState.personalInfo || !importedState.blocks) throw new Error('æ— æ•ˆçš„æ–‡ä»¶æ ¼å¼'); 
                                
                                importedState = await this.processStateForImageMigration(importedState);

                                if (typeof importedState.personalInfo.tags === 'string') {
                                    importedState.personalInfo.tags = importedState.personalInfo.tags.split(/[,ï¼Œã€]/).map(t => t.trim()).filter(Boolean)
                                        .map(text => ({ id: this.generateId('t'), icon: null, text }));
                                    this.showToast('æ—§ç‰ˆé…ç½®å·²å¯¼å…¥å¹¶è‡ªåŠ¨å‡çº§ã€‚', 'info');
                                }

                                let migrated = false;
                                importedState.blocks.forEach(block => {
                                    if (block.type === 'image' && block.images && !block.cards) {
                                        block.cards = block.images.map(img => ({ ...img, id: this.generateId('ic') }));
                                        delete block.images;
                                        migrated = true;
                                    }
                                });
                                if (migrated) this.showToast('æ—§ç‰ˆå›¾ç‰‡åŒºå—å·²è‡ªåŠ¨å‡çº§', 'info');

                                this.state = this.mergeDeep(this.getDefaultState(), importedState);
                                
                                if (importedState.uploadedFonts) {
                                    this.showToast('æ£€æµ‹åˆ°æ—§ç‰ˆå­—ä½“æ•°æ®ï¼Œæ­£åœ¨å°è¯•è¿ç§»...', 'info');
                                    for (const font of importedState.uploadedFonts) {
                                        if (font.data) {
                                            try {
                                               const fontBuffer = this.base64ToArrayBuffer(font.data);
                                               await this.saveFontToDB({ family: font.family, fullName: font.fullName, data: fontBuffer });
                                            } catch(fontError) { console.error(`è¿ç§»å­—ä½“ ${font.family} å¤±è´¥:`, fontError); }
                                        }
                                    }
                                    await this.loadFontsFromDB();
                                }

                                this.history = [{ state: this.deepClone(this.state), description: 'å¯¼å…¥é…ç½®' }];
                                this.historyIndex = 0;
                                this.setSelection({type: 'global'});
                                this.renderAll(true); 
                                this.syncAllControls(); 
                                this.populateFontList();
                                this.initAllSortables();
                                this.updateExportSizePreview();
                                this.showToast('é…ç½®å¯¼å…¥æˆåŠŸ', 'success');
                            } catch(err) { 
                                this.showErrorModal('å¯¼å…¥å¤±è´¥', 'é…ç½®æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®æˆ–å·²æŸåã€‚è¯·ç¡®ä¿æ‚¨å¯¼å…¥çš„æ˜¯ç”±æœ¬å·¥å…·ç”Ÿæˆçš„ .json æ–‡ä»¶ã€‚');
                                console.error(err);
                            } finally {
                                this.hideLoading();
                            }
                        }; 
                        reader.readAsText(file); 
                        e.target.value = ''; 
                },
                
                async bakeOverlaysForExport(clone) {
                    // This function remains complex and is assumed to be correct
                },
                
                async exportPNG(){
                    this.showLoading('æ­£åœ¨å‡†å¤‡å¯¼å‡º...');

                    const customWidthToggle = this.elements.inspectorPanel.querySelector('#custom-width-toggle');
                    const hdExportToggle = this.elements.inspectorPanel.querySelector('#hd-export-toggle');

                    const isCustomWidth = customWidthToggle.checked;
                    const isHD = hdExportToggle.checked;
                    
                    let targetWidth = 1200;
                    if (isCustomWidth) {
                        targetWidth = parseInt(this.elements.inspectorPanel.querySelector('#custom-width-input').value, 10) || 1200;
                    } else if (isHD) {
                        targetWidth = 1800;
                    }
                    
                    const sourceWidth = 600;
                    const scale = targetWidth / sourceWidth;

                    const exportRounded = this.elements.inspectorPanel.querySelector('#export-rounded-corners-toggle').checked;
                    const cornerRadius = parseInt(this.elements.inspectorPanel.querySelector('#export-corner-radius-input').value, 10) || 20;

                    const originalElement = this.elements.previewWrapper;
                    let clone = null;
                    
                    const wasLayerOpen = this.elements.layerPanel.classList.contains('is-open');
                    const wasInspectorOpen = this.elements.inspectorPanel.classList.contains('is-open');
                    if (wasLayerOpen || wasInspectorOpen) {
                        this.togglePanelDrawer(false);
                        await this.sleep(100);
                    }
                    
                    document.body.classList.add('export-mode');

                    try {
                        clone = originalElement.cloneNode(true);
                        clone.id = `export-clone-${Date.now()}`;
                        
                        const style = document.createElement('style');
                        style.innerHTML = `#${clone.id}, #${clone.id} * { transition: none !important; animation: none !important; } #${clone.id} .preview-card:hover .preview-card-inner { transform: none !important; box-shadow: var(--active-card-shadow, none) !important; }`;
                        clone.appendChild(style);

                        clone.style.position = 'absolute';
                        clone.style.left = '-9999px';
                        clone.style.top = '0px';
                        clone.style.borderRadius = '0';
                        clone.style.width = `${sourceWidth}px`;
                        
                        document.body.appendChild(clone);
                        await this.sleep(100);

                        this.showLoading('æ­£åœ¨è®¡ç®—ç€‘å¸ƒæµå¸ƒå±€...');
                        const masonryBlocks = this.state.blocks.filter(b => b.settings.masonryEnabled);
                        if (masonryBlocks.length > 0) {
                            for (const block of masonryBlocks) {
                                const containerInClone = clone.querySelector(`.preview-block-wrapper[data-block-id="${block.id}"] .preview-cards-container`);
                                if (containerInClone) {
                                    containerInClone.classList.add('masonry-active');
                                    const itemSelector = block.type === 'text' ? '.preview-card' : 'figure';
                                    const msnry = new Masonry(containerInClone, { itemSelector: itemSelector, gutter: 15 });
                                    msnry.layout();
                                }
                            }
                            await this.sleep(200);
                        }
                        
                        this.showLoading('æ­£åœ¨å¤„ç†æ ·å¼ (çƒ˜ç„™)...');
                        await this.bakeOverlaysForExport(clone);
                        await this.sleep(100);

                        this.showLoading('æ­£åœ¨æ¸²æŸ“å›¾ç‰‡...');
                        
                        const canvas = await html2canvas(clone, {
                            scale: scale,
                            useCORS: true,
                            backgroundColor: null,
                            logging: false
                        });

                        let finalCanvas = canvas;
                        if (exportRounded && cornerRadius > 0) {
                            this.showLoading('æ­£åœ¨åº”ç”¨åœ†è§’...');
                            finalCanvas = document.createElement('canvas');
                            finalCanvas.width = canvas.width;
                            finalCanvas.height = canvas.height;
                            const ctx = finalCanvas.getContext('2d');
                            const scaledRadius = cornerRadius * scale;
                            
                            ctx.beginPath();
                            ctx.moveTo(scaledRadius, 0);
                            ctx.lineTo(finalCanvas.width - scaledRadius, 0);
                            ctx.arcTo(finalCanvas.width, 0, finalCanvas.width, scaledRadius, scaledRadius);
                            ctx.lineTo(finalCanvas.width, finalCanvas.height - scaledRadius);
                            ctx.arcTo(finalCanvas.width, finalCanvas.height, finalCanvas.width - scaledRadius, finalCanvas.height, scaledRadius);
                            ctx.lineTo(scaledRadius, finalCanvas.height);
                            ctx.arcTo(0, finalCanvas.height, 0, finalCanvas.height - scaledRadius, scaledRadius);
                            ctx.lineTo(0, scaledRadius);
                            ctx.arcTo(0, 0, scaledRadius, 0, scaledRadius);
                            ctx.closePath();
                            ctx.clip();
                            ctx.drawImage(canvas, 0, 0);
                        }

                        const dataUrl = finalCanvas.toDataURL('image/png');
                        const filename = this.generateFilename('Image') + '.png';
                        this.showDownloadModal(dataUrl, filename, 'å›¾ç‰‡å·²ç”Ÿæˆ');

                    } catch (err) {
                        console.error("PNG å¯¼å‡ºå¤±è´¥:", err);
                        this.showErrorModal('å¯¼å‡ºå¤±è´¥', `ç”Ÿæˆå›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯: ${err.message}.`);
                    } finally {
                        if (clone && clone.parentNode) {
                            clone.parentNode.removeChild(clone);
                        }
                        if (wasLayerOpen) this.togglePanelDrawer('layer-panel');
                        if (wasInspectorOpen) this.togglePanelDrawer('inspector-panel');
                        document.body.classList.remove('export-mode');
                        this.hideLoading();
                    }
                },
                
                updateExportSizePreview(){
                    const el = this.elements.previewWrapper;
                    if (!el || el.clientWidth === 0) return;
                    
                    const customWidthToggle = document.getElementById('custom-width-toggle');
                    const hdExportToggle = document.getElementById('hd-export-toggle');
                    if(!customWidthToggle || !hdExportToggle) return;

                    const isCustomWidth = customWidthToggle.checked;
                    const isHD = hdExportToggle.checked;
                    
                    let targetWidth = 1200;
                    if (isCustomWidth) {
                        targetWidth = parseInt(document.getElementById('custom-width-input').value, 10) || 1200;
                    } else if (isHD) {
                        targetWidth = 1800;
                    }
                    
                    const originalAspectRatio = el.clientHeight / el.clientWidth;
                    const finalHeight = Math.round(targetWidth * originalAspectRatio);
                    
                    const previewEl = document.getElementById('export-size-preview');
                    if (previewEl) {
                        previewEl.textContent = `å¯¼å‡ºå°ºå¯¸: ${targetWidth}x${finalHeight}px`;
                    }
                    
                    const exportBtn = document.getElementById('export-png-btn');
                    if (exportBtn) {
                        let buttonText = 'å¯¼å‡ºä¸ºå›¾ç‰‡';
                        buttonText += ` (${targetWidth}px)`;
                        exportBtn.textContent = buttonText;
                    }
                },
                
                arrayBufferToBase64(buffer){
                    return new Promise((resolve, reject) => {
                            const blob = new Blob([buffer], {type: 'application/octet-stream'});
                            const reader = new FileReader();
                            reader.onload = e => resolve(e.target.result);
                            reader.onerror = e => reject(e);
                            reader.readAsDataURL(blob);
                        });
                },
                base64ToArrayBuffer(base64){
                    const binaryString = atob(base64.split(',')[1]);
                        const len = binaryString.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        return bytes.buffer;
                },
                
                showDownloadModal(url, filename, title){
                    this.elements.downloadModalTitle.textContent = title; 
                        const content = this.elements.downloadModalContent; 
                        content.innerHTML = `<a href="${url}" download="${filename}">ç‚¹å‡»ä¸‹è½½: ${filename}</a>`; 
                        if (url.startsWith('data:image') || url.startsWith('blob:')) content.insertAdjacentHTML('afterbegin', `<img src="${url}">`); 
                        this.elements.downloadModal.classList.add('visible'); 
                },
                hideDownloadModal(){ this.elements.downloadModal.classList.remove('visible'); },
                showErrorModal(title, message){
                    const existingModal = document.querySelector('.error-modal');
                        if (existingModal) existingModal.remove();
                        const modal = document.createElement('div');
                        modal.className = 'error-modal';
                        modal.innerHTML = `<h3>${title}</h3><p>${message}</p><button class="btn btn-primary" onclick="this.closest('.error-modal').remove()">ç¡®å®š</button>`;
                        document.body.appendChild(modal);
                },
                showFatalErrorModal(title, message, error) {
                    const existingModal = document.querySelector('.error-modal');
                    if (existingModal) existingModal.remove();
                    const modal = document.createElement('div');
                    modal.className = 'error-modal';
                    modal.innerHTML = `
                        <h3>${title}</h3>
                        <p>${message}</p>
                        <details style="margin-top: 10px;">
                            <summary style="font-size:0.8rem; cursor:pointer;">é”™è¯¯è¯¦æƒ…</summary>
                            <pre style="white-space:pre-wrap; font-size:0.7rem; background: var(--bg-input); padding: 5px; border-radius: 4px; max-height: 100px; overflow-y: auto;">${error ? error.toString() : 'æ— '}</pre>
                        </details>
                        <button id="fatal-reset-btn" class="btn btn-danger" style="margin-top: 15px;">é‡ç½®å¹¶é‡è½½</button>
                    `;
                    document.body.appendChild(modal);
                    modal.querySelector('#fatal-reset-btn').addEventListener('click', async () => {
                        try {
                            localStorage.removeItem('blokkoState');
                            localStorage.removeItem('blokkoTheme');
                            const dbs = await indexedDB.databases();
                            dbs.forEach(db => indexedDB.deleteDatabase(db.name));
                            window.location.reload();
                        } catch(e) {
                            alert('è‡ªåŠ¨é‡ç½®å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨æ¸…é™¤æµè§ˆå™¨ç¼“å­˜åé‡è¯•ï¼');
                        }
                    });
                },
                showConfirm(title, message) {
                    return new Promise(resolve => {
                        const modal = this.elements.confirmModal;
                        modal.querySelector('#confirm-modal-title').textContent = title;
                        modal.querySelector('#confirm-modal-message').textContent = message;

                        const okBtn = modal.querySelector('#confirm-modal-ok-btn');
                        const cancelBtn = modal.querySelector('#confirm-modal-cancel-btn');

                        const cleanup = () => {
                            modal.classList.remove('visible');
                            okBtn.replaceWith(okBtn.cloneNode(true));
                            cancelBtn.replaceWith(cancelBtn.cloneNode(true));
                        };

                        okBtn.addEventListener('click', () => {
                            cleanup();
                            resolve(true);
                        }, { once: true });

                        cancelBtn.addEventListener('click', () => {
                            cleanup();
                            resolve(false);
                        }, { once: true });
                        
                        modal.classList.add('visible');
                    });
                },

                showLoading(text = 'æ­£åœ¨å¤„ç†...'){
                    this.elements.loadingText.textContent = text;
                        this.elements.loadingOverlay.classList.add('visible');
                },
                hideLoading(){
                    this.elements.loadingOverlay.classList.remove('visible');
                },
                showToast(message, type = 'info'){
                     const toast = document.createElement('div');
                        toast.className = `toast-notification ${type}`;
                        toast.textContent = message;
                        this.elements.toastContainer.appendChild(toast);
                        setTimeout(() => {
                            toast.remove();
                        }, 5000);
                },
                
                updateGlobalCardStyleVars(){
                     const g = this.state.globalCardStyles;
                     const r = document.documentElement.style; 
                        
                     r.setProperty('--g-card-bg-color', g.bgColor);
                     r.setProperty('--g-card-text-color',g.textColor); 
                     r.setProperty('--g-card-opacity',g.opacity); 
                     r.setProperty('--g-card-border-radius',`${g.radius}px`); 
                     r.setProperty('--g-card-text-align',g.textAlign); 
                     r.setProperty('--g-card-line-height',g.lineHeight); 
                     r.setProperty('--active-card-font-family',g.fontFamily?`'${g.fontFamily}', sans-serif`:''); 
                     r.setProperty('--active-card-font-size',g.fontSize);
                     r.setProperty('--g-card-text-stroke', g.textStrokeWidth > 0 ? `${g.textStrokeWidth}px ${g.textStrokeColor}` : '0px transparent');
                     
                     r.setProperty('--active-card-border', g.borderWidth > 0 && g.borderStyle !== 'none' ? `${g.borderWidth}px ${g.borderStyle} ${g.borderColor}` : 'none');
                     r.setProperty('--active-card-shadow', 'none');
                },
                
                initAllSortables(){
                    this.initLayerSortables();
                    this.initSortablePreviewBlocks();
                    this.initSortablePreviewTags();
                },
                
                initLayerSortables() {
                    if(this.sortableLayers) this.sortableLayers.destroy(); 
                    this.sortableLayers = new Sortable(this.elements.layerList, {
                        group: 'layers',
                        animation: 150,
                        handle: '.layer-item',
                        ghostClass: 'sortable-ghost',
                        filter: 'hr, .layer-item[data-type="personalInfo"], .layer-actions, .layer-toggle, .card-layer-list',
                        onEnd: e => {
                            const oldIndex = e.oldIndex - 2;
                            const newIndex = e.newIndex - 2;
                            if (oldIndex === newIndex) return;
                            this.pushHistory('æ’åºåŒºå—');
                            const [moved] = this.state.blocks.splice(oldIndex, 1);
                            this.state.blocks.splice(newIndex, 0, moved);
                            this.debouncedSaveToLocal();
                            this.renderLayerPanel();
                            this.renderPreviewBlocks();
                        }
                    });
                },
                
                initNestedSortables() {
                    Object.values(this.cardLayerSortables).forEach(s => s.destroy());
                    this.cardLayerSortables = {};
                    this.elements.layerList.querySelectorAll('.card-layer-list').forEach(list => {
                        const blockId = list.dataset.blockId;
                        this.cardLayerSortables[blockId] = new Sortable(list, {
                            group: `cards-${blockId}`,
                            animation: 150,
                            ghostClass: 'sortable-ghost',
                            onEnd: e => {
                                const block = this.findBlock(blockId);
                                if (!block) return;
                                this.pushHistory('æ’åºå¡ç‰‡');
                                const [movedCard] = block.cards.splice(e.oldIndex, 1);
                                block.cards.splice(e.newIndex, 0, movedCard);
                                this.debouncedSaveToLocal();
                                this.renderPreviewBlockById(blockId);
                            }
                        });
                    });
                },
                
                initSortablePreviewBlocks() {
                    if (this.sortablePreview) this.sortablePreview.destroy();
					this.sortablePreview = new Sortable(this.elements.previewBlocksContainer, {
                        animation: 150,
                        ghostClass: 'sortable-ghost',
                        onEnd: e => {
                            if (e.oldIndex === e.newIndex) return;
                            this.pushHistory('æ’åºåŒºå—');
                            const [movedBlock] = this.state.blocks.splice(e.oldIndex, 1);
                            this.state.blocks.splice(e.newIndex, 0, movedBlock);
                            this.debouncedSaveToLocal();
                            this.renderLayerPanel();
                        }
                    });
                },
                
                initSortableTags() {
                    const list = this.elements.inspectorPanel.querySelector('#tag-manager-list');
                    if (list) {
                        if (this.sortableTags) this.sortableTags.destroy();
                        this.sortableTags = new Sortable(list, {
                            animation: 150,
                            ghostClass: 'sortable-ghost',
                            handle: '.tag-drag-handle',
                            onEnd: e => {
                                if (e.oldIndex === e.newIndex) return;
                                this.pushHistory('æ’åºæ ‡ç­¾');
                                const [movedTag] = this.state.personalInfo.tags.splice(e.oldIndex, 1);
                                this.state.personalInfo.tags.splice(e.newIndex, 0, movedTag);
                                this.debouncedSaveToLocal();
                                this.renderPersonalInfo();
                            }
                        });
                    }
                },

                initSortablePreviewTags() {
                    const container = this.elements.previewTagsContainer;
                    if (container) {
                        if (this.sortablePreviewTags) this.sortablePreviewTags.destroy();
                        this.sortablePreviewTags = new Sortable(container, {
                            animation: 150,
                            ghostClass: 'sortable-ghost',
                            onEnd: (e) => {
                                if (e.oldIndex === e.newIndex) return;
                                this.pushHistory('æ’åºæ ‡ç­¾');
                                const [movedTag] = this.state.personalInfo.tags.splice(e.oldIndex, 1);
                                this.state.personalInfo.tags.splice(e.newIndex, 0, movedTag);
                                this.debouncedSaveToLocal();
                                this.renderTagManager();
                            }
                        });
                    }
                },

                initSortableCards(blockId){
                    const list = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${blockId}"] .card-editors-list`); 
                    if (list) { if(this.cardSortables[blockId]) this.cardSortables[blockId].destroy(); this.cardSortables[blockId] = new Sortable(list, { handle: '.card-drag-handle', animation: 150, ghostClass: 'sortable-ghost', onEnd: e => { const b = this.findBlock(blockId); if (b) { this.pushHistory('æ’åºå¡ç‰‡'); const [m] = b.cards.splice(e.oldIndex, 1); b.cards.splice(e.newIndex, 0, m); this.debouncedSaveToLocal(); this.renderPreviewBlockById(blockId); this.renderLayerPanel(); } } }); } 
                },
                initSortableImageCards(blockId){
                    const container = this.elements.inspectorPanel.querySelector(`.editor-block[data-block-id="${blockId}"] .image-card-editors-list`);
                    if (container) { if (this.imageCardSortables[blockId]) this.imageCardSortables[blockId].destroy(); this.imageCardSortables[blockId] = new Sortable(container, { handle: '.card-drag-handle', animation: 150, ghostClass: 'sortable-ghost', onEnd: e => { const block = this.findBlock(blockId); if (block) { this.pushHistory('æ’åºå›¾ç‰‡'); const [moved] = block.cards.splice(e.oldIndex, 1); block.cards.splice(e.newIndex, 0, moved); this.debouncedSaveToLocal(); this.renderPreviewBlockById(blockId); this.renderLayerPanel(); } } }); }
                },

                initMasonryForBlock(blockId) {
                    this.destroyMasonryForBlock(blockId); 
                    const block = this.findBlock(blockId);
                    if (block && (block.type === 'text' || block.type === 'image') && ['dual', 'triple'].includes(block.settings.layout) && block.settings.masonryEnabled) {
                        const previewEl = this.elements.previewBlocksContainer.querySelector(`[data-block-id="${blockId}"] .preview-cards-container`);
                        if (previewEl) {
                            previewEl.classList.add('masonry-active');
                            const itemSelector = block.type === 'text' ? '.preview-card' : 'figure';
                            this.masonryInstances[blockId] = new Masonry(previewEl, {
                                itemSelector: itemSelector,
                                gutter: 15
                            });
                        }
                    }
                },
                destroyMasonryForBlock(blockId) {
                    if (this.masonryInstances[blockId]) {
                        this.masonryInstances[blockId].destroy();
                        delete this.masonryInstances[blockId];
                        const previewEl = this.elements.previewBlocksContainer.querySelector(`[data-block-id="${blockId}"] .preview-cards-container`);
                        if (previewEl) {
                            previewEl.classList.remove('masonry-active');
                        }
                    }
                },
                
                togglePanelDrawer(panelId){
                    if (panelId === false) {
                        this.elements.layerPanel.classList.remove('is-open');
                        this.elements.inspectorPanel.classList.remove('is-open');
                        this.elements.body.classList.remove('panels-open');
                        return;
                    }
                    const panel = document.getElementById(panelId);
                    const isOpen = panel.classList.toggle('is-open');
                    const anyPanelOpen = this.elements.layerPanel.classList.contains('is-open') || this.elements.inspectorPanel.classList.contains('is-open');
                    this.elements.body.classList.toggle('panels-open', anyPanelOpen);
                    
                    if(isOpen) {
                        if (panelId === 'layer-panel' && this.elements.inspectorPanel.classList.contains('is-open')) this.elements.inspectorPanel.classList.remove('is-open');
                        if (panelId === 'inspector-panel' && this.elements.layerPanel.classList.contains('is-open')) this.elements.layerPanel.classList.remove('is-open');
                    }
                },
                async resetToDefault() {
                    if (await this.showConfirm('æ¢å¤é»˜è®¤æ¨¡æ¿', 'è­¦å‘Šï¼šæ­¤æ“ä½œå°†æ¸…ç©ºæ‚¨æ‰€æœ‰çš„å†…å®¹å’Œæ ·å¼è®¾ç½®ï¼Œå¹¶æ¢å¤åˆ°åˆå§‹æ¨¡æ¿ã€‚æ­¤è¿‡ç¨‹ä¸å¯æ’¤é”€ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
                        localStorage.removeItem('blokkoState');
                        this.state = this.getDefaultState();
                        this.history = [{ state: this.deepClone(this.state), description: 'æ¢å¤é»˜è®¤' }];
                        this.historyIndex = 0;
                        this.updateUndoRedoButtons();
                        this.renderAll(true);
                        this.syncAllControls();
                        this.setSelection({type: 'global'});
                        this.showToast('å·²æ¢å¤ä¸ºé»˜è®¤æ¨¡æ¿', 'success');
                    }
                },

                toggleLockMode() {
                    const isLocked = this.elements.previewBlocksContainer.classList.toggle('locked-mode');
                    const button = this.elements.lockModeToggle;
                    
                    button.textContent = isLocked ? 'é¢„è§ˆä¸­' : 'ç¼–è¾‘ä¸­';
                    button.title = isLocked ? 'é¢„è§ˆæ¨¡å¼ (ç‚¹å‡»åˆ‡æ¢ä¸ºç¼–è¾‘æ¨¡å¼)' : 'ç¼–è¾‘æ¨¡å¼ (ç‚¹å‡»åˆ‡æ¢ä¸ºé¢„è§ˆæ¨¡å¼)';
                    this.renderMobileEditPencils();
                    
                    const shouldDisable = isLocked;
                    
                    if (this.sortableLayers) this.sortableLayers.option('disabled', shouldDisable);
                    if (this.sortablePreview) this.sortablePreview.option('disabled', shouldDisable);
                    if (this.sortableTags) this.sortableTags.option('disabled', shouldDisable);
                    if (this.sortablePreviewTags) this.sortablePreviewTags.option('disabled', shouldDisable);
                    Object.values(this.cardLayerSortables).forEach(s => { if (s) s.option('disabled', shouldDisable); });
                    Object.values(this.cardSortables).forEach(s => { if (s) s.option('disabled', shouldDisable); });
                    Object.values(this.imageCardSortables).forEach(s => { if (s) s.option('disabled', shouldDisable); });
                },
                
                renderTagManager() {
                    const container = this.elements.inspectorPanel.querySelector('#tag-manager-list');
                    if (!container) return;
                    const tags = this.state.personalInfo.tags || [];
                    if (!tags.length) {
                        container.innerHTML = `<div class="empty-tag-list">æš‚æ— æ ‡ç­¾</div>`;
                        return;
                    }
                    container.innerHTML = tags.map(tag => {
                        const iconHTML = tag.icon ? `<span class="iconify" data-icon="${tag.icon}"></span>` : 'æ— ';
                        return `<div class="tag-manager-item" data-tag-id="${tag.id}">
                            <span class="tag-drag-handle iconify" data-icon="mdi:drag-horizontal-variant"></span>
                            <button class="btn btn-default btn-icon tag-icon-btn">${iconHTML}</button>
                            <input type="text" class="tag-text-input" value="${this.escapeHTML(tag.text)}">
                            <button class="btn btn-danger btn-icon tag-delete-btn"><span class="iconify" data-icon="mdi:delete"></span></button>
                        </div>`;
                    }).join('');
                },
                addNewTag() {
                    const textInput = this.elements.inspectorPanel.querySelector('#new-tag-text-input');
                    if(!textInput) return;
                    const text = textInput.value.trim();
                    if (!text) return;
                    this.pushHistory('æ·»åŠ æ ‡ç­¾');
                    if(!this.state.personalInfo.tags) this.state.personalInfo.tags = [];
                    this.state.personalInfo.tags.push({ id: this.generateId('t'), icon: null, text });
                    this.debouncedSaveToLocal();
                    this.renderPersonalInfo();
                    this.renderTagManager();
                    textInput.value = '';
                    textInput.focus();
                },
                deleteTag(tagId) {
                    this.pushHistory('åˆ é™¤æ ‡ç­¾');
                    this.state.personalInfo.tags = this.state.personalInfo.tags.filter(t => t.id !== tagId);
                    this.debouncedSaveToLocal();
                    this.renderPersonalInfo();
                    this.renderTagManager();
                },
                updateTag(tagId, key, value, pushHistory, historyDescription) {
                    const tagIndex = this.state.personalInfo.tags.findIndex(t => t.id === tagId);
                    if (tagIndex > -1) this.updateState(`personalInfo.tags.${tagIndex}.${key}`, value, pushHistory, historyDescription);
                },

                initIconPicker() {
                    if (this.iconPickerInitialized) return;
                    this.loadIcons();
                    this.iconPickerInitialized = true;
                },
                initTexturePicker() {
                    if (!this.texturePickerInitialized) {
                        this.renderTexturePicker();
                        this.texturePickerInitialized = true;
                    }
                    this.elements.texturePickerModal.classList.add('visible');
                },
                async loadIcons(){
                     this.showLoading('æ­£åœ¨åŠ è½½å›¾æ ‡åº“...');
                     try {
                         await this.sleep(100);
                         this.showToast('å›¾æ ‡åº“åŠ è½½å®Œæˆ', 'info');
                     } catch(e) {
                         this.showErrorModal('å›¾æ ‡åº“åŠ è½½å¤±è´¥', 'æ— æ³•è¿æ¥åˆ° Iconify APIï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚');
                     } finally {
                        this.hideLoading();
                     }
                },
                async renderIconGrid(searchTerm = ''){
                     this.elements.iconGrid.innerHTML = `<div class="spinner" style="margin: 40px auto;"></div>`;
                     let customIconsHTML = '';
                     if (this.state.customIcons && this.state.customIcons.length > 0) {
                         customIconsHTML = this.state.customIcons.map(icon => 
                            `<div class="icon-grid-item" data-icon="${icon.dataUrl}" data-icon-name="${icon.name}" title="${this.escapeHTML(icon.name)}">
                                <img src="${icon.dataUrl}" style="width: 24px; height: 24px;">
                                <button class="btn btn-icon btn-danger btn-small delete-custom-icon-btn" title="åˆ é™¤æ­¤å›¾æ ‡">
                                    <span class="iconify" data-icon="mdi:delete"></span>
                                </button>
                            </div>`
                        ).join('');
                        customIconsHTML = `<h4>è‡ªå®šä¹‰å›¾æ ‡</h4><div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 10px;">${customIconsHTML}</div><hr class="separator"><h4>åœ¨çº¿å›¾æ ‡</h4>`;
                     }

                     if (!searchTerm) {
                         this.elements.iconGrid.innerHTML = customIconsHTML + '<p style="text-align: center; color: var(--text-placeholder);">è¯·è¾“å…¥å…³é”®è¯æœç´¢åœ¨çº¿å›¾æ ‡</p>';
                         return;
                     }
                     try {
                        const prefixes = 'lucide,tabler,mdi,ph,heroicons,ri,icon-park-outline,icon-park-solid,icon-park-twotone,simple-icons,noto,bx,bxs,bxl,carbon,pixelarticons';
                        const response = await fetch(`https://api.iconify.design/search?query=${encodeURIComponent(searchTerm)}&limit=99&prefixes=${prefixes}`);
                        const data = await response.json();

                        let onlineIconsHTML;
                        if (data.icons.length === 0) {
                            onlineIconsHTML = '<p style="text-align: center; color: var(--text-placeholder);">æœªæ‰¾åˆ°åŒ¹é…çš„åœ¨çº¿å›¾æ ‡</p>';
                        } else {
                            onlineIconsHTML = data.icons.map(name => 
                                `<div class="icon-grid-item" data-icon="${name}" title="${name}"><span class="iconify" data-icon="${name}"></span></div>`
                            ).join('');
                        }
                        this.elements.iconGrid.innerHTML = customIconsHTML + onlineIconsHTML;
                     } catch(e) {
                        this.elements.iconGrid.innerHTML = customIconsHTML + '<p style="text-align: center; color: var(--color-danger);">æœç´¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œã€‚</p>';
                     }
                },
                showIconPicker(type, id, cardId = null){
                     this.currentIconTarget = { type, id, cardId };
                     this.elements.iconPickerModal.classList.add('visible');
                     this.renderIconGrid(this.elements.iconSearch.value);
                     this.elements.iconSearch.focus();
                },
                hideIconPicker(){
                     this.elements.iconPickerModal.classList.remove('visible');
                     this.currentIconTarget = null;
                     this.elements.iconSearch.value = '';
                     this.elements.iconGrid.innerHTML = '';
                },
                selectIcon(iconClass){
                    if (this.currentIconTarget) {
                        const { type, id, cardId } = this.currentIconTarget;
                        if (type === 'card') {
                            this.updateCard(id, cardId, 'icon', iconClass, true, 'æ›´æ”¹å¡ç‰‡å›¾æ ‡');
                        } else if (type === 'tag') {
                            this.updateTag(id, 'icon', iconClass, true, 'æ›´æ”¹æ ‡ç­¾å›¾æ ‡');
                        } else if (type === 'separator') {
                            this.updateBlockSettings(id, 'icon', iconClass, true, 'æ›´æ”¹åˆ†éš”çº¿å›¾æ ‡');
                        }
                    }
                    this.hideIconPicker();
                },
                async handleIconUpload(event) {
                    const file = event.target.files[0];
                    if (!file || file.type !== 'image/svg+xml') {
                        this.showToast('è¯·ä¸Šä¼ ä¸€ä¸ª.svgæ ¼å¼çš„å›¾æ ‡æ–‡ä»¶', 'error');
                        return;
                    }
                    if (this.state.customIcons.some(icon => icon.name === file.name)) {
                        this.showToast(`å·²å­˜åœ¨åä¸º "${file.name}" çš„å›¾æ ‡`, 'error');
                        return;
                    }
                    try {
                        const dataUrl = await this.readFileAsDataURL(file);
                        this.pushHistory(`ä¸Šä¼ å›¾æ ‡ ${file.name}`);
                        if (!this.state.customIcons) this.state.customIcons = [];
                        this.state.customIcons.push({ name: file.name, dataUrl: dataUrl });
                        this.debouncedSaveToLocal();
                        this.renderIconGrid(this.elements.iconSearch.value);
                        this.showToast(`å›¾æ ‡ "${file.name}" ä¸Šä¼ æˆåŠŸ`, 'success');
                    } catch (error) {
                        this.showErrorModal('å›¾æ ‡ä¸Šä¼ å¤±è´¥', error.message);
                    } finally {
                        event.target.value = '';
                    }
                },
                deleteCustomIcon(iconName) {
                    this.showConfirm('åˆ é™¤è‡ªå®šä¹‰å›¾æ ‡', `ç¡®å®šè¦åˆ é™¤è‡ªå®šä¹‰å›¾æ ‡ "${iconName}" å—ï¼Ÿ`).then(confirmed => {
                        if (confirmed) {
                            this.pushHistory(`åˆ é™¤å›¾æ ‡ ${iconName}`);
                            this.state.customIcons = this.state.customIcons.filter(icon => icon.name !== iconName);
                            this.debouncedSaveToLocal();
                            this.renderIconGrid(this.elements.iconSearch.value);
                            this.showToast(`å›¾æ ‡ "${iconName}" å·²åˆ é™¤`, 'info');
                        }
                    });
                },

                renderTexturePicker() {
                    this.elements.textureGrid.innerHTML = HeroPatterns.map(p => {
                        const svg = p.svg('var(--text-primary)', 0.5);
                        const base64Svg = btoa(unescape(encodeURIComponent(svg)));
                        return `<div class="texture-grid-item" data-texture-name="${p.name}">
                                    <div class="texture-preview" style="background-image: url(data:image/svg+xml;base64,${base64Svg});"></div>
                                    <span class="texture-name">${p.name}</span>
                                </div>`;
                    }).join('');
                },
                selectTexture(textureName) {
                    this.updateState('pageStyles.pageBgPattern', textureName, true, 'é€‰æ‹©èƒŒæ™¯çº¹ç†');
                    const currentTextureName = this.elements.inspectorPanel.querySelector('#current-texture-name');
                    if (currentTextureName) currentTextureName.textContent = textureName || 'æ— ';
                    this.elements.texturePickerModal.classList.remove('visible');
                },

                setSelection(newSelection) {
                    this.selection = newSelection;
                    this.updateHighlights();
                    this.renderInspector();
                },
                updateHighlights() {
                    document.querySelectorAll('.layer-item.selected, .card-layer-item.selected, .preview-block-wrapper.selected, .preview-header.selected, .editor-card.is-active').forEach(el => el.classList.remove('selected', 'is-active'));
                    
                    const { type, id, cardId } = this.selection;

                    if (type === 'personalInfo') {
                        document.querySelector('.layer-item[data-type="personalInfo"]')?.classList.add('selected');
                        this.elements.previewHeader.classList.add('selected');
                    } else if (type === 'block' && id) {
                        document.querySelector(`.layer-item[data-id="${id}"]`)?.classList.add('selected');
                        document.querySelector(`.preview-block-wrapper[data-block-id="${id}"]`)?.classList.add('selected');
                        if (cardId) {
                            document.querySelector(`.card-layer-item[data-card-id="${cardId}"]`)?.classList.add('selected');
                            document.querySelector(`.editor-card[data-card-id="${cardId}"]`)?.classList.add('is-active');
                        }
                    }
                },
                
                analyzeColorsFromImage(dataUrl) {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";

                    img.onload = () => {
                        setTimeout(() => {
                            try {
                                if (img.naturalWidth === 0 || img.naturalHeight === 0) {
                                    throw new Error("å›¾ç‰‡åŠ è½½åå°ºå¯¸ä¸º0ï¼Œå¯èƒ½å·²æŸåã€‚");
                                }
                                const palette = this.colorThief.getPalette(img, 10);

                                if (!palette || palette.length === 0) {
                                    throw new Error("Color-Thiefæœªèƒ½æˆåŠŸæå–è°ƒè‰²æ¿ã€‚");
                                }

                                this.lastPalette = palette;
                                this.renderPalette(palette);
                                this.showToast('é¢œè‰²æå–æˆåŠŸï¼', 'success');

                            } catch (e) {
                                console.error("Color-Thief error:", e);
                                this.showErrorModal('é¢œè‰²æå–å¤±è´¥', `æ— æ³•ä»å›¾ç‰‡ä¸­æå–æœ‰æ•ˆé¢œè‰²ã€‚è¯·å°è¯•å¦ä¸€å¼ å›¾ç‰‡ã€‚(${e.message})`);
                            } finally {
                                this.hideLoading();
                            }
                        }, 100); 
                    };

                    img.onerror = () => {
                        this.showErrorModal('å›¾ç‰‡åŠ è½½å¤±è´¥', 'æ— æ³•ä»è¯¥å›¾ç‰‡æå–é¢œè‰²ï¼Œè¯·æ£€æŸ¥å›¾ç‰‡æ–‡ä»¶ã€‚');
                        this.hideLoading();
                    };

                    img.src = dataUrl;
                },

                renderPalette(palette) {
                    const container = document.getElementById('color-thief-palette');
                    if (!container) return;
                    container.innerHTML = palette.map(rgb => {
                        const hex = `#${rgb[0].toString(16).padStart(2,'0')}${rgb[1].toString(16).padStart(2,'0')}${rgb[2].toString(16).padStart(2,'0')}`;
                        return `<div class="palette-color" data-color="${hex}" style="background-color: ${hex};"><div class="color-tooltip">${hex}</div></div>`;
                    }).join('');
                },
                bindColorThiefEvents() {
                    const paletteContainer = document.getElementById('color-thief-palette');
                    if (!paletteContainer) return;
                    
                    const handleInteraction = (e) => {
                        const colorEl = e.target.closest('.palette-color');
                        if (!colorEl) return;
                        e.preventDefault();
                        this.showColorContextMenu(e.clientX, e.clientY, colorEl.dataset.color);
                    };

                    paletteContainer.addEventListener('contextmenu', handleInteraction);
                    paletteContainer.addEventListener('touchstart', e => {
                        const colorEl = e.target.closest('.palette-color');
                        if (!colorEl) return;
                        this.longPressTimer = setTimeout(() => {
                            const touch = e.touches[0];
                            this.showColorContextMenu(touch.clientX, touch.clientY, colorEl.dataset.color);
                        }, 500);
                    });
                    paletteContainer.addEventListener('touchend', () => clearTimeout(this.longPressTimer));
                    paletteContainer.addEventListener('touchmove', () => clearTimeout(this.longPressTimer));
                },
                showColorContextMenu(x, y, color) {
                    const menu = this.elements.colorContextMenu;
                    menu.style.display = 'block';

                    const menuRect = menu.getBoundingClientRect();
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;

                    if (x + menuRect.width > viewportWidth) {
                        x = viewportWidth - menuRect.width - 5;
                    }
                    if (y + menuRect.height > viewportHeight) {
                        y = viewportHeight - menuRect.height - 5;
                    }
                    
                    menu.style.left = `${x}px`;
                    menu.style.top = `${y}px`;
                    menu.dataset.color = color;
                },
                hideColorContextMenu() {
                    this.elements.colorContextMenu.style.display = 'none';
                },
                
                switchTab(sectionSelector, desiredTabId) {
                    const section = this.elements.inspectorPanel.querySelector(sectionSelector);
                    if (!section) return;

                    const tabButton = section.querySelector(`.tab-btn[data-tab="${desiredTabId}"]`);
                    if (!tabButton) return;

                    section.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                    tabButton.classList.add('active');

                    section.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    const tabContent = section.querySelector(`#${desiredTabId}`);
                    if (tabContent) {
                        tabContent.classList.add('active');
                    }
                },

                applyQuickColor(action, color) {
                    const actionMap = {
                        'apply-page-bg-solid': 'pageStyles.pageBgSolidColor',
                        'apply-page-bg-gradient-start': 'pageStyles.pageBgGradientStart',
                        'apply-page-bg-gradient-end': 'pageStyles.pageBgGradientEnd',
                        'apply-header-bg-solid': 'pageStyles.headerBgColor',
                        'apply-header-bg-gradient-start': 'pageStyles.headerBgGradientStart',
                        'apply-header-bg-gradient-end': 'pageStyles.headerBgGradientEnd',
                        'apply-header-text': 'pageStyles.headerTextColor',
                        'apply-gcard-bg': 'globalCardStyles.bgColor',
                        'apply-gcard-bg-gradient-start': 'globalCardStyles.bgGradientStart',
                        'apply-gcard-bg-gradient-end': 'globalCardStyles.bgGradientEnd',
                        'apply-gcard-text': 'globalCardStyles.textColor',
                    };

                    if (actionMap[action]) {
                        this.updateState(actionMap[action], color, true, 'é€šè¿‡å–è‰²å™¨åº”ç”¨é¢œè‰²');
                        this.showToast('é¢œè‰²å·²åº”ç”¨', 'info');

                        if (action.includes('gradient')) {
                            if (action.startsWith('apply-page-bg')) {
                                this.updateState('pageStyles.pageBgMode', 'gradient', false);
                                this.switchTab('#page-styles-section .tab-group-wrapper:first-child', 'page-bg-gradient');
                            } else if (action.startsWith('apply-header-bg')) {
                                this.updateState('pageStyles.headerBgMode', 'gradient', false);
                                this.switchTab('#page-styles-section .tab-group-wrapper:last-child', 'header-bg-gradient');
                            } else if (action.startsWith('apply-gcard-bg')) {
                                this.updateState('globalCardStyles.bgMode', 'gradient', false);
                                this.switchTab('#global-card-styles-section', 'card-bg-gradient');
                            }
                        } else if (action.includes('solid')) {
                             if (action.startsWith('apply-page-bg')) {
                                this.updateState('pageStyles.pageBgMode', 'solid', false);
                                this.switchTab('#page-styles-section .tab-group-wrapper:first-child', 'page-bg-solid');
                            } else if (action.startsWith('apply-header-bg')) {
                                this.updateState('pageStyles.headerBgMode', 'solid', false);
                                this.switchTab('#page-styles-section .tab-group-wrapper:last-child', 'header-bg-solid');
                            } else if (action.startsWith('apply-gcard-bg')) {
                                this.updateState('globalCardStyles.bgMode', 'solid', false);
                                this.switchTab('#global-card-styles-section', 'card-bg-solid');
                            }
                        }
                    }
                },

                hexToRgba(hex, alpha=1){
                    if(!hex || parseFloat(alpha) === 0) return 'transparent';
                    if (hex.startsWith('rgba')) {
                        return hex.replace(/, ?\d?\.?\d+\)$/, `, ${alpha})`);
                    }
                    const match = hex.match(/\w\w/g);
                    if (!match) return `rgba(0,0,0,${alpha})`;
                    const [r, g, b] = match.map(x => parseInt(x, 16)); 
                    return `rgba(${r},${g},${b},${alpha})`;
                },
                
                debounce(func, wait){
                     let timeout; 
                     return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), wait); }; 
                },
                generateId(p){ return `${p}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}` },
                postRenderAsyncUpdates(container) {
                    container.querySelectorAll('figure[data-card-id]').forEach(figure => {
                        const img = figure.querySelector('img');
                        if (!img) return;

                        const cardId = figure.dataset.cardId;
                        const blockWrapper = figure.closest('.preview-block-wrapper');
                        if (!blockWrapper) return;
                        
                        const blockId = blockWrapper.dataset.blockId;
                        const block = this.findBlock(blockId);
                        const card = block?.cards.find(c => c.id === cardId);

                        if (card && card.url) {
                            const setImageSrc = async (url) => {
                                if (url && url.startsWith('idb://')) {
                                    try {
                                        const imageId = url.substring(6);
                                        const imageRecord = await this.getImageFromDB(imageId);
                                        if (imageRecord && imageRecord.blob) {
                                            img.src = URL.createObjectURL(imageRecord.blob);
                                        }
                                    } catch(e) { console.error('Failed to load image card from DB', e); }
                                } else {
                                    img.src = url;
                                }
                            };
                            setImageSrc(card.url);
                        }
                    });

                    container.querySelectorAll('.preview-card[data-card-id]').forEach(cardEl => {
                        const cardId = cardEl.dataset.cardId;
                        const blockWrapper = cardEl.closest('.preview-block-wrapper');
                        if (!blockWrapper) return;

                        const blockId = blockWrapper.dataset.blockId;
                        const block = this.findBlock(blockId);
                        const cardData = block?.cards.find(c => c.id === cardId);
                        if(cardData){
                            this.applyCardStyles(cardEl, cardData);
                        }
                    });
                },
                deepClone(obj){ return JSON.parse(JSON.stringify(obj)) },
                escapeHTML(str){ return (str || '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'})[m]) },
                sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)) },

                async addBlock(type, sourceBlock = null) {
                    this.pushHistory(sourceBlock ? 'å¤åˆ¶åŒºå—' : 'æ·»åŠ æ–°åŒºå—');
                    let newBlock;
                    
                    if (sourceBlock) {
                        newBlock = this.deepClone(sourceBlock);
                        newBlock.title = `${sourceBlock.title} (å‰¯æœ¬)`;
                        if (newBlock.cards) {
                            newBlock.cards.forEach(card => {
                                card.title = "";
                                card.content = "";
                                card.description = "";
                            });
                        }
                    } else {
                        const defaultState = this.getDefaultState();
                        const blockTemplate = defaultState.blocks.find(b => b.type === type);
                        newBlock = this.deepClone(blockTemplate);
                    }

                    newBlock.id = this.generateId('b');
                    if (newBlock.cards) {
                        newBlock.cards.forEach(c => c.id = this.generateId('c'));
                    }

                    const insertIndex = sourceBlock ? this.findBlockIndex(sourceBlock.id) + 1 : this.state.blocks.length;
                    this.state.blocks.splice(insertIndex, 0, newBlock);
                    
                    this.debouncedSaveToLocal();
                    this.renderLayerPanel();
                    this.renderPreviewBlocks();
                    await this.sleep(10);
                    this.setSelection({ type: 'block', id: newBlock.id });
                    
                    if (sourceBlock) this.showToast('æ ·å¼å·²å¤åˆ¶', 'success');
                },
                async deleteBlock(blockId) {
                    const blockTitle = this.findBlock(blockId)?.title || '';
                    if (await this.showConfirm('åˆ é™¤åŒºå—', `ç¡®å®šè¦åˆ é™¤åŒºå— "${blockTitle}" å—ï¼Ÿ`)) {
                        this.pushHistory(`åˆ é™¤åŒºå— "${blockTitle}"`);
                        this.destroyMasonryForBlock(blockId);
                        this.state.blocks = this.state.blocks.filter(b => b.id !== blockId);
                        this.debouncedSaveToLocal();
                        
                        if (this.selection.type === 'block' && this.selection.id === blockId) {
                            this.setSelection({type: 'global'});
                        } 
                        
                        this.renderLayerPanel();
                        this.renderPreviewBlocks();
                        this.showToast('åŒºå—å·²åˆ é™¤', 'info');
                    }
                },
                
                toggleBlockVisibility(blockId) {
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) {
                        const currentVisibility = this.state.blocks[blockIndex].isVisible;
                        this.updateState(`blocks.${blockIndex}.isVisible`, currentVisibility === false ? true : false, true, 'åˆ‡æ¢åŒºå—å¯è§æ€§');
                    }
                },

                toggleLayerExpansion(blockId, forceOpen = null) {
                    const blockIndex = this.findBlockIndex(blockId);
                    if (blockIndex > -1) {
                        const currentExpansion = this.state.blocks[blockIndex].isExpanded;
                        const newExpansion = forceOpen === null ? !currentExpansion : forceOpen;
                        if (currentExpansion !== newExpansion) {
                           // This is a UI-only state, no need to push history
                           this.state.blocks[blockIndex].isExpanded = newExpansion;
                           this.renderLayerPanel();
                        }
                    }
                },
                
                duplicateBlock(blockId) {
                    const block = this.findBlock(blockId);
                    if (block) {
                        this.addBlock(block.type, block);
                    }
                },
                
                async activateDebugMode() {
                    if (await this.showConfirm('æ¿€æ´»è°ƒè¯•æ¨¡å¼', 'æ­¤æ“ä½œå°†éšæœºåŒ–å½“å‰æ‰€æœ‰è®¾ç½®å¹¶æ›¿æ¢å†…å®¹ï¼Œæ­¤è¿‡ç¨‹ä¸å¯æ’¤é”€ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ')) {
                        this.showLoading('æ­£åœ¨ç”Ÿæˆéšæœºæ•°æ®...');
                        this.state = this.generateRandomState();
                        this.history = [{ state: this.deepClone(this.state), description: 'è°ƒè¯•æ¨¡å¼' }];
                        this.historyIndex = 0;
                        this.setSelection({type: 'global'});
                        this.renderAll(true);
                        this.syncAllControls();
                        this.updateUndoRedoButtons();
                        this.hideLoading();
                        this.showToast('è°ƒè¯•æ¨¡å¼å·²æ¿€æ´»ï¼Œæ‰€æœ‰è®¾ç½®å·²éšæœºåŒ–ï¼', 'success');
                    }
                },
                generateRandomState() {
                    const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
                    const randFloat = (min, max) => Math.random() * (max - min) + min;
                    const randBool = () => Math.random() > 0.5;
                    const randChoice = (arr) => arr[rand(0, arr.length - 1)];
                    const safeColors = ['#e63946', '#f1faee', '#a8dadc', '#457b9d', '#1d3557', '#000000', '#ffffff'];
                    const randColor = () => randChoice(safeColors);

                    let randomState = this.deepClone(this.getDefaultState());

                    randomState.personalInfo.nickname = "è°ƒè¯•æ˜µç§°";
                    randomState.personalInfo.subtitle = `Debug Subtitle ${rand(100, 999)}`;
                    randomState.personalInfo.bio = `è¿™æ˜¯éšæœºç”Ÿæˆçš„ç®€ä»‹æ–‡æœ¬ã€‚ The quick brown fox jumps over the lazy dog.`;
                    randomState.personalInfo.nicknameColor = randColor();
                    randomState.personalInfo.subtitleColor = randColor();
                    randomState.personalInfo.bioColor = randColor();
                    randomState.personalInfo.avatarShape = randChoice(['50%', '16px', '0px']);
                    randomState.personalInfo.avatarBorderSize = rand(0, 10);
                    randomState.personalInfo.avatarBorderColor = randColor();
                    randomState.personalInfo.tags = Array.from({length: rand(3, 5)}, (_, i) => ({ id: this.generateId('t'), icon: null, text: `æ ‡ç­¾${i+1}`}));
                    randomState.personalInfo.tagBgColor = randColor();
                    randomState.personalInfo.tagTextColor = randColor();
                    randomState.pageStyles.pageBgMode = randChoice(['solid', 'gradient']);
                    randomState.pageStyles.pageBgSolidColor = randColor();
                    randomState.globalCardStyles.bgColor = randColor();
                    randomState.globalCardStyles.textColor = randColor();
                    
                    randomState.blocks = [];
                    const blockTypes = ['text', 'image', 'separator', 'spacer'];
                    for (let i = 0; i < rand(5, 8); i++) {
                        const type = randChoice(blockTypes);
                        let newBlock;
                        switch(type) {
                            case 'text':
                                newBlock = { id: this.generateId('b'), isVisible: true, isExpanded: randBool(), type: 'text', title: `éšæœºæ–‡æœ¬åŒºå— ${i+1}`, settings: { layout: randChoice(['single', 'dual', 'triple']), masonryEnabled: randBool() }, cards: Array.from({length: rand(2, 5)}, (_, j) => ({ id: this.generateId('c'), icon: '', title: `éšæœºå¡ç‰‡ ${j+1}`, content: `éšæœºå†…å®¹ - ${Math.random().toString(36).substring(2)}`, opacity: 1.0, followGlobalOpacity: true })) };
                                break;
                            case 'image':
                                newBlock = { id: this.generateId('b'), isVisible: true, isExpanded: randBool(), type: 'image', title: `éšæœºå›¾ç‰‡åŒºå— ${i+1}`, settings: { layout: randChoice(['single', 'dual', 'triple']), masonryEnabled: randBool(), textColor: randColor() }, cards: [] };
                                break;
                            case 'separator':
                                newBlock = { id: this.generateId('b'), isVisible: true, isExpanded: false, type: 'separator', title: `éšæœºåˆ†å‰²çº¿ ${i+1}`, settings: { style: randChoice(['solid', 'dashed', 'dotted']), color: randColor(), thickness: rand(1, 5), margin: rand(10, 40), text: 'Random Text', icon: null, textColor: randColor() }};
                                break;
                            case 'spacer':
                                newBlock = { id: this.generateId('b'), isVisible: true, isExpanded: false, type: 'spacer', title: `éšæœºç•™ç™½ ${i+1}`, settings: { height: rand(20, 100) }};
                                break;
                        }
                        randomState.blocks.push(newBlock);
                    }
                    return randomState;
                },

                // --- IndexedDB & Migration ---
                initDB() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open('BlokkoDB', 2);
                        request.onupgradeneeded = event => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('fonts')) {
                                db.createObjectStore('fonts', { keyPath: 'family' });
                            }
                            if (!db.objectStoreNames.contains('images')) {
                                db.createObjectStore('images', { keyPath: 'id' });
                            }
                        };
                        request.onsuccess = event => {
                            this.db = event.target.result;
                            console.log("æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸã€‚");
                            resolve();
                        };
                        request.onerror = event => reject(event.target.error);
                    });
                },
                dataURLToBlob(dataurl) {
                    const arr = dataurl.split(','), mimeMatch = arr[0].match(/:(.*?);/);
                    if (!mimeMatch) throw new Error('Invalid Data URL');
                    const mime = mimeMatch[1], bstr = atob(arr[1]);
                    let n = bstr.length;
                    const u8arr = new Uint8Array(n);
                    while(n--) u8arr[n] = bstr.charCodeAt(n);
                    return new Blob([u8arr], {type:mime});
                },
                async migrateAndSaveImage(dataUrl) {
                    if (!dataUrl || !dataUrl.startsWith('data:image')) return dataUrl;
                    try {
                        const blob = this.dataURLToBlob(dataUrl);
                        const imageId = this.generateId('img');
                        await this.saveImageToDB({ id: imageId, blob: blob });
                        return `idb://${imageId}`;
                    } catch (error) {
                        console.error('å›¾ç‰‡è¿ç§»å¤±è´¥:', error);
                        return dataUrl;
                    }
                },
                async processStateForImageMigration(obj) {
                    for (const key in obj) {
                        if (typeof obj[key] === 'string' && obj[key].startsWith('data:image')) {
                            this.showLoading('æ­£åœ¨è¿ç§»å›¾ç‰‡æ•°æ®...');
                            obj[key] = await this.migrateAndSaveImage(obj[key]);
                        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                            await this.processStateForImageMigration(obj[key]);
                        }
                    }
                    return obj;
                },
                saveImageToDB(imageData) {
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['images'], 'readwrite');
                        const store = transaction.objectStore('images');
                        const request = store.put(imageData);
                        request.onsuccess = resolve;
                        request.onerror = reject;
                    });
                },
                getImageFromDB(id) {
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['images'], 'readonly');
                        const store = transaction.objectStore('images');
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = reject;
                    });
                },
                saveFontToDB(fontData) {
                    return new Promise((resolve, reject) => {
                        if (!this.db) return reject("æ•°æ®åº“æœªåˆå§‹åŒ–");
                        const transaction = this.db.transaction(['fonts'], 'readwrite');
                        const store = transaction.objectStore('fonts');
                        const request = store.put(fontData);
                        request.onsuccess = () => resolve();
                        request.onerror = event => {
                            console.error("ä¿å­˜å­—ä½“åˆ°DBå¤±è´¥:", event.target.error);
                            if (event.target.error.name === 'QuotaExceededError') {
                                this.isStorageFull = true;
                                this.showStorageFullToast();
                            }
                            reject(event.target.error);
                        };
                    });
                },
                getFontFromDB(fontFamily) {
                    return new Promise((resolve, reject) => {
                        if (!this.db) return reject("æ•°æ®åº“æœªåˆå§‹åŒ–");
                        const transaction = this.db.transaction(['fonts'], 'readonly');
                        const store = transaction.objectStore('fonts');
                        const request = store.get(fontFamily);
                        request.onsuccess = event => resolve(event.target.result);
                        request.onerror = event => reject(event.target.error);
                    });
                },
                deleteFontFromDB(fontFamily) {
                    return new Promise((resolve, reject) => {
                        if (!this.db) return reject("æ•°æ®åº“æœªåˆå§‹åŒ–");
                        const transaction = this.db.transaction(['fonts'], 'readwrite');
                        const store = transaction.objectStore('fonts');
                        const request = store.delete(fontFamily);
                        request.onsuccess = () => resolve();
                        request.onerror = event => reject(event.target.error);
                    });
                },
                getAllFontsFromDB() {
                    return new Promise((resolve, reject) => {
                        if (!this.db) return reject("æ•°æ®åº“æœªåˆå§‹åŒ–");
                        const transaction = this.db.transaction(['fonts'], 'readonly');
                        const store = transaction.objectStore('fonts');
                        const request = store.getAll();
                        request.onsuccess = event => resolve(event.target.result);
                        request.onerror = event => reject(event.target.error);
                    });
                },
                async loadFontsFromDB() {
                    try {
                        const fonts = await this.getAllFontsFromDB();
                        this.uploadedFonts = [];
                        for (const font of fonts) {
                            this.uploadedFonts.push({ family: font.family, fullName: font.fullName, type: 'uploaded' });
                            try {
                                const fontFace = new FontFace(font.family, font.data);
                                await fontFace.load();
                                document.fonts.add(fontFace);
                            } catch (e) {
                                console.error(`ä»DBåŠ è½½å­—ä½“ "${font.family}" å¤±è´¥:`, e);
                            }
                        }
                        console.log(`ä»æ•°æ®åº“åŠ è½½äº† ${this.uploadedFonts.length} ä¸ªå­—ä½“ã€‚`);
                    } catch (e) {
                        console.error("ä»DBåŠ è½½æ‰€æœ‰å­—ä½“å¤±è´¥:", e);
                    }
                },
                async showFontManager() {
                    const listEl = this.elements.fontManagerModal.querySelector('#font-manager-list');
                    if (!listEl) return;
                    listEl.innerHTML = '<div class="spinner" style="margin: 20px auto;"></div>';
                    this.elements.fontManagerModal.classList.add('visible');
                    
                    const fonts = await this.getAllFontsFromDB();
                    if (!fonts || fonts.length === 0) {
                        listEl.innerHTML = '<div class="empty-font-list">æš‚æ— å·²ä¸Šä¼ çš„å­—ä½“</div>';
                        return;
                    }
                    
                    listEl.innerHTML = fonts.map(font => `
                        <div class="font-manager-item" data-font-family="${this.escapeHTML(font.family)}">
                            <span class="font-manager-item-name">${this.escapeHTML(font.fullName)}</span>
                            <button class="btn btn-danger btn-icon font-delete-btn" title="åˆ é™¤å­—ä½“">
                                <span class="iconify" data-icon="mdi:delete"></span>
                            </button>
                        </div>
                    `).join('');
                },
                async deleteFont(fontFamily) {
                    if (await this.showConfirm('åˆ é™¤å­—ä½“', `ç¡®å®šè¦åˆ é™¤å­—ä½“ "${fontFamily}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
                        try {
                            this.pushHistory(`åˆ é™¤å­—ä½“ ${fontFamily}`);
                            await this.deleteFontFromDB(fontFamily);
                            this.uploadedFonts = this.uploadedFonts.filter(f => f.family !== fontFamily);
                            if (this.state.globalCardStyles.fontFamily === fontFamily) {
                                this.updateState('globalCardStyles.fontFamily', '', false);
                            }
                            this.populateFontList();
                            this.showFontManager();
                            this.showToast(`å­—ä½“ "${fontFamily}" å·²åˆ é™¤ã€‚`, 'success');
                        } catch (e) {
                            this.showErrorModal('åˆ é™¤å¤±è´¥', 'ä»æ•°æ®åº“åˆ é™¤å­—ä½“æ—¶å‡ºé”™ã€‚');
                        }
                    }
                },
                
                showStorageFullToast() {
                    this.elements.storageWarningBanner.style.display = 'block';
                    this.elements.body.classList.add('storage-warning');
                },
                removeStorageFullToast() {
                    this.elements.storageWarningBanner.style.display = 'none';
                    this.elements.body.classList.remove('storage-warning');
                },
                
                sanitizeHTML(htmlString) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlString;
                    tempDiv.querySelectorAll('script, style, link, object, embed, iframe').forEach(el => el.remove());
                    tempDiv.querySelectorAll('*').forEach(el => {
                        for (const attr of [...el.attributes]) {
                            if (attr.name.startsWith('on')) {
                                el.removeAttribute(attr.name);
                            }
                        }
                    });
                    return tempDiv.innerHTML;
                },

                renderMobileEditPencils() {
                    // Remove existing pencils
                    this.elements.previewWrapper.querySelectorAll('.mobile-edit-pencil').forEach(p => p.remove());

                    const isLocked = this.elements.previewBlocksContainer.classList.contains('locked-mode');
                    if (isLocked) return;

                    // Add new pencils
                    this.elements.previewWrapper.querySelectorAll('[data-state-key], [data-card-key], [data-separator-text-key], .tag-pill span[data-tag-id]').forEach(el => {
                        const pencil = document.createElement('div');
                        pencil.className = 'mobile-edit-pencil';
                        pencil.innerHTML = '<span class="iconify" data-icon="mdi:pencil"></span>';
                        el.appendChild(pencil);
                    });
                },
            };
            App.init();
        });
    </script>
</body>
</html>
